# Knowledge Integrator: Synthesized Learnings - Meeting Scheduling Task

This document synthesizes learnings from multiple iterations of experiments focused on solving meeting scheduling tasks using LLMs. It serves as a running log of our understanding, effective strategies, failure modes, and experimental findings specific to this dataset.

## 1. DATASET PATTERNS & CHARACTERISTICS

*   **Consistent Template:** Questions consistently follow the format: "You are an expert at scheduling meetings..." followed by detailed constraints on participants, duration, and time preferences, and concluding with their existing schedules.
    *   *Example:* "You are an expert at scheduling meetings. We need to schedule a meeting for John, Mary, and Peter for 30 minutes..."
*   **Structured Task Description:** The problems follow a consistent structure: an introductory prompt ("You are an expert at scheduling meetings..."), followed by a `TASK` description outlining the meeting requirements (participants, duration, time constraints), then a `Here are the existing schedules...` section detailing each participant's availability, and finally a request to `Find a time that works...`.
*   **Single Meeting Focus:** Each question aims to schedule *one* specific meeting, not a series of meetings or recurring events.
*   **Solution Format:** The "SOLUTION:" part requires a single, specific proposed meeting time, including the day, start time, and end time.
    *   *Example:* "SOLUTION: Monday, 10:00 - 10:30"
*   **Time Frame:** The questions typically constrain meeting times between 9:00 and 17:00 (9 AM to 5 PM) on a specific day or range of days.
*   **Participant Schedules:** The core of the problem involves managing a list of participants and their pre-existing schedules, which are presented as blocked time slots.
*   **Calendar Availability Format:** Participant schedules are described using phrases like "blocked their calendar on Monday during 9:00 to 9:30" or "has meetings on Monday during 9:30 to 10:00". The format is consistent but can be verbose and contain multiple blocks of time. Some participants may have open availability ("Cheryl's calendar is wide open the entire day.").
*   **Consistent Introduction:** The introduction "You are an expert at scheduling meetings..." is consistently used, providing context to the LLM.
*   **Complex Temporal Constraints:** The core of the dataset lies in managing complex temporal constraints. Questions involve scheduling a meeting while considering multiple participants' existing schedules, specific time preferences, and workday boundaries. This requires a high degree of accuracy in parsing and reasoning about time intervals.
*   **Varied Negative Constraints:** The meeting constraints come in different forms. Explicit busy slots, unavailable days, and soft preferences ("would rather not meet") all appear, requiring a system that can handle a diverse range of exclusionary conditions.
*   **Natural Language Description:** Participant schedules are provided in natural language, which is inherently ambiguous and requires robust information extraction capabilities. Dates/times are not provided in a structured format.
*   **Schedule Information Format:** Schedule information is provided in natural language, making accurate parsing difficult. The time slots are often presented in ranges ("9:00 to 10:00") which need to be extracted and processed.
*   **Time Preferences:** Constraints on the meeting time, such as preferred days or time ranges ("Kathleen would rather not meet on Monday after 14:30"), are common and add complexity to the scheduling task.
*   **Implied Constraints:** Besides explicit time blocks, the problem statement sets overall constraints (e.g., "between the work hours of 9:00 to 17:00"). The "Note there exists a solution" clause indicates a feasible meeting time *must* exist.

## 2. EFFECTIVE TASK-SPECIFIC STRATEGIES

*   **Constraint Extraction (Inconclusive):** Extracting key constraints like participants, duration, available days, and time preferences appears to be a necessary initial step, but on its own does not lead to effective solutions. *Further testing is needed to confirm information extraction accuracy*.
*   **Deterministic Time-Slot Generation (Untested):** Generating all possible time slots and then filtering based on participant availability is a proposed strategy. *This has not yet been tested*.
*   **High-Level Multi-Agent Approach (Promising):** Decomposing the complex task into smaller, more manageable steps (data extraction, option generation, filtering, and verification) shows promise.
*   **LLM Reasoning for Time Slot Generation (Useful Component):** The LLM's ability to generate potential time slots based on constraints is a useful component, suggesting the LLM's reasoning abilities are helpful in this aspect of the task. However, this component is insufficient on its own.
*   *There are no working strategies because the accuracy was 0.00 in Iteration 4.*
*   **N/A** - Iteration 2 showed that even with 60% accuracy, there aren't any working strategies to highlight, suggesting more refinement is required.

## 3. COMMON FAILURE MODES ON THIS DATASET

*   **Invalid JSON Output:** The primary and complete failure mode is the LLM's inability to produce valid JSON when extracting constraints. The error message "Expecting value: line 1 column 1 (char 0)" indicates a completely malformed JSON output. This halts the entire scheduling process. The LLM appears to struggle with the complex extraction task.
*   **Robustness with Complex Calendar Information:** The problems with a large number of participants and time blocks in their schedules appear more prone to constraint extraction errors.
*   **"Could not find a valid meeting time" Error:** This is the most frequent error. It indicates a failure in the `find_available_time` function or a problem with the information passed to it, preventing the system from identifying feasible meeting slots. This occurs even when a valid solution exists.
*   **Incorrect Time Suggestion:** The system proposes meeting times that violate the specified constraints or overlap with existing schedules, even when a valid time is available. This indicates that the verification step is ineffective. Example: proposing "Monday 9:30-10:00" when the correct answer is "Monday, 9:00 - 9:30".
*   **Multiple Time Suggestions:** The system returns a *list* of possible meeting times instead of a single time, violating the expected output format.
*   **Conversational Filler:** The LLM includes conversational filler or intermediate reasoning steps in the final answer, rather than just the specific time slot.
*   **Unselected Preference:** The selected single time does not correspond to the expressed preference, if any.
*   **Schedule Conflict Errors:** The system frequently fails to accurately identify and avoid scheduling conflicts based on the provided participant schedules. It often proposes meeting times that overlap with a participant's existing commitments as evidenced in the failure examples where the proposed meeting times directly conflicted with participant availability. The error lies in the filtering or verification steps.
*   **Preference Violation:** It fails to correctly apply the time preferences and negative constraints, leading to violations of meeting constraints (e.g., scheduling a meeting on a day a participant "would rather not" meet). This arises from not correctly interpreting these types of constraints in the parsing step, or not correctly filtering them in the filtering or verification steps.
*   **Ambiguous Language:** There may be errors arising due to the way the existing schedules are provided in natural language. Ambiguities might lead to misinterpretation and therefore errors in extracted times.
*   **Inaccurate Data Extraction:** The primary failure occurs during the initial extraction of schedule data. Example: the system claims "Error: Inaccurate data extraction" when it should be extracting schedule blocks. This results from parsing being done with regular expressions instead of LLM extraction.

## 4. EXPERIMENT LOG & FINDINGS

*   **Iteration 0:**
    *   *Approach:* Initial exploration using LLM-driven constraint extraction, time slot finding, and solution verification with chain-of-thought prompting.
    *   *Finding:* LLMs are capable of understanding the scheduling task and extracting the constraints using chain-of-thought prompting, but struggle with the final step of distilling possible times down to a single, correct solution in the required format. The chain-of-thought identifies the valid times, but isn't sufficient to choose one in particular.
*   **Iteration 1:**
    *   *Approach:* Refinement of the initial approach, focusing on LLM-driven extraction and verification.
    *   *Finding:* The LLM alone, even with the "expert" persona, cannot reliably generate valid meeting times based on the provided constraints. Accuracy remains low, with the dominant failure being "Could not find a valid meeting time".
    *   *Rejection:* The hypothesis that LLM-driven extraction and verification, chained together in this specific manner, would lead to reasonable accuracy has been rejected.
*   **Iteration 2:**
    *   *Approach:* Exploration strategy used, focusing on constraint parsing and viable time filtering.
    *   *Finding:* Revealed limitations in constraint handling, especially parsing provided natural language schedules and filtering the viable times effectively. Constraints were parsed, but were either not correctly interpreted or implemented when identifying the meeting time. LLM reasoner may require additional few-shot examples on parsing the data accurately. Accuracy was 60%.
*   **Iteration 3:**
    *   *Approach:* Multi-agent approach decomposing the complex task into smaller steps (data extraction, option generation, filtering, and verification).
    *   *Finding:* The multi-agent approach, in its current implementation, struggles with precise data extraction from natural language schedule descriptions. The verification process isn't sufficiently catching errors in time slot selection. Regular expressions are used for parsing instead of LLM extraction.
*   **Iteration 4:**
    *   *Approach:* An attempt was made to rely solely on the LLM to extract a complex JSON directly from unstructured text with validation loops.
    *   *Finding:* The LLM cannot reliably extract constraints and provides malformed JSON outputs. Accuracy was 0.00.
    *   *Rejection:* The hypothesis that the LLM could reliably extract constraints with validation was strongly rejected. The verification loops are not sufficient for this extraction.
    *   *Script Errors:* Script failed to extract valid constraints during repair attempts.

## 5. NEXT RESEARCH DIRECTIONS

*   **Simplify Constraint Extraction:** Break down the constraint extraction process into smaller, more manageable steps. Instead of asking for a full JSON in one go, extract individual pieces of information (participants, duration, time ranges) using separate LLM calls with simpler prompts.
*   **Code-Assisted Parsing:** Use Python code to pre-process the input and extract basic information (e.g., participant names) before passing it to the LLM. This reduces the LLM's workload and makes the extraction task easier.
*   **Few-Shot Example Optimization:** Carefully design a few-shot learning prompt with multiple examples that demonstrate the *exact* JSON format required, and with examples showcasing how to deal with varied calendar descriptions. Consider adding a system prompt focused solely on output format constraints.
*   **Specialized Information Extraction:** Refine or create specialized agents for different types of information extraction to simplify the work and make the task easier.
*   **Focus on Improving `find_available_time`:** This function is a bottleneck. Refactor and optimize the core logic to reliably identify valid meeting slots based on the extracted constraints.
*   **Implement and Test Deterministic Time-Slot Generation:** Generate all possible time slots, then filter based on availability to reduce the solution space.
*   **Verify Constraint Extraction Output:** Implement targeted tests to confirm the LLM is correctly understanding and extracting the constraints. Expand example sets or refine the prompt if information is missing.
*   **Replace LLM Verification with Programmatic Logic:** Implement deterministic, programmatic logic to replace the LLM-based solution verification. The programmatic logic should be based on the extracted constraints to eliminate potential misinterpretations and improve reliability.
*   **Prompt Engineering for Single Time Output:** Continue refining prompts to explicitly instruct the LLM to provide a single, specific proposed meeting time in the required format. Add more few-shot examples demonstrating this format.
*   **Prioritization Logic:** Develop a method to prioritize possible times, potentially based on participant preferences or other criteria. Prompt the LLM to explain its prioritization rationale.
*   **Post-Processing for Single Time Output:** Implement a post-processing step to *enforce* a single time output. If the LLM provides multiple options, have it re-reason to select the best single option. If that fails, choose the first valid option programmatically.
*   **Improve Schedule Parsing:** The information extraction component needs to be more precise in parsing participant schedules. Consider implementing a specialized agent for schedule parsing.
    *   Consider using more few-shot examples that demonstrate negative constraints.
    *   Break the schedule parsing down into smaller components so that it is easier to diagnose where the failures happen.
    *   **Replace regular expressions and brittle parsing with LLM-driven extraction using chain-of-thought prompting.**
    *   **Provide the LLM with multiple examples of schedule parsing and explicit instructions for extracting data correctly.**
    *   **Include verification steps for the data extraction agent, prompting the LLM to confirm extracted information against the original text.**
*   **Enhanced Filtering Logic**: Refine the logic for filtering and verifying potential meeting times to ensure that all constraints are strictly enforced.
    *   Implement a verification loop with a well defined output structure that the verification is forced to provide, ensuring more accuracy.
    *   Use a deterministic function for calculating if a time slot overlaps a schedule and enforce that within the filtering logic.
*   **Constraint Representation**: Explore using a more structured intermediate representation for constraints.
    *   Represent explicit schedule times and exclusionary constraints as a list of disallowed times.
*   **Verification Focus:** Enhance the verification steps to explicitly check for constraint violations *before* providing a final time.
    *   Consider implementing a verification agent that validates the proposed meeting time does not conflict with any constraints.
    *   **Enhance the verification prompts to explicitly check for common errors, such as overlapping time slots or violations of constraints.**
    *   **Add more examples to the verification prompt to improve accuracy.**
*   **Deterministic Filtering:** Ensure the filtering logic accurately implements the constraints. Use Python code to represent available time slots as a series of 15- or 30-minute blocks, and then filter them based on extracted constraints. This would provide a deterministic way of verifying the availability of each participant.