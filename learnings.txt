# Synthesized Learnings: Scheduling Task Dataset

This document captures accumulated learnings from experiments on the scheduling task dataset. It focuses on dataset-specific patterns, effective strategies, common failure modes, and an experiment log to guide future research directions.

## 1. DATASET PATTERNS & CHARACTERISTICS

*   **Question Structure:** Questions are formatted as instructions to schedule a meeting, followed by specific constraints on participant schedules, meeting duration, and time preferences. A consistent structure is observed: An introductory sentence setting the stage, a `TASK` describing the meeting to be scheduled, participant schedules presented sequentially, and a `SOLUTION` prompt.

    *   *Example:* "Schedule a meeting for John, Mary for 30 minutes. John is busy: Monday 9am-12pm, Tuesday 1pm-3pm. Mary is busy: Monday 10am-11am, Wednesday 2pm-4pm."
*   **Consistent Template:** The questions follow a consistent template: a preamble describing the task as scheduling a meeting, constraints on participants' schedules, a specified duration, and a desired meeting time.
*   **Explicit Schedules:** The dataset provides explicit schedules for each participant, indicating busy slots. A core task element is parsing the natural language schedule descriptions to extract the blocked time slots.
    *   The existing schedules are always presented as a list of participants and their blocked time slots in a "X is busy on Day during Start_Time to End_Time" format.
*   **Natural Language Time Constraints:** Time constraints are expressed using natural language descriptions of busy time blocks. This requires the LLM to accurately parse and interpret these time ranges.

    *   *Example:* "Monday 9am-12pm" indicates that the participant is unavailable between 9:00 AM and 12:00 PM on Monday.
*   **Negative Constraints & Preferences:** The dataset includes negative constraints, such as "Harold would rather not meet on Monday after 14:00," requiring the system to handle preferences in addition to hard constraints. The presence of participant preferences (e.g., "do not want to meet on Tuesday before 11:00") adds complexity to the constraint satisfaction problem. Incorporating negative constraints effectively in the LLM prompt is important: For example, if Douglas doesn't want to meet after 13:30 on Monday, this constraint should be phrased more directly in the prompt.
    *   Many questions include an "earliest availability" constraint, adding a layer of complexity to finding a suitable slot.
    *   Some questions also add preferences (e.g., "Kathleen would rather not meet on Monday after 14:30").
*   **Multiple Days:** Some questions span multiple days, requiring the system to correctly calculate the schedule and consider time ranges across different days without mixing them up.
*   **Single-Slot Bias:** The "SOLUTION:" in the dataset often provides just one possible meeting time, creating a bias towards single-slot answers, even when multiple solutions exist. This biases the system towards finding just *one* possible meeting time instead of evaluating and prioritizing among various possible valid meeting times.
*   **Consistent Use of Blocked Times:** Participant schedules are consistently described using blocked times. This allows for targeted information extraction of these time intervals.
*   **Meeting Duration Constraints:** Questions always specify a meeting duration, which must be considered when finding available slots.
*   **Work Hour Constraints:** Questions frequently include constraints on valid work hours (e.g., "schedule during work hours").

## 2. EFFECTIVE TASK-SPECIFIC STRATEGIES

*   **"Extract-then-Solve" Approach:** The decomposition of the problem into `extract_meeting_data` (identifying key information) and `find_available_slots` (scheduling based on extracted data) is fundamentally sound. This allows for more targeted LLM prompting and isolates failure points.
*   **LLM for Information Extraction:** The use of LLM for information extraction with few-shot examples has potential. The strategy of providing context with the "expert at scheduling meetings" prompt seems promising for framing the task.
*   **Verification Loop:** Implementing a verification step after information extraction to validate the extracted schedules and constraints is valuable. This helps ensure data accuracy and isolate the problem of failures to `find_available_slots`, and makes debugging failures in later steps easier. The implementation needs refinement to handle edge cases and complex schedules effectively.
*   **Structured Extraction:** Structured extraction using LLMs seems partially effective in extracting the schedules and constraints. The error examples show that the extraction *is* happening, but the downstream processing is flawed.
*   **LLM for Validation and Refinement:** The use of LLM for validating and refining extraction hints towards improvements in data accuracy.
*   **ReAct Agent Framework:** The ReAct agent framework is a reasonable starting point, as it allows for iterative refinement of the proposed solution by reasoning about constraints and acting to find valid time slots.
*   **LLM Candidate Time Proposal:** Leveraging the LLM to directly propose candidate meeting times appears to be efficient, as it reduces the need for explicit programmatic enumeration of all possible time slots.

## 3. COMMON FAILURE MODES ON THIS DATASET

*   **Inaccurate Schedule Extraction:** The primary failure mode is inaccurate extraction of schedules and constraints. The system fails to correctly identify all available time slots for participants and incorrectly marks slots as unavailable. This often results in proposing meeting times that conflict with existing schedules or preferences.
    *   *Example:* Failing to identify that John is available on Monday from 12pm-5pm, given the constraint "John is busy: Monday 9am-12pm".
*   **Incorrect Constraint Handling:** The system struggles with questions that require integrating multiple constraints. For example, when both participants have preferences for certain days, the system often fails to find the optimal solution that satisfies both constraints or fails to exclude days altogether. The current implementation doesn't sufficiently prioritize constraints.
*   **Complex Algorithm for Determining Available Time Slots:** The core of the problem lies in the complexity of algorithm for determining available time slots based on participant schedules. The system seems to be making mistakes in identifying the intersection of free time, often overlooking busy slots or misinterpreting the time ranges. The `find_available_slots` function's logic is failing to correctly process the extracted schedules to determine actual availability for *all* participants, resulting in incorrect time slot proposals. For example, the system proposes Monday 11:00-11:30, even though the correct answer is Monday 12:00-12:30.
*   **Multiple Day Schedule Handling:** The system struggles with questions spanning multiple days. It might correctly parse individual time constraints, but it incorrectly calculates the schedule when the question spans multiple days, such as mixing up time ranges across days.
*   **Prioritization of Multiple Valid Time Slots:** The `find_available_slots` function produces *multiple* valid time slots, while the expected answer is often a *single* time slot. The system struggles with prioritization when multiple possibilities exist. The constraints and preferences are not being weighted to select the *best* option from the viable options, thus failing to generate a single solution.
*   **Verbose Output:** The system's final answer presentation can be overly verbose, including extraneous reasoning steps instead of directly providing the proposed time.
*   **Constraint Checking Errors:** The system proposes meeting times that conflict with participant schedules, indicating issues with constraint checking. *Example:* The system proposed Tuesday 9:00-9:30 even though Patricia has blocked their calendar on Tuesday during 10:30 to 12:00, 13:30 to 15:00, 16:00 to 17:00.
*   **Earliest Availability Failures:** The system fails to accurately identify and apply "earliest availability" constraints.
*   **Inaccurate Time Range Extraction:** The system fails to accurately extract the time ranges during which participants are available.

## 4. EXPERIMENT LOG & FINDINGS

*   **Iteration 0:**
    *   Exploration strategy: Using an LLM for both data extraction and slot finding.
    *   Result: Low accuracy. Confirmed the hypothesis that direct extraction of meeting data using LLM can lead to inaccurate data.
*   **Iteration 1:**
    *   Exploitation strategy: Using "extract-then-solve" approach with verification loop.
    *   Result: Achieved a baseline accuracy of 60%. The verification loop helps isolate the problem of failures to `find_available_slots`.
*   **Iteration 2:**
    *   Exploitation strategy: Continued exploitation of the structured approach of LLM-driven data extraction and slot-finding.
    *   Result: No accuracy improvement compared to the previous iteration. Indicates the current implementation has reached a local optimum, and more significant modifications are needed. Highlights that the verification loop, while useful for extraction accuracy, doesn't address the core problem of slot prioritization and constraint satisfaction.
*   **Iteration 3:**
    *   Strategy: Single-agent chain-of-thought approach for structured information extraction.
    *   Result: Showed some promise in extracting structured information, but revealed a weakness in complex constraint reasoning and slot availability determination. Low overall accuracy indicates that the current implementation is not robust enough to handle the dataset's complexity.
*   **Iteration 4:**
    *   Strategy: ReAct agent framework for iterative refinement of the proposed solution.
    *   Result: Demonstrated promise as a reasonable starting point but proved insufficient to handle the complexity of checking multiple schedules in its current implementation. Reliance on LLM to determine valid times (rather than verification) leads to inaccuracies.

## 5. NEXT RESEARCH DIRECTIONS

*   **Improve Information Extraction Accuracy:** Revise the `extract_meeting_data` function with more effective prompting strategies, potentially using chain-of-thought reasoning to guide the LLM in parsing the text and extracting data. Provide more diverse few-shot examples to cover a broader range of schedule descriptions and constraints. Specifically create a specific information extraction prompt for the time intervals when participants are busy. Represent each person's schedule with start and end times so that it can be programmatically checked.
*   **Alternative Extraction Formats:** Experiment with different extraction formats. Instead of extracting all data at once, try extracting each participant's schedule separately and then combining the results. This might improve accuracy by breaking the problem into smaller, more manageable chunks. Also, add the "SOLUTION:" as one of the key/value pairs in the extraction prompt to guide the LLM on providing accurate answers.
*   **Robust Constraint Solver:** Redesign the `find_available_slots` function with a more robust constraint solver. The current algorithm is insufficient. Convert time ranges and constraints into a more mathematically precise format to improve precision. This requires a *major revamp* prioritizing correct logic and comprehensive test cases to ensure accurate availability determination based on *all* participants' schedules and the meeting duration. Consider using deterministic Python code for this calculation once the schedule extractions are confirmed to be correct. Implement a rigorous programmatic constraint-checking mechanism. After the LLM proposes a meeting time, use Python code to explicitly verify that the time slot does not conflict with any participant's schedule.
*   **Rule-Based Constraint Filtering:** Explore alternative approaches to constraint handling. Rather than directly encoding the constraints into the available slot finding prompt, try using a rule-based approach to filter the available slots based on the constraints.
*   **Multiple Day Schedule Handling:** Improve the handling of multiple days in the scheduler so that time ranges across different days are not mixed up and incorrectly handled.
*   **Constraint and Preference Prioritization:** Modify the `find_available_slots` stage to explicitly prioritize constraints and preferences. Introduce a scoring mechanism to evaluate potential time slots based on how well they satisfy all constraints.
*   **Post-Processing for Best Solution Selection:** Implement a post-processing step that filters the multiple time slots to select the best single solution based on preference criteria.
*   **Clarify Output:** Simplify the final output to provide only the proposed meeting time in the format "Here is the proposed time: Day, Start_Time - End_Time". Remove the surrounding explanation.
*   **Detailed Logging:** Add detailed logging of the extracted schedules and the logic used to determine available slots to better diagnose failures.
*   **Verification of `find_available_slots` output:** Before returning a proposed solution, use an LLM to verify the solution.
*   **Earliest Availability Logic:** Implement logic to specifically address "earliest availability." If this constraint is present, sort the available time slots and return the first one.
*   **Few-Shot Examples for Multiple Schedules:** Add few-shot examples to the prompt to demonstrate how the agent should reason about multiple schedules and select a time slot that satisfies all constraints.