
            You are performing SURGICAL REFINEMENT of the single best-performing script.
            Your goal is to identify specific weaknesses in this script and make targeted improvements while preserving its strengths.

            Here are example problems from previously seen data:
            [
  {
    "id": 0,
    "question": "In Heidi's history class, the only grades that count toward the semester average are the $6$ tests she has already taken and the upcoming final exam. The final exam counts as two tests. Heidi has determined that if she earns $99$ points on the final she will have exactly a $90$-point average for the semester. On average, how many points has Heidi scored on each test prior to the final exam?",
    "answer": "Set the average for her previous exams to be $x$. The total amount of points including the final will be $6x+2 \\cdot 99$. The average is $\\frac{6x+2 \\cdot 99}{8}=90$. Then we solve for $x$. $$\\frac{6x+2 \\cdot 99}{8}=90 \\rightarrow 6x+198=720 \\rightarrow 6x=522 \\rightarrow x=\\boxed{87}.$$"
  },
  {
    "id": 1,
    "question": "Suppose that $\\overline{abcd}$ is a four-digit integer with no digits equal to zero such that $\\overline{ab}$, $\\overline{bc}$, and $\\overline{cd}$ are distinct integers that each divide into $\\overline{abcd}$. Find the smallest possible value of $\\overline{abcd}$.",
    "answer": "Since $\\overline{ab} | \\overline{abcd} = 100 \\cdot \\overline{ab} + \\overline{cd}$, then $\\overline{ab}$ also divides into $\\overline{abcd} - 100 \\cdot \\overline{ab} = \\overline{cd}$. Similarly, since $\\overline{cd} | \\overline{abcd} = 100 \\cdot \\overline{ab} + \\overline{cd}$, then $\\overline{cd}$ must divide into $\\overline{abcd} - \\overline{cd} = 100 \\cdot \\overline{ab}$. To minimize $\\overline{abcd}$, then we would like to try $a = b = 1$. It follows that $\\overline{cd}$ is divisible by $11$, and also divides into $100 \\cdot \\overline{ab} = 1100$. Thus, $\\overline{cd} = 11,22,44,55$, but we can eliminate the first due to the distinctness condition. Trying each of the others, we see that $1122 = 2 \\cdot 3 \\cdot 11 \\cdot 17$ is not divisible by $12$; $1144 = 2^3 \\cdot 11 \\cdot 13$ is not divisible by $14$; and $\\boxed{1155} = 3 \\cdot 5 \\cdot 7 \\cdot 11$ is indeed divisible by $15$."
  },
  {
    "id": 2,
    "question": "There are real numbers $a$ and $b$ such that for every positive number $x$, we have the identity\n\\[\n  \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) + \\tan^{-1}(ax) + \\tan^{-1}(bx) \n    = \\frac{\\pi}{2} \\, .\n\\](Throughout this equation, $\\tan^{-1}$ means the inverse tangent function, sometimes written $\\arctan$.)  What is the value of $a^2 + b^2$?",
    "answer": "By the tangent addition formula,\n\\[\\tan (\\tan^{-1} p + \\tan^{-1} q) = \\frac{p + q}{1 - pq}.\\]From the given equation,\n\\[\\tan^{-1} ax + \\tan^{-1} bx = \\frac{\\pi}{2} - \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right).\\]Then\n\\[\\tan (\\tan^{-1} ax + \\tan^{-1} bx) = \\tan \\left( \\frac{\\pi}{2} - \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) \\right),\\]The left-hand side is $\\frac{ax + bx}{1 - abx^2}.$  The right-hand side is\n\\begin{align*}\n\\tan \\left( \\frac{\\pi}{2} - \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) \\right) &= \\frac{1}{\\tan \\left( \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) \\right)} \\\\\n&= \\frac{1}{\\frac{1}{x} - \\frac{x}{8}} \\\\\n&= \\frac{x}{1 - \\frac{1}{8} x^2}.\n\\end{align*}Hence, $a + b = 1$ and $ab = \\frac{1}{8},$ so\n\\[a^2 + b^2 = (a + b)^2 - 2ab = 1 - \\frac{2}{8} = \\boxed{\\frac{3}{4}}.\\]"
  }
]

            
        ITERATION HISTORY SUMMARY:
        - Total iterations completed: 1
        - Current explore/exploit balance: 60/20
        - Best accuracy achieved: 0.50 (iteration 0)

        APPROACH HISTORY (last 1 iterations):
        [
  {
    "iteration": 0,
    "strategy": "baseline",
    "accuracy": 0.5,
    "approach": "Simple baseline script: Direct LLM call without sophisticated techniques"
  }
]

        COMMON ERROR PATTERNS:
        []

        PRIMARY ISSUES (last 1 iterations):
        [
  {
    "iteration": 0,
    "issue": "The most critical problem to fix is the **inaccuracy in performing arithmetic and logical calculations**. This includes median calculation, LCM calculations, and general numerical manipulation errors within algebraic solutions. This undermines the entire solution process, even if the initial problem setup and equation formulation are correct."
  }
]

        TARGETED IMPROVEMENTS:
        [
  "Add more Print Statements for Future Debugging:** Add more print statements to show the intermediate stages of calculations so that in the future you can tell where things went wrong.",
  "Enhanced Constraint Handling:** Add explicit checks and validation steps to ensure all problem constraints are considered throughout the solution process. This could involve using automated constraint satisfaction techniques or incorporating constraint programming elements.",
  "Implement a Numerical Verification Module:** Integrate a numerical verification module to double-check the correctness of arithmetic computations. This could involve unit testing or using an external calculator to confirm results. For median calculation, explicitly check all values and their positions in sorted order."
]
        

EXAMPLE OF EFFECTIVE LLM USAGE PATTERNS:

```python
def extract_information_with_examples(text):
    """Extract key information from the input text using embedded examples."""
    system_instruction = "You are an information extraction specialist focusing on identifying key entities and relationships."
    
    prompt = f"""
    Extract key information from this text. Focus on identifying all entities, relationships, and important attributes.
    
    Example usage:
    
    Input Text:
    The company XYZ Corp reported quarterly earnings of $3.5 million, which represents a 12% increase from last year. The CEO, Jane Smith, attributed this growth to their new product line launched in March, which has already captured 8% of the market share. They expect to expand their operations to Europe by Q2 2023.
    
    Let's think step by step.
    
    The key entities are:
    - XYZ Corp (company)
    - Jane Smith (person, CEO)
    - New product line (product)
    
    The key information points are:
    - Financial: Quarterly earnings of $3.5 million
    - Performance: 12% increase from previous year
    - Product: New product line launched in March
    - Market: 8% market share for new product
    - Plans: Expansion to Europe by Q2 2023
    
    Extracted Information:
    {{
      "entities": [
        {{"name": "XYZ Corp", "type": "company"}},
        {{"name": "Jane Smith", "type": "person", "role": "CEO"}},
        {{"name": "New product line", "type": "product", "launch_date": "March"}}
      ],
      "financial_data": {{
        "quarterly_earnings": "$3.5 million",
        "growth_rate": "12%"
      }},
      "market_data": {{
        "product_market_share": "8%"
      }},
      "future_plans": [
        {{"type": "expansion", "region": "Europe", "timeline": "Q2 2023"}}
      ]
    }}
    
    Now, extract information from this new text:
    {text}
    """
    
    return call_llm(prompt, system_instruction)
```

```python
def verify_solution_with_examples(problem, proposed_solution):
    """Verify if the proposed solution satisfies all requirements using embedded examples."""
    system_instruction = "You are a critical evaluator who verifies if solutions correctly address problems."
    
    prompt = f"""
    Verify if this proposed solution correctly addresses all aspects of the problem.
    
    Example usage:
    
    Problem:
    Design a data structure that can efficiently perform the following operations:
    1. Insert a value
    2. Delete a value
    3. Get a random value with equal probability for all stored values
    All operations should have average time complexity of O(1).
    
    Proposed Solution:
    I'll use a combination of a hashmap and an array. The hashmap will store the value as the key and its index in the array as the value. The array will store all the inserted values.
    
    For insert: Add the value to the end of the array and update the hashmap with the value and its index. O(1) time.
    
    For delete: Look up the index of the value in the hashmap, swap the value with the last element in the array, update the hashmap for the swapped element, remove the last element from the array, and remove the value from the hashmap. O(1) time.
    
    For get random: Generate a random index within the array's bounds and return the value at that index. O(1) time.
    
    Verification:
    Let me check each requirement:
    1. Insert operation: The solution adds the value to the end of the array and updates the hashmap with O(1) time complexity ✓
    2. Delete operation: The solution uses the hashmap to find the index, then swaps with the last element and updates accordingly with O(1) time complexity ✓
    3. Get random operation: The solution generates a random index within the array bounds with O(1) time complexity ✓
    4. All operations have O(1) average time complexity ✓
    
    Result: VALID - The solution correctly addresses all requirements with the specified time complexity.
    
    Problem:
    {problem}
    
    Proposed Solution:
    {proposed_solution}
    
    Verification:
    """
    
    return call_llm(prompt, system_instruction)
```

```python
def solve_with_validation_loop(problem, max_attempts=3):
    """Solve a problem with iterative refinement through validation feedback loop."""
    system_instruction_solver = "You are an expert problem solver who creates detailed, correct solutions."
    system_instruction_validator = "You are a critical validator who carefully checks solutions against all requirements."
    
    # Initial solution generation
    solution_prompt = f"""
    Provide a detailed solution to this problem. Be thorough and ensure you address all requirements.
    
    Problem:
    {problem}
    """
    
    solution = call_llm(solution_prompt, system_instruction_solver)
    
    # Validation loop
    for attempt in range(max_attempts):
        # Validate the current solution
        validation_prompt = f"""
        Carefully validate if this solution correctly addresses all aspects of the problem.
        If the solution is valid, respond with "VALID: [brief reason]".
        If the solution has any issues, respond with "INVALID: [detailed explanation of issues]".
        
        Problem:
        {problem}
        
        Proposed Solution:
        {solution}
        """
        
        validation_result = call_llm(validation_prompt, system_instruction_validator)
        
        # Check if solution is valid
        if validation_result.startswith("VALID:"):
            return solution
        
        # If invalid, refine the solution
        refined_prompt = f"""
        Your previous solution to this problem has some issues that need to be addressed.
        
        Problem:
        {problem}
        
        Your previous solution:
        {solution}
        
        Validation feedback:
        {validation_result}
        
        Please provide a completely revised solution that addresses all the issues mentioned.
        """
        
        solution = call_llm(refined_prompt, system_instruction_solver)
    
    return solution
```

```python
def multi_perspective_analysis(problem):
    """Analyze a problem from multiple specialized perspectives and synthesize the insights."""
    # Define specialized analysis functions
    def analyze_factual_content(problem):
        system_instruction = "You are a factual analyst who focuses on identifying key facts and data points."
        prompt = f"""
        Analyze this problem for factual content only. Identify explicit facts, constraints, and requirements.
        
        Problem:
        {problem}
        """
        return call_llm(prompt, system_instruction)
    
    def analyze_structure(problem):
        system_instruction = "You are a structural analyst who specializes in problem organization and patterns."
        prompt = f"""
        Analyze the structure of this problem. Identify its components, relationships, and patterns.
        
        Problem:
        {problem}
        """
        return call_llm(prompt, system_instruction)
    
    # Execute parallel analyses
    factual_analysis = analyze_factual_content(problem)
    structural_analysis = analyze_structure(problem)
    
    # Synthesize the results
    synthesis_prompt = f"""
    Synthesize these two different analyses of the same problem into a comprehensive understanding.
    
    Factual Analysis:
    {factual_analysis}
    
    Structural Analysis:
    {structural_analysis}
    
    Provide a unified analysis that leverages both perspectives.
    """
    
    return call_llm(synthesis_prompt, "You are an insight synthesizer who combines multiple analyses.")
```

```python
def best_of_n_approach(problem, n=3):
    """Generate multiple solutions and select the best one based on a quality evaluation."""
    system_instruction_solver = "You are an expert problem solver who provides detailed, correct solutions."
    system_instruction_evaluator = "You are a quality evaluator who assesses solutions based on correctness, completeness, and clarity."
    
    # Generate n different solutions
    solutions = []
    for i in range(n):
        diversity_factor = f"Solution approach {i+1}/{n}: Use a different perspective from previous solutions."
        solution_prompt = f"""
        Provide a detailed solution to this problem.
        {diversity_factor if i > 0 else ""}
        
        Problem:
        {problem}
        """
        
        solutions.append(call_llm(solution_prompt, system_instruction_solver))
    
    # Evaluate each solution
    evaluations = []
    for i, solution in enumerate(solutions):
        evaluation_prompt = f"""
        Evaluate this solution on correctness, completeness, and clarity (1-10 scale).
        
        Problem:
        {problem}
        
        Solution {i+1}:
        {solution}
        
        Provide your evaluation as a JSON with scores and explanation.
        """
        
        evaluations.append(call_llm(evaluation_prompt, system_instruction_evaluator))
    
    # Find the best solution
    comparison_prompt = f"""
    Compare these solutions and their evaluations. Select the best one.
    
    Problem:
    {problem}
    
    {["Solution " + str(i+1) + ": " + solutions[i] + "\n\nEvaluation: " + evaluations[i] for i in range(n)]}
    
    Which solution is best? Respond with the solution number and explanation.
    """
    
    best_solution_index = int(call_llm(comparison_prompt, "You are a solution selector.").split()[1]) - 1
    return solutions[best_solution_index]
```

```python
def solve_with_react_pattern(problem):
    """Solve problems through iterative Reasoning and Acting (ReAct) approach."""
    system_instruction = "You are a problem-solving agent that follows the ReAct pattern: Reason about the current state, take an Action, observe the result, and repeat until reaching a solution."
    
    # Initialize ReAct process
    prompt = f"""
    Solve this problem using the ReAct pattern - alternate between Reasoning and Acting until you reach a final answer.
    
    Example usage:
    
    Problem: What is the capital of the country where the Great Barrier Reef is located, and what is the population of that capital?
    
    Thought 1: I need to determine which country the Great Barrier Reef is in, then find its capital, and finally the population of that capital.
    Action 1: Search[Great Barrier Reef location]
    Observation 1: The Great Barrier Reef is located off the coast of Queensland in northeastern Australia.
    
    Thought 2: Now I know the Great Barrier Reef is in Australia. I need to find Australia's capital city.
    Action 2: Search[capital of Australia]
    Observation 2: The capital of Australia is Canberra.
    
    Thought 3: Now I need to find the population of Canberra.
    Action 3: Search[population of Canberra]
    Observation 3: As of 2021, the population of Canberra is approximately 431,500.
    
    Thought 4: I have found all the required information. The capital of Australia (where the Great Barrier Reef is located) is Canberra, and its population is approximately 431,500.
    Action 4: Finish[The capital of Australia is Canberra, with a population of approximately 431,500.]
    
    Now solve this new problem:
    {problem}
    
    Start with Thought 1:
    """
    
    # Initial reasoning and action planning
    react_response = call_llm(prompt, system_instruction)
    
    # Extract the action from the response
    action = extract_action(react_response)
    
    # Continue the ReAct loop until we reach a "Finish" action
    while not action["type"] == "Finish":
        # Perform the requested action and get an observation
        if action["type"] == "Search":
            observation = perform_search(action["query"])
        elif action["type"] == "Calculate":
            observation = perform_calculation(action["expression"])
        elif action["type"] == "Lookup":
            observation = perform_lookup(action["term"])
        else:
            observation = f"Unknown action type: {action['type']}"
        
        # Continue the ReAct process with the new observation
        continuation_prompt = f"""
        {react_response}
        Observation {action["step_number"]}: {observation}
        
        Continue with the next thought and action:
        """
        
        # Get the next reasoning step and action
        react_response += "\n" + call_llm(continuation_prompt, system_instruction)
        
        # Extract the next action
        action = extract_action(react_response)
    
    # Extract the final answer from the Finish action
    final_answer = action["answer"]
    return final_answer

def extract_action(text):
    """Parse the ReAct response to extract the current action."""
    # Find the last action in the text
    action_matches = re.findall(r"Action (\d+): (\w+)\[(.*?)\]", text)
    if not action_matches:
        return {"type": "Error", "step_number": 0, "query": "No action found"}
    
    # Get the most recent action
    last_action = action_matches[-1]
    step_number = int(last_action[0])
    action_type = last_action[1]
    action_content = last_action[2]
    
    # Handle different action types
    if action_type == "Finish":
        return {"type": "Finish", "step_number": step_number, "answer": action_content}
    elif action_type in ["Search", "Lookup", "Calculate"]:
        return {"type": action_type, "step_number": step_number, "query": action_content}
    else:
        return {"type": "Unknown", "step_number": step_number, "query": action_content}

def perform_search(query):
    """Simulate a search action in the ReAct pattern."""
    # In a real implementation, this would call an actual search API
    return call_llm(f"Provide a factual answer about: {query}", "You are a helpful search engine that provides concise, factual information.")

def perform_calculation(expression):
    """Perform a calculation action in the ReAct pattern."""
    try:
        # Safely evaluate the expression
        result = eval(expression, {"__builtins__": {}}, {"math": math})
        return f"The result is {result}"
    except Exception as e:
        return f"Error in calculation: {str(e)}"

def perform_lookup(term):
    """Simulate a lookup action for specific information."""
    # In a real implementation, this would query a knowledge base or database
    return call_llm(f"Provide specific information about: {term}", "You are a knowledge base that provides specific factual information.")
```MULTI-EXAMPLE PROMPTING GUIDANCE:
        1. CRITICAL: Use MULTIPLE examples (2-5) in EVERY LLM prompt, not just one
        2. Vary the number of examples based on task complexity - more complex tasks need more examples
        3. Select diverse examples that showcase different patterns and edge cases
        4. Structure your few-shot examples to demonstrate clear step-by-step reasoning
        5. Consider using both "easy" and "challenging" examples to help the LLM learn from contrasts
        6. The collection of examples should collectively cover all key aspects of the problem
        7. When available, use examples from previous iterations that revealed specific strengths or weaknesses.
        8. USE REAL EXAMPLES FROM THE DATASET WHERE POSSIBLE!!

        Example of poor single-example prompting:
        ```python
        def extract_entities(text):
            prompt = f'''
            Extract entities from this text.

            Example:
            Text: John will meet Mary at 3pm on Tuesday.
            Entities: {{"people": ["John", "Mary"], "time": "3pm", "day": "Tuesday"}}

            Text: {text}
            Entities:
            '''
            return call_llm(prompt)
        ```

        Example of effective multi-example prompting:
        ```python
        def extract_entities(text):
            prompt = f'''
            Extract entities from this text.

            Example 1:
            Text: John will meet Mary at 3pm on Tuesday.
            Entities: {{"people": ["John", "Mary"], "time": "3pm", "day": "Tuesday"}}

            Example 2:
            Text: The team needs to submit the report by Friday at noon.
            Entities: {{"people": ["the team"], "time": "noon", "day": "Friday", "object": "report"}}

            Example 3:
            Text: Alex cannot attend the conference from Jan 3-5 due to prior commitments.
            Entities: {{"people": ["Alex"], "event": "conference", "date_range": ["Jan 3-5"], "reason": "prior commitments"}}

            Text: {text}
            Entities:
            '''
            return call_llm(prompt)
        ```

        === DIRECT LLM REASONING APPROACH ===

        CRITICAL: Previous scripts have shown that complex code generation with JSON parsing and multi-step pipelines often 
        leads to errors and low performance. Instead, focus on leveraging the LLM's natural reasoning abilities:

        1. SIMPLIFY YOUR APPROACH:
           - Minimize the number of processing steps - simpler is better
           - Directly use LLM for pattern recognition rather than writing complex code
           - Avoid trying to parse or manipulate JSON manually - pass it as text to the LLM

        2. DIRECT TRANSFORMATION:
           - Instead of trying to extract features and then apply them, use the LLM to do the transformation directly
           - Use examples to teach the LLM the pattern, then have it apply that pattern to new inputs
           - Avoid attempting to write complex algorithmic solutions when pattern recognition will work better

        3. ROBUST ERROR HANDLING:
           - Include multiple approaches in case one fails (direct approach + fallback approach)
           - Use simple validation to check if outputs are in the expected format
           - Include a last-resort approach that will always return something valid

        4. AVOID COMMON PITFALLS:
           - Do NOT attempt to use json.loads() or complex JSON parsing - it often fails
           - Do NOT create overly complex Python pipelines that require perfect indentation
           - Do NOT create functions that generate or execute dynamic code
           - Do NOT create unnecessarily complex data transformations

        5. SUCCESSFUL EXAMPLES:
           - The most successful approaches have used direct pattern matching with multiple examples
           - Scripts with simple validation and fallback approaches perform better
           - Scripts with fewer processing steps have higher success rates
        
        IMPLEMENTATION STRATEGIES:
        1. Maintain a "example bank" of successful and failed examples to select from
        2. Implement n-shot prompting with n=3 as default, but adapt based on performance
        3. For complex tasks, use up to 5 examples; for simpler tasks, 2-3 may be sufficient
        4. Include examples with a range of complexity levels, rather than all similar examples



        VALIDATION AND VERIFICATION GUIDANCE:
        1. CRITICAL: Consider implementing validation loops for EACH key processing step, not just final outputs
        2. Design your system to detect, diagnose, and recover from specific errors. This will help future learnings
        3. For every LLM extraction or generation, add a verification step that checks:
           - Whether the output is well-formed and complete
           - Whether the output is logically consistent with the input
           - Whether all constraints are satisfied
        4. Add feedback loops that retry failures with specific feedback
        5. Include diagnostic outputs that reveal exactly where failures occur. Add print statements and intermediate outputs such that you can see them later to determine why things are going wrong.
        6. Include capability to trace through execution steps to identify failure points

        Example of pipeline without verification:
        ```python
        def process_question(question):
            entities = extract_entities(question)
            constraints = identify_constraints(question)
            solution = generate_solution(entities, constraints)
            return solution
        ```

        Example of robust pipeline with verification:
        ```python
        def process_question(question, max_attempts=3):
            # Step 1: Extract entities with verification
            entities_result = extract_entities_with_verification(question)
            if not entities_result.get("is_valid"):
                print(f"Entity extraction failed: {entities_result.get('validation_feedback')}")
                return f"Error in entity extraction: {entities_result.get('validation_feedback')}"

            # Step 2: Identify constraints with verification
            constraints_result = identify_constraints_with_verification(question, entities_result["entities"])
            if not constraints_result.get("is_valid"):
                print(f"Constraint identification failed: {constraints_result.get('validation_feedback')}")
                return f"Error in constraint identification: {constraints_result.get('validation_feedback')}"

            # Step 3: Generate solution with verification
            solution_result = generate_solution_with_verification(
                question, 
                entities_result["entities"], 
                constraints_result["constraints"]
            )
            if not solution_result.get("is_valid"):
                print(f"Solution generation failed: {solution_result.get('validation_feedback')}")
                return f"Error in solution generation: {solution_result.get('validation_feedback')}"

            return solution_result["solution"]

        def extract_entities_with_verification(question, max_attempts=3):
            #Extract entities and verify their validity with feedback loop.
            system_instruction = "You are an expert at extracting and validating entities."

            for attempt in range(max_attempts):
                # First attempt at extraction
                extraction_prompt = f'''
                Extract key entities from this question. 
                Return a JSON object with the extracted entities.

                Example 1: [example with entities]
                Example 2: [example with different entities]
                Example 3: [example with complex entities]

                Question: {question}
                Extraction:
                '''

                extracted_data = call_llm(extraction_prompt, system_instruction)

                try:
                    # Parse the extraction
                    data = json.loads(extracted_data)

                    # Verification step
                    verification_prompt = f'''
                    Verify if these extracted entities are complete and correct:

                    Question: {question}
                    Extracted entities: {json.dumps(data, indent=2)}

                    Check if:
                    1. All relevant entities are extracted
                    2. No irrelevant entities are included
                    3. All entity values are correct

                    Return a JSON with:
                    {{
                      "is_valid": true/false,
                      "validation_feedback": "detailed explanation",
                      "missing_entities": ["entity1", "entity2"],
                      "incorrect_entities": ["entity3"]
                    }}
                    '''

                    verification_result = call_llm(verification_prompt, system_instruction)
                    verification_data = json.loads(verification_result)

                    if verification_data.get("is_valid", False):
                        data["is_valid"] = True
                        data["validation_feedback"] = "All entities are valid."
                        return data

                    # If not valid and we have attempts left, refine with feedback
                    if attempt < max_attempts - 1:
                        feedback = verification_data.get("validation_feedback", "")
                        print(f"Validation failed (attempt {attempt+1}/{max_attempts}): {feedback}")
                        continue

                    # If we're out of attempts, return the best we have with validation info
                    data["is_valid"] = False
                    data["validation_feedback"] = verification_data.get("validation_feedback", "Unknown validation error")
                    return data

                except Exception as e:
                    print(f"Error in extraction/validation (attempt {attempt+1}/{max_attempts}): {str(e)}")
                    if attempt >= max_attempts - 1:
                        return {
                            "is_valid": False,
                            "validation_feedback": f"Error during processing: {str(e)}"
                        }

            return {
                "is_valid": False,
                "validation_feedback": "Failed to extract valid entities after multiple attempts."
            }
        ```

        VALIDATION IMPLEMENTATION STRATEGIES:
        1. Create detailed verification functions for each major processing step
        2. Implement max_attempts limits on all retry loops (typically 3-5 attempts)
        3. Pass specific feedback from verification to subsequent retry attempts
        4. Log all verification failures to help identify systemic issues
        5. Design fallback behaviors when verification repeatedly fails

        

            
        ACCUMULATED LEARNINGS FROM PREVIOUS ITERATIONS:
        ```
# Math Question Dataset: Evolving Research Log

This document serves as a dynamic research log, capturing our evolving understanding, strategies, and findings related to the task of solving math questions from the provided dataset. It prioritizes concrete, task-specific insights.

## 1. DATASET PATTERNS & CHARACTERISTICS

*   **Question Content:** Predominantly multi-step mathematical reasoning problems. Requires a combination of algebra, geometry, and number theory. Questions range in complexity, requiring both computational and conceptual understanding.
*   **Answer Style:** Concise, step-by-step solutions using LaTeX. Final answers often boxed.
*   **Formatting:** Uses LaTeX for mathematical expressions and Asymptote code for diagrams. Accurate LaTeX interpretation is crucial.
*   **Numerical Focus:** Many questions require finding specific numerical values (e.g., smallest possible value, probability, arithmetic mean), demanding precise calculations.
*   **Reasoning Types:** Deductive, algebraic manipulation, spatial, computational, and logical.
*   **Examples:**
    *   Geometry problems involving area/circumference calculations, vector geometry.
    *   Number theory problems involving divisibility, digit sums.
    *   Algebra problems involving solving equations.

## 2. EFFECTIVE TASK-SPECIFIC STRATEGIES

*   **Ineffective (Baseline):** Direct LLM call. Accuracy ~50%. Insufficient for the complexity and precision required.

## 3. COMMON FAILURE MODES ON THIS DATASET

*   **Arithmetic and Logical Calculation Errors:** Consistent errors in basic arithmetic and logical calculations (e.g., median, probability). *Example: Incorrectly calculating the median in the stem and leaf plot question.*
*   **Misinterpretation of Problem Context:** Failing to fully understand the constraints or conditions stated in the problem, leading to incorrect solution paths. *Example: LLM jumps directly to a numerical answer without proper justification in divisibility question.*
*   **LaTeX Interpretation Issues:** Subtle errors in interpreting LaTeX can lead to misconstrued equations and wrong answers.
*   **Difficulty:** Understanding the problem statement, which may involve complex mathematical notation. Choosing the right approach and applying the correct formulas. Performing accurate calculations. Dealing with multi-step problems requiring a sequence of logical deductions. Interpreting visual information from diagrams (when present).
*   **Edge Cases/Complexities:** Problems with subtle wording that can lead to misinterpretation. Questions requiring creative problem-solving or non-obvious insights. Diagrams that may be misleading or require careful analysis. Calculations involving fractions, radicals, or other potentially error-prone operations.

## 4. EXPERIMENT LOG & FINDINGS

*   **Experiment 0 (Baseline):**
    *   **Description:** Direct call to the LLM with the question.
    *   **Accuracy:** ~50%
    *   **Findings:** The baseline approach is inadequate. Requires more than just general knowledge; necessitates precise calculation and logical reasoning capabilities. Calculation errors and misinterpretations of context are frequent.

## 5. NEXT RESEARCH DIRECTIONS

*   **Implement Calculator Tool:** Offload arithmetic calculations to a tool for accurate numerical computation.
*   **Step-by-Step Reasoning:** Incorporate a step-by-step reasoning approach in the prompt to decompose problems into verifiable steps.
*   **Verifier Implementation:** Use a verifier to check the LLM's final answer against the problem's constraints and logical consistency.
*   **LaTeX Handling Improvement:** Improve LaTeX handling either via pre-processing or prompt engineering.
*   **Solution Strategies:**
    *   **Direct Calculation:** Solve the problem by applying relevant formulas and performing calculations directly.
    *   **Equation Solving:** Set up equations based on the problem statement and solve for the unknown variables.
    *   **Geometric Reasoning:** Use geometric properties and relationships to find the solution.
    *   **Casework:** Divide the problem into different cases and solve each case separately.
    *   **Pattern Recognition:** Identify patterns or relationships that can help solve the problem.
*   **Problem Decomposition:**
    1.  **Understand the Problem:** Carefully read the question and identify the knowns and unknowns. Translate the problem into mathematical notation.
    2.  **Develop a Plan:** Determine which formulas, theorems, or techniques are relevant to the problem.
    3.  **Execute the Plan:** Apply the chosen techniques to solve the problem.
    4.  **Check the Answer:** Verify that the answer is reasonable and consistent with the problem statement.
*   **Validation Techniques:**
    *   **Unit Analysis:** Check that the units of the answer are correct.
    *   **Estimation:** Estimate the answer to see if it's in the right ballpark.
    *   **Substitution:** Plug the answer back into the original problem to see if it works.
    *   **Dimensional Analysis:** Check that the dimensions of the quantities are consistent.
    *   **Consider extreme values:** check the answer works for extreme values of some variable.
*   **Creative Insights:**
    *   Sometimes, a geometric problem can be solved more easily using algebra, or vice versa.
    *   Looking for symmetries in the problem can simplify the solution.
    *   Rearranging the problem statement or using a different coordinate system can sometimes reveal a simpler solution path. Think about the problem from a different angle. Can you reframe the question or use a different representation? Instead of trying to solve the problem directly, try to solve a simpler version of the problem first. Draw analogies to other problem domains where similar concepts or techniques apply.
*   **Implementation Recommendations:**
    *   **Verification Steps:** Mathematical Correctness: The most crucial aspect. Verify that each step in the solution is mathematically sound. Consistency with Problem Statement: Ensure that the solution addresses the specific question asked and uses the given information correctly. Reasonableness of Answer: Check if the answer is reasonable in the context of the problem (e.g., a negative length is likely wrong). Edge Case Testing: Test the solution with edge cases or extreme values to ensure it holds true in all scenarios.
    *   **Intermediate Steps/Representations:** Symbolic Representation: Maintain the problem in symbolic form (using variables and equations) as long as possible to avoid premature numerical evaluation. Equation Tree: Represent the equations as a tree structure to facilitate manipulation and simplification. Diagrammatic Representation: (If applicable) Use a graph or diagram to represent the geometric relationships in the problem.
    *   **Text-Based Techniques:** LaTeX Parsing & Generation: While avoiding complex code generation, leverage LLMs' ability to understand and generate LaTeX. This is crucial for both interpreting questions and formatting answers. Step-by-Step Reasoning Chain: Prompt the LLM to explicitly state its reasoning in a step-by-step manner. This allows for easier debugging and verification. Each step should be a complete sentence. Formula Identification: Train the LLM to identify relevant formulas based on keywords in the problem statement. Equation Simplification: Use prompting to guide the LLM to simplify equations and expressions. Example-Based Learning: Fine-tune the LLM on a large dataset of similar problems and solutions. Verification Prompting: Use separate prompts to verify the correctness of each step in the solution and the final answer. For example, "Is this step logically valid based on the previous step?" "Does this answer make sense in the context of the problem?" Avoid Over-Reliance on Code: Don't try to offload the *reasoning* to external code. Use code only for arithmetic or symbolic manipulation if absolutely necessary, and always verify the results.
```
        

            
        CAPABILITY ASSESSMENT & IMPROVEMENT GUIDANCE:
        SYSTEM ANALYSIS & GUIDANCE


        

            BEST SCRIPT TO REFINE:
            Iteration: 0
            Accuracy: 0.50
            Approach Summary: Simple baseline script: Direct LLM call without sophisticated techniques

            CURRENT BEST SCRIPT CODE:
            ```python
            import os
from google import genai
from google.genai import types

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response"""
    try:
        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

def main(question):
    """
    Baseline script: Simple direct LLM call without sophisticated techniques.
    This establishes the baseline performance capability for this dataset.
    """
    system_instruction = "You are a helpful assistant. Answer the question directly and concisely based on the information provided."

    # Simple, direct call to LLM
    answer = call_llm(question, system_instruction)

    return answer
    
            ```

            SPECIFIC SUCCESS CASES (what the script does well):
            [
  {
    "question": "In Heidi's history class, the only grades that count toward the semester average are the $6$ tests she has already taken and the upcoming final exam. The final exam counts as two tests. Heidi has determined that if she earns $99$ points on the final she will have exactly a $90$-point average for the semester. On average, how many points has Heidi scored on each test prior to the final exam?",
    "system_answer": "Let $x$ be the average of Heidi's scores on the 6 tests. Then the sum of her scores on the 6 tests is $6x$.\nThe final exam counts as two tests, and she scores 99 on the final, so the final exam contributes $2 \\cdot 99 = 198$ points.\nThe total number of tests is $6+2=8$.\nHer average for the semester is 90, so the total number of points is $8 \\cdot 90 = 720$.\nTherefore, $6x + 198 = 720$.\n$6x = 720 - 198 = 522$.\n$x = \\frac{522}{6} = 87$.\n\nThe average number of points Heidi scored on each test prior to the final exam is 87.\n\nFinal Answer: The final answer is $\\boxed{87}$",
    "golden_answer": "Set the average for her previous exams to be $x$. The total amount of points including the final will be $6x+2 \\cdot 99$. The average is $\\frac{6x+2 \\cdot 99}{8}=90$. Then we solve for $x$. $$\\frac{6x+2 \\cdot 99}{8}=90 \\rightarrow 6x+198=720 \\rightarrow 6x=522 \\rightarrow x=\\boxed{87}.$$",
    "explanation": "Both answers arrive at the same numerical solution using essentially the same logic, clearly defining variables and setting up the appropriate equation."
  },
  {
    "question": "There are real numbers $a$ and $b$ such that for every positive number $x$, we have the identity\n\\[\n  \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) + \\tan^{-1}(ax) + \\tan^{-1}(bx) \n    = \\frac{\\pi}{2} \\, .\n\\](Throughout this equation, $\\tan^{-1}$ means the inverse tangent function, sometimes written $\\arctan$.)  What is the value of $a^2 + b^2$?",
    "system_answer": "Since\n\\[\\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) + \\tan^{-1}(ax) + \\tan^{-1}(bx) = \\frac{\\pi}{2}\\]for all $x > 0,$\n\\[\\tan^{-1}(ax) + \\tan^{-1}(bx) = \\frac{\\pi}{2} - \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) = \\tan^{-1} \\left( \\frac{1}{\\frac{1}{x} - \\frac{x}{8}} \\right) = \\tan^{-1} \\left( \\frac{8x}{8 - x^2} \\right).\\]Then\n\\[\\tan^{-1}(ax) + \\tan^{-1}(bx) = \\tan^{-1} \\left( \\frac{ax + bx}{1 - abx^2} \\right) = \\tan^{-1} \\left( \\frac{(a + b) x}{1 - abx^2} \\right).\\]Thus, we must have\n\\[\\frac{(a + b) x}{1 - abx^2} = \\frac{8x}{8 - x^2}.\\]Then $(a + b) x (8 - x^2) = 8x (1 - abx^2),$ so $(a + b) (8 - x^2) = 8(1 - abx^2).$  Then $8(a + b) - (a + b) x^2 = 8 - 8abx^2.$\nComparing coefficients, we must have $8(a + b) = 8,$ so $a + b = 1.$  Also, $a + b = 8ab,$ so $1 = 8ab,$ i.e. $ab = \\frac{1}{8}.$\n\nThen $a$ and $b$ are the roots of\n\\[t^2 - (a + b) t + ab = 0,\\]so $t^2 - t + \\frac{1}{8} = 0.$  Then $8t^2 - 8t + 1 = 0,$ so\n\\[t = \\frac{8 \\pm \\sqrt{64 - 32}}{16} = \\frac{8 \\pm \\sqrt{32}}{16} = \\frac{8 \\pm 4 \\sqrt{2}}{16} = \\frac{2 \\pm \\sqrt{2}}{4}.\\]Then $a = \\frac{2 + \\sqrt{2}}{4}$ and $b = \\frac{2 - \\sqrt{2}}{4},$ or vice versa.  In either case,\n\\begin{align*} a^2 + b^2 &= \\left( \\frac{2 + \\sqrt{2}}{4} \\right)^2 + \\left( \\frac{2 - \\sqrt{2}}{4} \\right)^2 \\\\ &= \\frac{4 + 4 \\sqrt{2} + 2}{16} + \\frac{4 - 4 \\sqrt{2} + 2}{16} \\\\ &= \\frac{6 + 4 \\sqrt{2}}{16} + \\frac{6 - 4 \\sqrt{2}}{16} \\\\ &= \\frac{12}{16} = \\frac{3}{4}. \\end{align*}\n\nFinal Answer: The final answer is $\\boxed{\\frac{3}{4}}$",
    "golden_answer": "By the tangent addition formula,\n\\[\\tan (\\tan^{-1} p + \\tan^{-1} q) = \\frac{p + q}{1 - pq}.\\]From the given equation,\n\\[\\tan^{-1} ax + \\tan^{-1} bx = \\frac{\\pi}{2} - \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right).\\]Then\n\\[\\tan (\\tan^{-1} ax + \\tan^{-1} bx) = \\tan \\left( \\frac{\\pi}{2} - \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) \\right),\\]The left-hand side is $\\frac{ax + bx}{1 - abx^2}.$  The right-hand side is\n\\begin{align*}\n\\tan \\left( \\frac{\\pi}{2} - \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) \\right) &= \\frac{1}{\\tan \\left( \\tan^{-1} \\left( \\frac{1}{x} - \\frac{x}{8} \\right) \\right)} \\\\\n&= \\frac{1}{\\frac{1}{x} - \\frac{x}{8}} \\\\\n&= \\frac{x}{1 - \\frac{1}{8} x^2}.\n\\end{align*}Hence, $a + b = 1$ and $ab = \\frac{1}{8},$ so\n\\[a^2 + b^2 = (a + b)^2 - 2ab = 1 - \\frac{2}{8} = \\boxed{\\frac{3}{4}}.\\]",
    "explanation": "Both answers arrive at the same result, using similar trigonometric identities and algebraic manipulations. The solution steps and final answer are equivalent."
  },
  {
    "question": "What is the probability that a randomly selected integer in the set $$\\{1,2,3,\\ldots,100\\}$$  is divisible by 2 and not divisible by 3? Express your answer as a common fraction.",
    "system_answer": "Let $S = \\{1, 2, 3, \\ldots, 100\\}$.\nWe want to find the probability that a randomly selected integer in $S$ is divisible by 2 and not divisible by 3.\n\nThe number of integers in $S$ divisible by 2 is $\\left\\lfloor \\frac{100}{2} \\right\\rfloor = 50$.\nThe number of integers in $S$ divisible by 3 is $\\left\\lfloor \\frac{100}{3} \\right\\rfloor = 33$.\nThe number of integers in $S$ divisible by both 2 and 3 is the number of integers divisible by 6, which is $\\left\\lfloor \\frac{100}{6} \\right\\rfloor = 16$.\n\nThe number of integers in $S$ divisible by 2 is 50. Among these, the number of integers also divisible by 3 is the number of integers divisible by 6, which is 16. Therefore, the number of integers in $S$ divisible by 2 but not divisible by 3 is $50 - 16 = 34$.\n\nThe probability that a randomly selected integer in $S$ is divisible by 2 and not divisible by 3 is $\\frac{34}{100} = \\frac{17}{50}$.\n\nFinal Answer: The final answer is $\\boxed{\\frac{17}{50}}$",
    "golden_answer": "Since $100 = 50\\cdot 2$, there are 50 integers in the set that are divisible by 2.  The numbers among these that are also divisible by 3 are the multiples of 6 in the set.  Dividing 100 by 6 gives $16\\frac23$, so there are 16 multiples of 6 in the set, which leaves $50-16 = 34$ multiples of 2 that are not also multiples of 3.  There are 100 numbers in the set so the desired probability is $\\dfrac{34}{100} = \\boxed{\\dfrac{17}{50}}$.",
    "explanation": "Both answers arrive at the same conclusion and provide the same reasoning, although worded slightly differently. The core logic of calculating the number of integers divisible by 2, then subtracting those also divisible by 3 (i.e., divisible by 6) is identical in both answers, leading to the same probability of 17/50."
  }
]

            SPECIFIC FAILURE CASES (what needs improvement):
            [
  {
    "question": "Suppose that $\\overline{abcd}$ is a four-digit integer with no digits equal to zero such that $\\overline{ab}$, $\\overline{bc}$, and $\\overline{cd}$ are distinct integers that each divide into $\\overline{abcd}$. Find the smallest possible value of $\\overline{abcd}$.",
    "system_answer": "The smallest possible value of $\\overline{abcd}$ is 1236.",
    "golden_answer": "Since $\\overline{ab} | \\overline{abcd} = 100 \\cdot \\overline{ab} + \\overline{cd}$, then $\\overline{ab}$ also divides into $\\overline{abcd} - 100 \\cdot \\overline{ab} = \\overline{cd}$. Similarly, since $\\overline{cd} | \\overline{abcd} = 100 \\cdot \\overline{ab} + \\overline{cd}$, then $\\overline{cd}$ must divide into $\\overline{abcd} - \\overline{cd} = 100 \\cdot \\overline{ab}$. To minimize $\\overline{abcd}$, then we would like to try $a = b = 1$. It follows that $\\overline{cd}$ is divisible by $11$, and also divides into $100 \\cdot \\overline{ab} = 1100$. Thus, $\\overline{cd} = 11,22,44,55$, but we can eliminate the first due to the distinctness condition. Trying each of the others, we see that $1122 = 2 \\cdot 3 \\cdot 11 \\cdot 17$ is not divisible by $12$; $1144 = 2^3 \\cdot 11 \\cdot 13$ is not divisible by $14$; and $\\boxed{1155} = 3 \\cdot 5 \\cdot 7 \\cdot 11$ is indeed divisible by $15$.",
    "explanation": "The system answer only states the smallest possible value of abcd is 1236. The golden answer states the value is 1155, including detailed reasoning to get to this solution. As such, the answers do not match"
  },
  {
    "question": "Randy presses RAND on his calculator twice to obtain two random numbers between 0 and 1. Let $p$ be the probability that these two numbers and 1 form the sides of an obtuse triangle.  Find $4p$.",
    "system_answer": "Let $x$ and $y$ be the two random numbers between 0 and 1.\nFor $x, y, 1$ to form a triangle, we need $x+y>1$, $x+1>y$, and $y+1>x$.\nFor the triangle to be obtuse, we need $x^2 + y^2 < 1$, $x^2 + 1 < y^2$, or $y^2 + 1 < x^2$.\nThe region where $x, y \\in (0,1)$ and $x+y>1$, $x+1>y$, and $y+1>x$ is the region defined by $x+y>1$, $y>x-1$, $x>y-1$. Since $x,y \\in (0,1)$, this is the region bounded by $x=0, x=1, y=0, y=1, x+y>1$.\nThe area of this region is $1 - \\frac{1}{2} = \\frac{1}{2}$.\nNow consider the conditions for the triangle to be obtuse: $x^2+y^2<1$, $x^2+1<y^2$, $y^2+1<x^2$.\n\\begin{itemize}\n    \\item $x^2+y^2 < 1$. This region is a quarter circle with radius 1, centered at $(0,0)$. The area of this region that also satisfies $x+y>1$ is $\\frac{\\pi}{4} - \\frac{1}{2}$.\n    \\item $x^2+1 < y^2$ or $y^2 > x^2+1$. This has no solution in the interval $(0,1)$.\n    \\item $y^2+1 < x^2$ or $x^2 > y^2+1$. This has no solution in the interval $(0,1)$.\n\\end{itemize}\nThus, the area of the region where the triangle is obtuse is $\\frac{\\pi}{4}-\\frac{1}{2}$.\nThe total area is $\\frac{1}{2}$.\nThe probability that the triangle is obtuse is $p = \\frac{\\frac{\\pi}{4}-\\frac{1}{2}}{\\frac{1}{2}} = \\frac{\\pi}{2} - 1$.\n$4p = 4(\\frac{\\pi}{2}-1) = 2\\pi - 4 \\approx 2(3.14159) - 4 \\approx 6.28318 - 4 = 2.28318$\n\nHowever, the condition for forming a triangle is $x+y>1, x+1>y, y+1>x$.\nThe area is $1-\\frac{1}{2} = \\frac{1}{2}$.\nFor obtuse triangle, $x^2+y^2<1$, $x^2+1 < y^2$ or $y^2+1 < x^2$.\nIf $x^2+y^2 < 1$, area is $\\frac{\\pi}{4}$. Then we have $x+y > 1$. The area is $\\frac{\\pi}{4} - \\frac{1}{2}$.\n$y^2 > x^2+1$ or $y > \\sqrt{x^2+1}$, no solution.\n$x^2 > y^2+1$ or $x > \\sqrt{y^2+1}$, no solution.\nSo the area is $\\frac{\\pi}{4} - \\frac{1}{2}$.\nThe total area is $\\frac{1}{2}$.\nThus, $p = \\frac{\\frac{\\pi}{4} - \\frac{1}{2}}{\\frac{1}{2}} = \\frac{\\pi}{2} - 1$.\n$4p = 2\\pi - 4$.\n\nFinal Answer: The final answer is $\\boxed{2\\pi-4}$",
    "golden_answer": "Let the two random numbers be $x$ and $y$. In order to form an obtuse triangle, since 1 will be the longest side, we must simultaneously satisfy the following inequalities: $$x+y>1\\text{ and }x^2+y^2<1.$$The first is the triangle inequality and the second guarantees that the triangle is obtuse. Graphing these in the $xy$-plane, we get the following shaded region. [asy]\ndraw(unitsquare);\ndraw((0,0)--(1,0),EndArrow);\ndraw((0,0)--(0,1),EndArrow);\nlabel(\"0\",(0,0),SW);\nlabel(\"1\",(1,0),S);\nlabel(\"1\",(0,1),W);\nlabel(\"$x$\",(.5,0),S);\nlabel(\"$y$\",(0,.5),W);\nfill((1,0)--(0,1)..(3/5,4/5)..cycle,gray(.7));\n[/asy] The curve is an arc of the unit circle centered at the origin. This area is then equal to that sector minus the right isosceles triangle within it, or $\\frac{\\pi}{4}-\\frac{1}{2}=\\frac{\\pi-2}{4}.$ And since the area of the square is $1,$ $p = \\frac{\\pi-2}{4}.$\n\nFour times $p$ is $\\boxed{\\pi-2}$.",
    "explanation": "The golden answer states that 4p = pi - 2. The system answer states that 4p = 2pi - 4. These are not equivalent."
  },
  {
    "question": "The exam grades of a pre-algebra class were arranged in a stem and leaf plot as illustrated. What is the arithmetic mean of the median and the mode of the given data?\n\n\\begin{tabular}{ c | c c c ccc c c c}\n4&1&&&&&&&&\\\\\n5&2&&&&&&&&\\\\\n6&7&8&8&&&&&&\\\\\n7&1&1&2&3&3&3&5&6&8\\\\\n8&0&4&4&6&6&6&6&8&\\\\\n9&1&3&5&5&7&&&&\\\\\n\\end{tabular}",
    "system_answer": "The median of the data set is 73 and the mode is 86. The arithmetic mean of these two numbers is $\\frac{73+86}{2} = \\frac{159}{2} = 79.5$.",
    "golden_answer": "Each digit to the right of the vertical bar represents (the units digit of) one exam grade. Counting the digits, we see that there are $27$ exam grades in all. Thus, the $14^{\\rm th}$ grade in increasing order is the median (since there are $13$ grades smaller than it and $13$ grades larger than it). The chart makes it easy to read off the grades in increasing order -- we just read across the rows, from top to bottom. The $14^{\\rm th}$ entry is $78,$ so that's the median grade.\n\nThe mode is the most frequently occurring grade. In this case, it's $86,$ which appears four times in the chart.\n\nThe arithmetic mean of the median and mode of the data is $\\dfrac{1}{2}(78+86),$ or $\\boxed{82}.$",
    "explanation": "The system answer states that the median is 73 and the mode is 86. The golden answer states the median is 78 and the mode is 86. Therefore, the answers do not communicate the same information."
  }
]

            REFINEMENT ANALYSIS GUIDANCE:
            1. IDENTIFY THE CORE STRENGTH:
               - What specific technique or approach makes this script successful?
               - Which components are working well and must be preserved?
               - What is the script's main competitive advantage?

            2. PINPOINT SPECIFIC WEAKNESSES:
               - Where exactly do the failures occur in the processing pipeline?
               - What specific patterns cause the script to fail?
               - Are failures due to information extraction, reasoning, formatting, or verification?
               - Can you identify the exact function or step where problems arise?

            3. FORM A SPECIFIC HYPOTHESIS:
               - What is the ONE most critical weakness to address?
               - What specific change would most likely improve performance?
               - How can you fix this weakness without breaking the existing strengths?
               - What verification can you add to test if your fix works?

            4. SURGICAL IMPROVEMENT STRATEGY:
               - Make the MINIMUM changes necessary to address the identified weakness
               - Preserve all successful components and logic
               - Add targeted verification for the specific area being improved
               - Enhance error handling for the identified failure mode
               - Add debugging output to verify the fix is working

            SPECIFIC REFINEMENT TECHNIQUES:
            - If failures are in information extraction: Improve prompts, add verification, better parsing
            - If failures are in reasoning: Add chain-of-thought, verification loops, multi-step reasoning
            - If failures are in formatting: Add output validation, format checking, retry logic
            - If failures are inconsistent: Add confidence scoring, multiple attempts, consensus approaches

            CRITICAL REFINEMENT REQUIREMENTS:
            1. Preserve the core successful approach - don't change what's working
            2. Make targeted, minimal changes focused on the specific weakness identified
            3. Add verification steps specifically for the area being improved
            4. Include debugging output to verify improvements are working
            5. EVERY LLM PROMPT must include embedded examples
            6. Test your hypothesis with additional verification

            Here's how to call the Gemini API. Use this example without modification:
            def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. DO NOT deviate from this example template or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

            REFINEMENT IMPLEMENTATION:
            State Your Hypothesis: Clearly comment what specific weakness you're addressing and how
            Preserve Strengths: Keep all successful components intact
            Targeted Fix: Implement the minimal change needed to address the weakness
            Add Verification: Include checks to ensure your fix is working
            Debug Output: Add print statements to track the improvement

            Return a COMPLETE, RUNNABLE Python script that:
            1. Preserves the successful core approach of the original script
            2. Makes targeted improvements to address the specific identified weakness
            3. Includes a clear comment stating your improvement hypothesis
            4. Adds verification specifically for the improved component
            5. Includes embedded examples in EVERY LLM prompt
            6. Is COMPLETE - no missing code, no "..." placeholders
            7. Closes all string literals properly

            REFINEMENT HYPOTHESIS: [State your specific hypothesis about what to improve and why in a comment]

            BE EXTREMELY CAREFUL TO PROPERLY CLOSE ALL STRING QUOTES AND TRIPLE QUOTES!
            MAKE SURGICAL IMPROVEMENTS WHILE PRESERVING THE SCRIPT'S CORE STRENGTHS!
            