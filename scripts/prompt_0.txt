
        You are developing a Python script to solve problems using LLM reasoning capabilities.
        You are in the EXPLORATION PHASE. You must generate a NEW approach that's different from previous approaches but informed by their successes and failures. With this approach, you will have a specific NEW HYPOTHESIS or variable you are trying to test. Your goal is to see if this new approach works, and you must add verification and validation steps to deduce if this new change is helpful. Carefully and fairly evaluate whether the hypothesis should be accepted, rejected, re-tested, or something else, making reference to specific outputs, reasoning steps, error messages, or other evidence from the exectuion. You may test RADICAL NEW APPROACHES that are substantially different from previous approaches. 

        You should try NEW THINGS:

        Break down the problem into smaller pieces
        Think CREATIVELY about how to solve your problem if other approaches aren't working
        Transform data into different formats to see if it helps

        # YOUR TASK
        You are deeply familiar with prompting techniques and the agent works from the literature. 
        Your goal is to maximize the specified performance metrics by proposing interestingly new agents.
        Observe the past discovered agents and scripts carefully and think about what insights, lessons, or stepping stones can be learned from them.
        Be creative when thinking about the next interesting agent to try. You are encouraged to draw inspiration from related agent papers or academic papers from other research areas.
        Use the knowledge from the archive and inspiration from academic literature to propose the next interesting agentic system design.
        THINK OUTSIDE THE BOX.


        Here are example problems from previously seen data. YOUR APPROACH MUST BE DIFFERENT THAN THESE:
        [
  {
    "id": 0,
    "question": "Grid Transformation Task\n\n=== TRAINING EXAMPLES ===\n\nExample 1:\nInput Grid:\n[\n  [0, 7, 7]\n  [7, 7, 7]\n  [0, 7, 7]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 7, 7, 0, 7, 7]\n  [0, 0, 0, 7, 7, 7, 7, 7, 7]\n  [0, 0, 0, 0, 7, 7, 0, 7, 7]\n  [0, 7, 7, 0, 7, 7, 0, 7, 7]\n  [7, 7, 7, 7, 7, 7, 7, 7, 7]\n  [0, 7, 7, 0, 7, 7, 0, 7, 7]\n  [0, 0, 0, 0, 7, 7, 0, 7, 7]\n  [0, 0, 0, 7, 7, 7, 7, 7, 7]\n  [0, 0, 0, 0, 7, 7, 0, 7, 7]\n]\nExample 2:\nInput Grid:\n[\n  [4, 0, 4]\n  [0, 0, 0]\n  [0, 4, 0]\n]\n\nOutput Grid:\n[\n  [4, 0, 4, 0, 0, 0, 4, 0, 4]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 4, 0, 0, 0, 0, 0, 4, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 0, 4, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 4, 0, 0, 0, 0]\n]\nExample 3:\nInput Grid:\n[\n  [0, 0, 0]\n  [0, 0, 2]\n  [2, 0, 2]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 2]\n  [0, 0, 0, 0, 0, 0, 2, 0, 2]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 2, 0, 0, 0, 0, 0, 2]\n  [2, 0, 2, 0, 0, 0, 2, 0, 2]\n]\nExample 4:\nInput Grid:\n[\n  [6, 6, 0]\n  [6, 0, 0]\n  [0, 6, 6]\n]\n\nOutput Grid:\n[\n  [6, 6, 0, 6, 6, 0, 0, 0, 0]\n  [6, 0, 0, 6, 0, 0, 0, 0, 0]\n  [0, 6, 6, 0, 6, 6, 0, 0, 0]\n  [6, 6, 0, 0, 0, 0, 0, 0, 0]\n  [6, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 6, 6, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 6, 6, 0, 6, 6, 0]\n  [0, 0, 0, 6, 0, 0, 6, 0, 0]\n  [0, 0, 0, 0, 6, 6, 0, 6, 6]\n]\nExample 5:\nInput Grid:\n[\n  [2, 2, 2]\n  [0, 0, 0]\n  [0, 2, 2]\n]\n\nOutput Grid:\n[\n  [2, 2, 2, 2, 2, 2, 2, 2, 2]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 2, 2, 0, 2, 2, 0, 2, 2]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 2, 2, 2, 2, 2, 2]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 2, 2, 0, 2, 2]\n]\n\n=== TEST INPUT ===\n[\n  [7, 0, 7]\n  [7, 0, 7]\n  [7, 7, 0]\n]\n\nTransform the test input according to the pattern shown in the training examples.",
    "answer": "[[7,0,7,0,0,0,7,0,7],[7,0,7,0,0,0,7,0,7],[7,7,0,0,0,0,7,7,0],[7,0,7,0,0,0,7,0,7],[7,0,7,0,0,0,7,0,7],[7,7,0,0,0,0,7,7,0],[7,0,7,7,0,7,0,0,0],[7,0,7,7,0,7,0,0,0],[7,7,0,7,7,0,0,0,0]]"
  },
  {
    "id": 1,
    "question": "Grid Transformation Task\n\n=== TRAINING EXAMPLES ===\n\nExample 1:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 0]\n  [0, 3, 0, 3, 0, 0]\n  [0, 0, 3, 0, 3, 0]\n  [0, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 0]\n  [0, 3, 4, 3, 0, 0]\n  [0, 0, 3, 4, 3, 0]\n  [0, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0]\n]\nExample 2:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 0, 3, 0, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 3, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 0, 3, 0, 0, 0]\n  [0, 0, 0, 0, 0, 3, 0, 3, 0, 0]\n  [0, 0, 0, 3, 0, 3, 3, 0, 0, 0]\n  [0, 0, 3, 3, 3, 0, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 0, 3, 0, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 3, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 0, 3, 0, 0, 0]\n  [0, 0, 0, 0, 0, 3, 4, 3, 0, 0]\n  [0, 0, 0, 3, 0, 3, 3, 0, 0, 0]\n  [0, 0, 3, 3, 3, 0, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\nExample 3:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 0, 0, 0, 0, 0]\n  [0, 3, 3, 0, 3, 3, 0, 3, 0, 0]\n  [3, 0, 0, 3, 0, 0, 3, 0, 3, 0]\n  [0, 0, 0, 3, 0, 0, 3, 3, 0, 0]\n  [0, 0, 0, 3, 0, 0, 3, 0, 0, 0]\n  [0, 0, 0, 3, 0, 0, 3, 0, 0, 0]\n  [0, 0, 0, 0, 3, 3, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 0, 0, 0, 0, 0]\n  [0, 3, 3, 0, 3, 3, 0, 3, 0, 0]\n  [3, 0, 0, 3, 4, 4, 3, 4, 3, 0]\n  [0, 0, 0, 3, 4, 4, 3, 3, 0, 0]\n  [0, 0, 0, 3, 4, 4, 3, 0, 0, 0]\n  [0, 0, 0, 3, 4, 4, 3, 0, 0, 0]\n  [0, 0, 0, 0, 3, 3, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\nExample 4:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 3, 3, 3, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 3, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 3, 0, 3, 0, 0]\n  [0, 0, 3, 3, 3, 3, 3, 3, 3, 0]\n  [0, 0, 0, 3, 0, 0, 0, 0, 3, 0]\n  [0, 0, 0, 3, 0, 0, 0, 3, 3, 0]\n  [0, 0, 0, 3, 3, 0, 0, 3, 0, 3]\n  [0, 0, 0, 3, 0, 3, 0, 0, 3, 0]\n  [0, 0, 0, 0, 3, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 3, 3, 3, 0, 0, 0, 0]\n  [0, 0, 3, 4, 4, 3, 0, 0, 0, 0]\n  [0, 0, 3, 4, 4, 3, 0, 3, 0, 0]\n  [0, 0, 3, 3, 3, 3, 3, 3, 3, 0]\n  [0, 0, 0, 3, 0, 0, 0, 0, 3, 0]\n  [0, 0, 0, 3, 0, 0, 0, 3, 3, 0]\n  [0, 0, 0, 3, 3, 0, 0, 3, 4, 3]\n  [0, 0, 0, 3, 4, 3, 0, 0, 3, 0]\n  [0, 0, 0, 0, 3, 0, 0, 0, 0, 0]\n]\nExample 5:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 3, 3, 3, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 3, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 3, 0, 0, 3, 3, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 3, 3, 3, 4, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 3, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 3, 3, 4, 4, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 3, 3, 0, 0, 3, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 3, 0, 0, 3, 3, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 4, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n=== TEST INPUT ===\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 3, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0]\n  [0, 0, 0, 0, 0, 0, 3, 3, 0, 3, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0]\n  [0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nTransform the test input according to the pattern shown in the training examples.",
    "answer": "[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,3,4,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,3,0,3,3,3,3,3,0,3,3,0,0,0,0,0,0,0,0],[0,0,0,0,3,4,4,4,4,3,4,4,3,0,0,0,0,0,0,0],[0,0,0,0,3,3,3,3,3,0,3,3,3,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,4,4,3,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,4,4,3,0,0],[0,0,0,0,0,0,0,0,0,3,3,3,3,3,4,4,4,3,0,0],[0,0,0,0,0,0,0,0,0,3,4,4,4,3,4,4,4,3,0,0],[0,0,0,0,0,0,0,0,3,3,3,3,3,3,4,4,4,3,0,0],[0,0,0,0,0,0,3,3,4,3,0,0,0,3,3,3,3,3,0,0],[0,0,3,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0],[0,3,4,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,3,0,3,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,3,4,4,4,3,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,3,4,4,4,3,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]"
  },
  {
    "id": 2,
    "question": "Grid Transformation Task\n\n=== TRAINING EXAMPLES ===\n\nExample 1:\nInput Grid:\n[\n  [0, 1, 0]\n  [1, 1, 0]\n  [0, 1, 0]\n  [0, 1, 1]\n  [0, 1, 0]\n  [1, 1, 0]\n]\n\nOutput Grid:\n[\n  [0, 2, 0]\n  [2, 2, 0]\n  [0, 2, 0]\n  [0, 2, 2]\n  [0, 2, 0]\n  [2, 2, 0]\n  [0, 2, 0]\n  [0, 2, 2]\n  [0, 2, 0]\n]\nExample 2:\nInput Grid:\n[\n  [0, 1, 0]\n  [1, 0, 1]\n  [0, 1, 0]\n  [1, 0, 1]\n  [0, 1, 0]\n  [1, 0, 1]\n]\n\nOutput Grid:\n[\n  [0, 2, 0]\n  [2, 0, 2]\n  [0, 2, 0]\n  [2, 0, 2]\n  [0, 2, 0]\n  [2, 0, 2]\n  [0, 2, 0]\n  [2, 0, 2]\n  [0, 2, 0]\n]\nExample 3:\nInput Grid:\n[\n  [0, 1, 0]\n  [1, 1, 0]\n  [0, 1, 0]\n  [0, 1, 0]\n  [1, 1, 0]\n  [0, 1, 0]\n]\n\nOutput Grid:\n[\n  [0, 2, 0]\n  [2, 2, 0]\n  [0, 2, 0]\n  [0, 2, 0]\n  [2, 2, 0]\n  [0, 2, 0]\n  [0, 2, 0]\n  [2, 2, 0]\n  [0, 2, 0]\n]\n\n=== TEST INPUT ===\n[\n  [1, 1, 1]\n  [0, 1, 0]\n  [0, 1, 0]\n  [1, 1, 1]\n  [0, 1, 0]\n  [0, 1, 0]\n]\n\nTransform the test input according to the pattern shown in the training examples.",
    "answer": "[[2,2,2],[0,2,0],[0,2,0],[2,2,2],[0,2,0],[0,2,0],[2,2,2],[0,2,0],[0,2,0]]"
  }
]

        HISTORICAL CONTEXT. YOUR APPROACH MUST ALSO BE DIFFERENT THAN THESE:
        ITERATION HISTORY SUMMARY:
    - Total iterations completed: 0
    - Current explore/exploit balance: 60/40
    - Best accuracy achieved: None

    PREVIOUS APPROACHES:
    No previous approaches available.
    



MULTI-EXAMPLE PROMPTING GUIDANCE:
        1. CRITICAL: Use MULTIPLE examples (2-5) in EVERY LLM prompt, not just one
        2. Vary the number of examples based on task complexity - more complex tasks need more examples
        3. Select diverse examples that showcase different patterns and edge cases
        4. Structure your few-shot examples to demonstrate clear step-by-step reasoning
        5. Consider using both "easy" and "challenging" examples to help the LLM learn from contrasts
        6. The collection of examples should collectively cover all key aspects of the problem
        7. When available, use examples from previous iterations that revealed specific strengths or weaknesses.
        8. USE REAL EXAMPLES FROM THE DATASET WHERE POSSIBLE!!

        

        LIBRARY OF PROMPTS, TECHNIQUES, STRATEGIES, AND PATTERNS:
        

=== AVAILABLE PATTERNS ===


        # Step-by-Step Reasoning Pattern

        ## Example Prompt Structure
        ```
        Solve this problem step-by-step:

        Example:
        Problem: [example problem]

        Step 1: [first reasoning step]
        Step 2: [second reasoning step]
        Step 3: [third reasoning step]
        Therefore: [conclusion]

        Problem: {problem}

        Let's solve this step-by-step:
        ```

        ## Implementation Notes
        - Explicit steps guide the LLM through logical reasoning
        - Choose example problems similar to your target task
        - Can be combined with verification to check each step
        


        # Few-Shot Learning Pattern

        ## Example Prompt Structure
        ```
        I'll show you some examples, then ask you to solve a new problem.

        Example 1:
        Input: [example input 1]
        Output: [example output 1]

        Example 2:
        Input: [example input 2]
        Output: [example output 2]

        Example 3:
        Input: [example input 3]
        Output: [example output 3]

        Now, solve this new problem:
        Input: {new_problem}
        Output:
        ```

        ## Implementation Notes
        - Select examples that demonstrate the pattern or approach
        - Vary example complexity to cover edge cases
        - Consider showing examples with mistakes and corrections
        - Dynamic selection of examples based on the specific problem
        


        # Verification with Feedback Loop Pattern

        ## Example Implementation Structure
        ```python
        # This is a template - adapt freely to your needs

        # Initial solution generation
        solution = generate_solution(problem)

        # Loop until valid or max attempts reached
        for attempt in range(max_attempts):
            # Check if solution is valid
            verification_result = verify_solution(problem, solution)

            if verification_result["is_valid"]:
                return solution

            # If invalid, refine with specific feedback
            feedback = verification_result["feedback"]
            solution = refine_solution(problem, solution, feedback)

        return solution
        ```

        ## Example Verification Prompt
        ```
        Verify if this solution correctly addresses the problem:

        Problem: {problem}
        Solution: {solution}

        Evaluation criteria:
        1. Is the solution correct?
        2. Is it complete?
        3. Does it address all constraints?

        Provide specific feedback on any issues found.
        ```

        ## Implementation Notes
        - Always include specific feedback about WHY something fails verification
        - Send output back to earlier in the pipeline with the feedback
        - Consider multiple verification methods for critical tasks
        


        # Multi-Perspective Analysis Pattern

        ## Example Structure
        1. Define relevant perspectives for your task
           - Domain experts (mathematician, designer, programmer)
           - Cognitive styles (analytical, creative, practical)
           - Methodologies (deductive, inductive, abductive)

        2. For each perspective, generate analysis:
           ```
           As a {perspective}, analyze this problem:

           {problem}

           Focus on aspects that a {perspective} would notice:
           [Perspective-specific instructions]
           ```

        3. Synthesize the insights:
           ```
           Combining these perspectives:
           [List of perspective insights]

           Create a comprehensive solution that leverages these diverse viewpoints.
           ```

        ## Implementation Notes
        - Select perspectives relevant to your specific problem
        - Customize instructions for each perspective
        - Vary the synthesis approach based on how divergent the perspectives are
        


        # Self-Consistency with Chain-of-Thought Pattern

        ## Example Implementation Structure
        ```python
        # This is a template - adapt freely to your needs

        # 1. Generate multiple reasoning paths with higher temperature
        reasoning_paths = []
        for i in range(num_paths):
            cot_prompt = f'''
            Please think step by step to solve this problem:

            {problem}

            Think carefully and show your complete reasoning.
            '''

            # Use higher temperature for diversity in reasoning
            reasoning = call_llm(cot_prompt, temperature=0.7)
            reasoning_paths.append(reasoning)

        # 2. Collect solutions that pass validation
        valid_solutions = []
        for reasoning in reasoning_paths:
            # Extract solution from reasoning
            solution = extract_solution(reasoning)

            # Validate solution against examples if available
            if examples and validate_against_examples(solution, examples):
                valid_solutions.append({"reasoning": reasoning, "solution": solution})

        # 3. Make final decision based on all valid reasoning paths
        ensemble_prompt = f'''
        Consider these different valid reasoning paths to solve the problem:

        Problem:
        {problem}

        Reasoning Paths:
        {format_reasoning_paths(valid_solutions)}

        Analyze all reasoning approaches carefully. Identify which reasoning is most sound.
        Provide a final solution based on the best reasoning approach.
        '''

        # Use lower temperature for final decision
        final_solution = call_llm(ensemble_prompt, temperature=0.1)
        ```

        ## Example Prompt for Generating Diverse Reasoning
        ```
        Solve this problem step by step:

        Problem: {problem}

        Show your complete reasoning process before giving the final answer.
        ```

        ## Example Prompt for Final Decision
        ```
        I've generated several different reasoning approaches to solve this problem:

        Problem: 
        {problem}

        Approach 1:
        {reasoning_1}

        Approach 2:
        {reasoning_2}

        Approach 3:
        {reasoning_3}

        Analyze these different reasoning approaches. Which approach has the most sound reasoning?
        Based on your analysis, provide the final answer to the problem.
        ```

        ## Implementation Notes
        - Higher temperature (0.7-0.9) creates more diverse reasoning paths
        - Consider keeping only reasoning paths that arrive at a consistent answer
        - The final decision can use majority voting or weighted evaluation of reasoning quality
        - This pattern is especially effective for problems with multiple valid solution paths
        - You can filter reasoning paths before the final decision based on consistency with examples
        - For critical applications, add verification to each reasoning path
        


        # Best-of-N with Verification Pattern

        ## Example Structure
        1. Generate multiple diverse solutions:
           ```
           Generate a {nth} solution to this problem:
           {problem}

           Make this approach different from typical solutions by [diversity instruction].
           ```

        2. Test each solution against examples:
           ```
           Check if this solution works for this test case:

           Solution: {solution}
           Test case: {test_case}

           Verify if the solution produces the correct result.
           ```

        3. Select the best solution based on performance:
           ```
           Compare these solutions based on [criteria].
           Which solution best addresses the problem?
           ```

        ## Implementation Notes
        - Force diversity in generation through specific instructions
        - Use different test cases to evaluate different aspects
        - Consider combining elements from multiple solutions
        - Customize evaluation criteria to match what matters most
        


        # ReAct (Reasoning + Acting) Pattern

        ## Example Prompt Structure
        ```
        Solve this problem using the ReAct pattern:

        Example:
        Problem: [example problem]

        Thought 1: [reasoning about what to do]
        Action 1: [type][[specific action]]
        Observation 1: [result of action]

        Thought 2: [reasoning based on observation]
        Action 2: [type][[specific action]]
        Observation 2: [result of action]

        ...

        Thought N: [final reasoning]
        Action N: Finish[[final answer]]

        Problem: {problem}

        Thought 1:
        ```

        ## Action Types to Consider:
        - Search[query]: To find information
        - Calculate[expression]: To perform calculations
        - Lookup[term]: To look up definitions
        - Extract[data, pattern]: To extract information
        - Analyze[data]: To analyze patterns or trends
        - Finish[answer]: To provide the final answer

        ## Implementation Notes
        - Adapt action types to match your task domain
        - Simulate realistic observations for each action
        - Create specialized handlers for each action type
        - Add verification steps between actions if needed
        


        # Feature Extraction Pattern

        ## Example Prompt Structure
        ```
        Analyze this input and extract key features:

        Input:
        {input}

        Extract features like:
        1. [Feature type 1 relevant to domain]
        2. [Feature type 2 relevant to domain]
        3. [Feature type 3 relevant to domain]

        For each feature, provide:
        - A clear description
        - Why it's significant
        - How it might relate to solving the problem
        ```

        ## Domain-Specific Feature Types:
        - Text analysis: themes, entities, sentiment, structure
        - Visual puzzles: shapes, positions, colors, transformations
        - Math problems: equations, constraints, variables, relationships
        - Logic puzzles: rules, constraints, entities, relationships

        ## Implementation Notes
        - Customize feature types based on your specific domain
        - Provide examples of good feature extraction
        - Consider different levels of abstraction
        - Features should simplify downstream processing
        


        # Pattern Identification Template

        ## Example Prompt Structure
        ```
        Examine these examples and identify all underlying patterns:

        Examples:
        [Example 1]
        [Example 2]
        [Example 3]

        For each pattern you identify:
        1. Describe the pattern precisely
        2. Show how it applies to the examples
        3. Explain how this pattern could be used

        Consider these types of patterns:
        - [Pattern type 1 relevant to domain]
        - [Pattern type 2 relevant to domain]
        - [Pattern type 3 relevant to domain]
        ```

        ## Pattern Types to Consider:
        - Spatial: position, size, symmetry, rotation, reflection
        - Transformation: addition, subtraction, multiplication, inversion
        - Sequence: repetition, alternation, progression, recursion
        - Visual: color, shape, size, orientation, grouping
        - Logical: conditionals, conjunctions, disjunctions, implications
        - Linguistic: syntax, semantics, structure, style, tone
        - Algorithmic: loops, conditionals, recursion, iteration
        - Psychological: motivation, emotion, belief, perception, cognition
        - Knowledge: facts, definitions, relationships, hierarchies, taxonomies
        - Structural: composition, decomposition, hierarchy, network, graph
        - Relational: cause, effect, correlation, comparison, contrast
        - Unknown: patterns that are not immediately obvious or familiar

        ## Implementation Notes
        - Encourage identification of multiple patterns
        - Ask for concrete examples of each pattern
        - Consider having the LLM rank pattern likelihood
        - Test identified patterns before applying them
        


        # Wait Injection Pattern

        ## Example Structure
        1. Get initial reasoning:
           ```
           Solve this problem step by step:
           {problem}
           ```

        2. Inject wait and reconsideration:
           ```
           Solve this problem step by step:
           {problem}

           {initial_reasoning_part}
           ...wait... let me reconsider this...

           [Reconsideration instruction]
           ```

        ## Reconsideration Instructions:
        - "Are there assumptions I made that might not be valid?"
        - "Is there a simpler approach I overlooked?"
        - "Let me check my logic carefully on the previous steps"
        - "Let me consider this problem from a different angle"

        ## Implementation Notes
        - Timing is critical - inject wait during critical reasoning
        - Customize reconsideration prompts to address common pitfalls
        - Experiment with multiple wait points for complex problems
        - Can be combined with perspective switching
        - "...wait..." token injection shown to trigger re-evaluation in LLMs
        


        # Hypothesis Testing Pattern

        ## Example Structure
        1. Generate multiple hypotheses:
           ```
           Generate {n} different hypotheses about the pattern in this problem:
           {problem}

           For each hypothesis:
           - State what the pattern might be
           - Explain your reasoning
           - Predict how it would apply to new examples
           ```

        2. Test each hypothesis against examples:
           ```
           Test these hypotheses:
           [List of hypotheses]

           Against these examples:
           [List of examples]

           For each hypothesis and example:
           - Apply the hypothesis
           - Check if the result matches the expected output
           - Note any discrepancies
           ```

        3. Refine based on results:
           ```
           Based on the testing results, refine the most promising hypothesis:
           [Testing results]

           Create an improved hypothesis that addresses any failures.
           ```

        ## Implementation Notes
        - Generate diverse hypotheses, not minor variations
        - Use examples that can distinguish between hypotheses
        - Consider combining elements from multiple hypotheses
        - Explicit refinement steps are critical for improvement
        


        # Data Analyzer Pattern

        ## Example Prompt Structure
        ```
        Analyze these examples to identify patterns and solution approaches:

        Examples:
        [Example data]

        Provide a comprehensive analysis with these sections:

        ## DATASET CHARACTERISTICS
        (What patterns exist in the data? What structures or formats are present?)

        ## CHALLENGE ASSESSMENT
        (What makes these problems difficult? What edge cases exist?)

        ## APPROACH RECOMMENDATIONS
        (What solution strategies would work well? How should the problem be decomposed?)

        ## IMPLEMENTATION CONSIDERATIONS
        (What verification steps are needed? What intermediate representations help?)
        ```

        ## Implementation Notes
        - Run this analysis before attempting solutions
        - Customize sections based on problem domain
        - Use insights to guide solution approach selection
        - Consider running on a subset of data first
        


        # Dynamic Memory Pattern

        ## Example Implementation Structure
        ```python
        # Initialize memory buffer
        memory_buffer = []

        # Generate initial candidate solutions
        initial_prompt = f'''
        Solve this problem with step-by-step reasoning:

        {problem}
        '''

        num_candidates = 5  # Number of initial candidates
        for i in range(num_candidates):
            # Vary temperature or instructions slightly for diversity
            solution = generate_solution(problem, temperature=0.7+i*0.05)

            # Evaluate solution quality
            evaluation = evaluate_solution(solution, test_examples)

            # Store in memory buffer
            memory_buffer.append({
                'solution': solution,
                'evaluation': evaluation,
                'score': evaluation.get('correct_count', 0),
                'iteration': 0
            })

        # Iterative refinement using memory
        max_iterations = 3
        for iteration in range(max_iterations):
            # Get recent memory entries to avoid redundancy
            recent_entries = memory_buffer[-num_candidates:]

            # Generate refined solutions based on memory
            refined_solutions = []
            for entry in recent_entries:
                refinement_prompt = f'''
                Refine this solution based on evaluation feedback:

                Problem: {problem}

                Previous solution:
                {entry['solution']}

                Evaluation feedback:
                {entry['evaluation'].get('feedback', 'No feedback available')}

                Provide an improved solution addressing the issues.
                '''

                refined = generate_solution(refinement_prompt, temperature=0.5)
                evaluation = evaluate_solution(refined, test_examples)

                # Add to refined solutions if unique
                if not any(r['solution'] == refined for r in refined_solutions):
                    refined_solutions.append({
                        'solution': refined,
                        'evaluation': evaluation,
                        'score': evaluation.get('correct_count', 0),
                        'iteration': iteration + 1,
                        'parent': entry
                    })

            # Add refined solutions to memory
            memory_buffer.extend(refined_solutions)

        # Select best solutions based on performance
        top_solutions = sorted(memory_buffer, key=lambda x: x['score'], reverse=True)[:3]

        # Synthesize final solution from top performers
        synthesis_prompt = f'''
        Create a final solution based on these top-performing approaches:

        Problem: {problem}

        Approach 1:
        {top_solutions[0]['solution']}
        Score: {top_solutions[0]['score']}

        Approach 2:
        {top_solutions[1]['solution']}
        Score: {top_solutions[1]['score']}

        Approach 3:
        {top_solutions[2]['solution']}
        Score: {top_solutions[2]['score']}

        Provide a solution that incorporates the strengths of all approaches.
        '''

        final_solution = generate_solution(synthesis_prompt, temperature=0.3)
        ```

        ## Implementation Notes
        - The memory buffer stores solution attempts, evaluations, and metadata
        - Solution refinement is guided by accumulated feedback
        - Memory creates continuity across iteration cycles
        - Memory can be structured to track different aspects (reasoning paths, errors, successful patterns)
        - Can add filtering to maintain diversity in the memory buffer
        - Memory can persist across different problems to build general knowledge
        - Consider memory management strategies for large buffers
        


        # Expert Panel Pattern

        ## Example Structure
        1. Collect perspectives from different experts:
           ```
           As an expert {expert_role}, analyze this problem:
           {problem}

           Provide analysis focusing on:
           [Expert-specific questions]
           ```

        2. Facilitate discussion between experts:
           ```
           The following experts are discussing this problem:
           [List of expert insights]

           Simulate a discussion where they:
           - Respond to each other's insights
           - Identify agreements and disagreements
           - Build on each other's ideas
           ```

        3. Build consensus solution:
           ```
           Based on this expert discussion:
           [Expert discussion]

           Develop a consensus solution that incorporates the key insights.
           ```

        ## Expert Roles to Consider:
        - Domain-specific roles (mathematician, logician, programmer)
        - Cognitive styles (analytical, creative, critical)
        - Process experts (planner, implementer, evaluator)

        ## Implementation Notes
        - Select experts relevant to your specific problem
        - Customize questions for each expert role
        - Structure the discussion to address key disagreements
        - Consider weighted consensus based on expertise relevance
        


        # Debate Pattern

        ## Example Structure
        1. Generate initial position:
           ```
           Provide a solution to this problem:
           {problem}
           ```

        2. Generate critique from opposing viewpoint:
           ```
           Critique this solution:
           {initial_solution}

           Identify specific weaknesses or overlooked considerations.
           ```

        3. Generate defense or refinement:
           ```
           Respond to this critique of your solution:
           {critique}

           Either defend your approach or refine it to address the critique.
           ```

        4. Generate synthesis and resolution:
           ```
           Based on this debate:
           [Initial solution]
           [Critique]
           [Defense/refinement]

           Provide an improved solution that incorporates valid points from both sides.
           ```

        ## Implementation Notes
        - Consider specific opposing viewpoints for your domain
        - Adjust number of debate rounds based on problem complexity
        - Focus critique on different aspects (correctness, efficiency, completeness)
        - Use explicit resolution criteria for synthesis
        


        # Comprehensive Verification Pattern

        ## Example Structure
        1. Perform multiple verification methods:
           - Logical consistency check
           - Test case verification
           - Alternative approach comparison
           - Edge case analysis

        2. Example logical check:
           ```
           Verify if this solution is logically consistent:
           {solution}

           Check for:
           - Internal contradictions
           - Unwarranted assumptions
           - Logical fallacies
           ```

        3. Example test case check:
           ```
           Apply this solution to this test case:

           Solution: {solution}
           Test case: {test_case}

           Does it produce the expected result?
           ```

        4. Create verification summary:
           ```
           Based on all verification results:
           [Verification results]

           Is the solution verified? If not, what specific issues need to be addressed?
           ```

        ## Implementation Notes
        - Customize verification methods to your domain
        - Always include feedback for failed verification
        - Consider confidence weighting for different methods
        - Include both syntactic and semantic verification
        


        # Self-Consistency Checking Pattern

        ## Example Structure
        1. Generate multiple independent solutions:
           ```
           Solve this problem:
           {problem}

           Provide a complete solution with your reasoning.
           ```

           (Repeat for multiple solutions)

        2. Extract answers from solutions:
           ```
           Extract the final answer from your solution.
           ```

        3. Check consistency across answers:
           ```
           Analyze these different answers to the same problem:
           [List of answers]

           Are they consistent? If not, which is most likely correct and why?
           ```

        ## Implementation Notes
        - Use different prompting for each solution attempt
        - Consider majority voting for consistent answers
        - For inconsistent results, analyze reasoning paths
        - Can be combined with verification of each solution
        


        # Pattern Combination Guide

        Patterns can and should be combined for complex tasks. Here are effective combinations:

        ## Verification + Generation Patterns
        - Apply verification to any generation pattern
        - Use feedback from verification to guide regeneration
        - Example: Few-shot learning with verification feedback loop

        ## Multi-Perspective + Debate
        - Generate perspectives from different experts
        - Have experts debate their approaches
        - Synthesize the best elements from the debate

        ## ReAct + Verification
        - Verify each action before proceeding
        - Use verification feedback to guide next actions
        - Add reflection steps between actions

        ## Chain of Thought + Wait Injection
        - Insert wait points during complex reasoning steps
        - Use wait points to reconsider assumptions
        - Continue chain of thought after reconsideration

        ## Data Analysis + Hypothesis Testing
        - Use data analysis to generate initial hypotheses
        - Test hypotheses systematically
        - Refine based on test results

        ## Creative Combinations
        Don't limit yourself to these suggestions! Experiment with novel combinations:
        - Start with data analysis, use expert panel to interpret, debate approaches, implement with ReAct
        - Generate hypotheses, verify with self-consistency, refine with expert feedback
        - Extract features, perform multi-perspective analysis, implement with verification loops

        The key is to match pattern combinations to the specific challenges of your task.
        


        # Pattern Adaptation Guide

        These patterns are starting points, not rigid prescriptions. Here's how to adapt them:

        ## Prompt Engineering
        - Adjust detail level based on task complexity
        - Modify tone and style to fit domain context
        - Add domain-specific terminology and concepts
        - Customize examples to match your specific task

        ## Function Logic
        - Simplify patterns for straightforward tasks
        - Expand patterns for complex reasoning
        - Modify verification criteria based on importance
        - Adjust number of iterations or perspectives based on needs

        ## Implementation Variants
        - Text-only implementations for pure LLM interaction
        - Hybrid implementations that combine LLM with code logic
        - Multi-stage pipelines that apply different patterns sequentially
        - Parallel implementations that generate multiple approaches

        ## Key Questions for Adaptation
        1. What's unique about my specific task?
        2. Which parts of the pattern are most relevant?
        3. What additional steps or checks are needed?
        4. How can I make the pattern more efficient for my context?

        Remember: These patterns are tools to be wielded creatively, not constraints!
        


        # Example: Adapting and Combining Patterns

        ## Original Task
        Solving grid pattern problems by identifying abstract transformation rules.

        ## Pattern Selection and Adaptation

        1. Start with Data Analyzer to understand grid structure:
        ```python
        # Customize the Data Analyzer pattern for grid analysis
        grid_analysis_prompt = f'''
        Analyze these grid transformation examples:
        {examples}

        Focus specifically on:
        - Spatial relationships in the grid
        - Transformation rules between input and output
        - Pattern constraints and edge cases
        - Potential algorithms for transformation
        '''

        analysis = call_llm(grid_analysis_prompt)
        ```

        2. Apply Pattern Identification with domain customization:
        ```python
        # Adapt the Pattern Identification template for grid transformations
        pattern_prompt = f'''
        Identify transformation patterns in these grid examples:
        {examples}

        For each example, analyze these aspects:
        - Cell-to-cell transformations
        - Row/column operations
        - Shape preservation or alteration
        - Color or value changes
        - Positional shifts or rotations

        Describe each pattern precisely and show how it applies.
        '''

        patterns = call_llm(pattern_prompt)
        ```

        3. Combine with Hypothesis Testing:
        ```python
        # Generate hypotheses about transformation rules
        hypothesis_prompt = f'''
        Based on these identified patterns:
        {patterns}

        Generate 3 different hypotheses about the transformation rules.
        For each hypothesis:
        - Clearly state the transformation rule
        - Explain how it works on each example
        - Predict what would happen with different inputs
        '''

        hypotheses = call_llm(hypothesis_prompt)

        # Test each hypothesis
        for hypothesis in parse_hypotheses(hypotheses):
            verification_prompt = f'''
            Test this hypothesis against all examples:
            {hypothesis}

            Examples:
            {examples}

            For each example, show whether the hypothesis:
            - Correctly predicts the transformation
            - Fails to explain some aspect
            - Needs refinement (and how)
            '''

            verification = call_llm(verification_prompt)
            hypothesis_results.append(verification)
        ```

        4. Add Verification with Feedback Loop:
        ```python
        # Apply best hypothesis to new problem with verification
        for attempt in range(max_attempts):
            solution = apply_best_hypothesis(new_problem, best_hypothesis)

            verification_prompt = f'''
            Verify this solution:
            {solution}

            Check:
            - Does it follow the established transformation rule?
            - Are there any errors in application?
            - Is the output grid format correct?

            Return specific feedback on any issues.
            '''

            verification = call_llm(verification_prompt)

            if is_valid(verification):
                return solution

            # Refine with feedback
            refinement_prompt = f'''
            Refine this solution based on feedback:

            Solution: {solution}
            Feedback: {extract_feedback(verification)}

            Create an improved solution addressing all issues.
            '''

            solution = call_llm(refinement_prompt)
        ```

        ## Key Adaptation Points
        - Added grid-specific terminology to all prompts
        - Modified pattern identification to focus on spatial relationships
        - Added grid-specific hypotheses and testing
        - Customized verification criteria for grid transformations
        - Combined four different patterns in a cohesive workflow
        

        LEARNINGS FROM PREVIOUS ITERATIONS:
        
            ACCUMULATED LEARNINGS FROM PREVIOUS ITERATIONS:
            === INITIAL DATASET ANALYSIS [2025-05-06 21:50:16] ===

    Okay, I've analyzed the provided dataset of grid transformation tasks. Here's a breakdown of my findings:

## DATASET CHARACTERISTICS

*   **Patterns in Questions:**
    *   All questions follow a consistent format: "Grid Transformation Task\n\n=== TRAINING EXAMPLES ===\n\nExample 1:\nInput Grid:\n...\nOutput Grid:\n...\n\n=== TEST INPUT ===\n...\nTransform the test input according to the pattern shown in the training examples."
    *   The training examples provide input-output pairs to illustrate the transformation rule.
    *   The core task is to infer the transformation rule from the examples and apply it to the test input.
    *   Questions tend to vary in grid sizes, number of training examples, and complexity of the transformation rule.

*   **Patterns in Answers:**
    *   Answers are always grid structures, represented as lists of lists.
    *   The numbers within the grids are typically integers.
    *   The answer grid's dimensions are dependent on the input grid and the inferred transformation.
    *   The answers directly reflect the application of the transformation rule to the test input.

*   **Structure and Format:**
    *   **Input:** Questions are text-based, containing structured information about the training examples and the test input, with grids formatted as lists of lists represented as strings.
    *   **Output:** Answers are grid structures in a string representation.
    *   Grids are typically represented as two-dimensional arrays of integers.

*   **Domain Knowledge:**
    *   **Spatial Reasoning:** Understanding how shapes, patterns, and arrangements change.
    *   **Pattern Recognition:** Identifying repeating sequences or relationships within the grids.
    *   **Logical Inference:** Deducing the transformation rule based on limited examples.
    *   **Array Manipulation:** Understanding how to access and modify elements within a grid.

*   **Question Types:**
    *   All questions are of the same general type: *grid transformation*.  However, the specific transformations vary, leading to different sub-types:
        *   **Expansion and Value Replication:**  Expanding the grid dimensions and repeating values (Example 0).
        *   **Value Modification based on Position/Neighbors:** Changing values based on their location or the values of adjacent cells (Example 1).
        *   **Complex Combination:** Combining aspects of expansion, replication, and conditional modification (Example 4).

*   **Reasoning Types:**
    *   **Inductive Reasoning:** Generalizing a rule from specific examples. This is core to all the examples.
    *   **Spatial Reasoning:**  Understanding the relationships between grid elements.
    *   **Algorithmic Reasoning:**  Formulating a step-by-step process to transform the grid.
    *   **Edge Case Handling:**  Determining how the transformation applies to elements on the borders of the grid.

## DATA CHALLENGES

*   **Difficulty Factors:**
    *   **Ambiguity:** The training examples may not fully specify the transformation rule, leading to multiple possible interpretations.
    *   **Abstraction:**  The rules may be abstract and not directly related to the numerical values.
    *   **Complexity:**  Some transformations involve intricate combinations of steps.
    *   **Limited Examples:** Often, only a few examples are provided, making generalization difficult.

*   **Edge Cases and Complexities:**
    *   **Grid Boundaries:** Rules might behave differently at the edges of the grid.
    *   **Varying Grid Sizes:** The rule may need to adapt to different input grid dimensions.
    *   **Nested Patterns:** The rule might involve multiple levels of pattern recognition (e.g., identifying sub-patterns within the grid).
    *   **Conditional Transformations:** Certain transformations may depend on specific conditions within the input grid.

*   **Reasoning Requirements:**
    *   **Pattern Recognition:** Identifying the core transformation being applied.
    *   **Abstraction:** Representing the transformation in a general, reusable form.
    *   **Rule Application:** Consistently applying the rule to the test input.
    *   **Verification:** Ensuring that the transformed grid adheres to the inferred rule.

## POTENTIAL APPROACHES

*   **Solution Strategies:**
    1.  **Pattern Matching and Rule Extraction:**
        *   Analyze the training examples to identify the changes between input and output grids.
        *   Formulate a symbolic representation of the transformation rule. This can be thought of as a short program or set of instructions.
    2.  **Transformation Simulation:**
        *   Implement the inferred rule as a series of operations on the grid.
        *   Apply the operations to the test input.
    3.  **Example-Based Reasoning:**
        *   Compare the test input to the training inputs to identify similar patterns.
        *   Adapt the transformation from the closest training example to the test input.
    4. **Decomposition:** Break down the grid transformation into smaller, manageable sub-transformations.

*   **Decomposition:**
    1.  **Dimension Analysis:** Determine how the dimensions (rows and columns) of the grid change.
    2.  **Value Mapping:** Identify how individual values are transformed (e.g., 0 becomes 2, 1 becomes 2).
    3.  **Neighborhood Analysis:** Analyze how a cell's value is influenced by its neighbors.
    4.  **Rule Combination:** Combine these individual transformations to create the complete rule.

*   **Validation Techniques:**
    1.  **Symmetry Checks:** Verify if the transformation preserves or introduces symmetry in the grid.
    2.  **Value Distribution:** Analyze if the distribution of values changes in a predictable way.
    3.  **Visual Inspection:** (If possible) Display the transformed grid to check for obvious errors.
    4. **Training example re-application:** Re-apply the inferred transformation to the training inputs. Do you get the training outputs?

*   **Unusual/Edge Case Handling:**
    *   **Default Values:** Define a default value to use when the rule cannot be applied (e.g., for out-of-bounds cells).
    *   **Conditional Logic:** Incorporate conditional statements into the rule to handle specific cases.
    *   **Exception Handling:** Catch and handle errors that occur during the transformation process.

## CREATIVE INSIGHTS

*   **Non-Obvious Patterns:**
    *   **Frequency Analysis:** Look at how often each number occurs in the input and output grids; this may reveal patterns or biases in the transformation.
    *   **Delta Grids:**  Create a grid that represents the *difference* between the input and output grids. This can highlight the parts of the grid that are changing.
*   **Unique Perspectives:**
    *   **Treating Grids as Images:** Use image processing techniques (blur, edge detection, etc.) to find patterns and transformations. This is only an analogy to guide the reasoning.
*   **Analogies:**
    *   **Cellular Automata:** Drawing an analogy to cellular automata, where each cell updates based on its neighbors, might help in defining local transformation rules.
    *   **Image Resizing Algorithms:** Relate grid expansion to image resizing and use related algorithms.

## IMPLEMENTATION RECOMMENDATIONS

*   **Verification Steps:**
    1.  **Rule Consistency:**  Check that the inferred transformation rule is consistent across all training examples.
    2.  **Boundary Condition Testing:**  Specifically test how the rule applies to elements near the grid boundaries.
    3.  **Intermediate State Inspection:**  If possible, visualize the grid at intermediate steps during the transformation.

*   **Intermediate Representations:**
    1.  **Symbolic Rule Representation:**  Represent the inferred rule as a symbolic expression or a sequence of operations. Example: `"Expand grid by factor of 3. Replace 1 with 2."`
    2.  **Transformation Matrix:** If the transformation involves linear operations, use a transformation matrix. (Less likely to be helpful here).
    3.  **Heatmaps:** Visualize the changes in the grid with heatmaps to identify transformation hotspots.

*   **Text-Based Techniques:**

    Given the preference for text-based processing to avoid JSON parsing complexities, I suggest these specific techniques:

    1.  **Direct Pattern Extraction from Text:**
        *   Use regex or string manipulation to directly identify the grid dimensions and values from the input text.
        *   Write functions that operate on string representations of grids to extract relevant information.
    2.  **Symbolic Rule Encoding in Text:**
        *   Represent the inferred transformation rule in natural language as a string. For example:
            *   `"Each cell is multiplied by 2"`
            *   `"Expand grid 3x3. If cell value is X, replace with Y."`
        *   The LLM then uses this string description to perform the transformation.
    3.  **Step-by-Step Transformation Instructions:**
        *   Instead of a complex program, give the LLM a series of explicit instructions, like:
            1.  `"Read the input grid."`
            2.  `"Determine the grid's dimensions."`
            3.  `"For each cell, apply the following rule: ..."`
            4.  `"Construct the output grid with the transformed values."`
            5.  `"Format the output grid as a list of lists."`
    4.  **Few-Shot Learning with Demonstrations:**
        *   Augment the prompt with additional examples that demonstrate the step-by-step reasoning process. This can guide the LLM's reasoning and improve its performance.
    5.  **Output Formatting Prompts:**
        *   Provide the LLM with explicit instructions on how to format the output grid. For example:
            *   `"The output must be a string representation of a list of lists, with each inner list representing a row in the grid."`
            *   `"Use commas to separate the numbers in each row, and enclose each row in square brackets."`

By focusing on leveraging the LLM's natural language understanding and reasoning abilities, we can minimize the need for complex code generation and JSON parsing, leading to more robust and efficient solutions.


    === END INITIAL DATASET ANALYSIS ===
            

        CAPABILITY ASSESSMENT & IMPROVEMENT GUIDANCE:
        
            CAPABILITY ASSESSMENT & IMPROVEMENT GUIDANCE:
            SYSTEM ANALYSIS & GUIDANCE


            

        EXPLORATION GUIDANCE:
        1. Review the historical approaches, error patterns, and accumulated learnings carefully
        2. Review the FULL CODE of previous scripts to understand what has already been tried
        3. Design a new approach that is DISTINCTLY DIFFERENT from previous attempts. This approach should have a specific NEW HYPOTHESIS or variable you are trying to test. Carefully and fairly evaluate whether the hypothesis should be accepted, rejected, re-tested, or something else, making reference to specific outputs, reasoning steps, error messages, or other evidence from the exectuion.
        4. CRITICAL: Include EMBEDDED EXAMPLES directly within your LLM prompts
        5. For each key function, show a complete worked example, or include multiple examples, including:
           - Input example that resembles the dataset
           - Step-by-step reasoning through the example
           - Properly formatted output
        6. Apply the insights from the ACCUMULATED LEARNINGS section to avoid repeating past mistakes
        7. Pay SPECIAL ATTENTION to the weaknesses and improvement suggestions from the capability assessment
        8. Consider implementing one or more of these LLM usage patterns:
           - Repeated validation with feedback loops
           - Multi-perspective analysis with synthesis
           - Dynamic input-dependent routing with an orchestrator
           - Hybrid approaches combining LLM with deterministic functions
           - Best-of-n solution generation and selection
           - ReAct pattern for interactive reasoning and action
           - If it is unknown how successful a processing state or part of the pipeline is, include verification steps to different parts of the pipeline in order to help deduce which parts are successful and where the system is breaking
           - Answer checkers to validate the final answer against the problem statement. If the answer is incorrect, the checker can send the answer back to an earlier part of the system for for refinement with feedback

        Here's how to call the Gemini API. ONLY call it in this format and DO NOT make up configuration options!:
        def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. DO NOT deviate from this example template or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

        Since this is an EXPLORATION phase:
        - Try a fundamentally different approach to reasoning about the problem. Test a NEW HYPOTHESIS or variable, and add verification steps to deduce if this new change is helpful. Carefully and fairly evaluate whether the hypothesis should be accepted, rejected, re-tested, or something else, making reference to specific outputs, reasoning steps, error messages, or other evidence from the exectuion.
        - THIS IS KEY: Break down the problem into new, distinct reasoning steps based on past performance before you start coding
        - For EACH key LLM prompt, include a relevant example with:
          * Sample input similar to the dataset
          * Expected reasoning steps
          * Desired output format
        - Apply a verifier call to different parts of the pipeline in order to understand what parts of the pipeline of calls is successful and where the system is breaking
        - Pay special attention to addressing the primary issues from previous iterations
        - Ensure your new approach addresses the weaknesses identified in the capability assessment

        CRITICAL REQUIREMENTS:
        1. The script MUST properly handle all string literals - be extremely careful with quotes and triple quotes
        2. The script MUST NOT exceed 150 lines of code to prevent truncation
        3. Include detailed comments explaining your reasoning approach
        4. EVERY SINGLE LLM PROMPT must include at least one embedded example showing:
           - Sample input with reasoning
           - Desired output format
        5. Make proper use of error handling
        6. Implement robust capabilities to address the specific weaknesses identified in the capability assessment
        7. Do NOT use json.loads() in the LLM calls to process input data. JSON formatting is good to use to structure information as inputs and outputs, but attempting to have functions process JSON data explicitly with strict built-in functionality is error prone due to formatting issues and additional text that appears as documentation, reasoning, or comments. When passing data into another LLM call, you can read it as plain text rather than trying to load it in strict json format, is the better approach.

        Return a COMPLETE, RUNNABLE Python script that:
        1. Has a main function that takes a question string as input and returns the answer string
        2. Makes multiple LLM calls for different reasoning steps
        3. Has proper error handling for API calls
        4. Includes embedded examples in EVERY LLM prompt
        5. Is COMPLETE - no missing code, no "..." placeholders
        6. Closes all string literals properly

        This should be FUNDAMENTALLY DIFFERENT from all previous approaches. Do not reuse the same overall structure.

        BE EXTREMELY CAREFUL TO PROPERLY CLOSE ALL STRING QUOTES AND TRIPLE QUOTES!
        