
            You are developing a Python script to solve problems using LLM reasoning capabilities.
            You are in the EXPLORATION PHASE. You must generate a NEW approach that's different from previous approaches but informed by their successes and failures. With this approach, you will have a specific NEW HYPOTHESIS or variable you are trying to test. Your goal is to see if this new approach works, and you must add verification and validation steps to deduce if this new change is helpful. You may also test RADICAL NEW APPROACHES that are substantially different from previous approaches. 
            
            You should try NEW THINGS:
            
            Break down the problem into smaller pieces
            Think CREATIVELY about how to solve your problem if other approaches aren't working
            Transform data into different formats to see if it helps

            # YOUR TASK
            You are deeply familiar with prompting techniques and the agent works from the literature. 
            Your goal is to maximize the specified performance metrics by proposing interestingly new agents.
            Observe the past discovered agents and scripts carefully and think about what insights, lessons, or stepping stones can be learned from them.
            Be creative when thinking about the next interesting agent to try. You are encouraged to draw inspiration from related agent papers or academic papers from other research areas.
            Use the knowledge from the archive and inspiration from academic literature to propose the next interesting agentic system design.
            THINK OUTSIDE THE BOX.
            

            Here are example problems from previously seen data:
            [
  {
    "id": 0,
    "question": "=== TRAINING EXAMPLES ===\n\nExample 1:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 5, 5, 0, 1, 0, 0, 0, 0, 1, 0, 5, 5, 6, 6, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 5, 0, 0, 6, 6, 5, 0, 1, 0, 0, 7, 7, 0, 0, 1, 0, 5, 6, 6, 0, 0, 5, 0, 0, 0]\n  [0, 0, 7, 7, 0, 0, 0, 7, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 0, 0, 0, 7, 7]\n  [0, 0, 7, 7, 0, 0, 7, 0, 5, 0, 0, 4, 0, 7, 0, 2, 2, 0, 7, 0, 4, 0, 0, 5, 0, 7, 0, 0, 7, 7]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 4, 0, 0, 4, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n  [0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 7, 0, 7, 0, 9, 9, 9, 9, 9, 9, 9, 9]\n  [0, 0, 0, 7, 0, 0, 3, 0, 0, 0, 0, 0, 4, 0, 8, 0, 0, 8, 0, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9]\n  [0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 9, 9, 9, 9, 9, 9, 9]\n  [9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 9, 9, 9, 9, 9, 9, 9, 9]\n  [9, 9, 9, 9, 9, 9, 9, 7, 0, 8, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9]\n  [9, 9, 9, 9, 9, 9, 9, 0, 4, 0, 0, 5, 9, 9, 9, 9, 9, 9, 9, 0, 5, 0, 9, 9, 9, 9, 9, 9, 9, 9]\n  [5, 0, 0, 4, 0, 7, 0, 2, 0, 0, 5, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 5, 9, 9, 9, 9, 9, 9, 4, 0]\n  [0, 1, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 1, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0]\n  [1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0]\n  [0, 0, 0, 0, 4, 0, 8, 0, 0, 0, 0, 7, 9, 9, 9, 9, 9, 9, 9, 0, 7, 0, 0, 0, 0, 8, 0, 4, 0, 0]\n  [0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 7, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 7, 0, 0, 0, 0, 0, 0, 2, 0]\n  [0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 7, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 7, 0, 0, 0, 0, 0, 0, 2, 0]\n  [0, 0, 0, 0, 4, 0, 8, 0, 0, 0, 0, 7, 0, 1, 1, 0, 0, 1, 1, 0, 7, 0, 0, 0, 0, 8, 0, 4, 0, 0]\n  [1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0]\n  [0, 1, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0]\n  [5, 0, 0, 4, 0, 7, 0, 2, 0, 0, 5, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 5, 0, 0, 2, 0, 7, 0, 4, 0]\n  [5, 5, 4, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 7, 7, 0, 0, 0, 5, 0, 0, 4, 0, 0, 0, 0, 0, 4]\n  [6, 6, 5, 0, 1, 0, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 5]\n  [6, 6, 5, 5, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 5, 5]\n  [0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0, 7]\n  [0, 0, 0, 7, 0, 0, 3, 0, 0, 0, 0, 0, 4, 0, 8, 0, 0, 8, 0, 4, 0, 0, 0, 0, 0, 3, 0, 0, 7, 0]\n  [0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 7, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 4, 0, 0, 4, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 7, 7, 0, 0, 7, 0, 5, 0, 0, 4, 0, 7, 0, 2, 2, 0, 7, 0, 4, 0, 0, 5, 0, 7, 0, 0, 7, 7]\n  [0, 0, 7, 7, 0, 0, 0, 7, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 0, 0, 0, 7, 7]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 5, 5, 0, 1, 0, 0, 0, 0, 1, 0, 5, 5, 6, 6, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 5, 0, 0, 6, 6, 5, 0, 1, 0, 0, 7, 7, 0, 0, 1, 0, 5, 6, 6, 0, 0, 5, 0, 0, 0]\n  [0, 0, 7, 7, 0, 0, 0, 7, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 0, 0, 0, 7, 7]\n  [0, 0, 7, 7, 0, 0, 7, 0, 5, 0, 0, 4, 0, 7, 0, 2, 2, 0, 7, 0, 4, 0, 0, 5, 0, 7, 0, 0, 7, 7]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 4, 0, 0, 4, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n  [0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 7, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 7, 0, 0, 3, 0, 0, 0, 0, 0, 4, 0, 8, 0, 0, 8, 0, 4, 0, 0, 0, 0, 0, 3, 0, 0, 7, 0]\n  [0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0, 7]\n  [6, 6, 5, 5, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 5, 5]\n  [6, 6, 5, 0, 1, 0, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 5]\n  [5, 5, 4, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 7, 7, 0, 0, 0, 5, 0, 0, 4, 0, 0, 0, 0, 0, 4]\n  [5, 0, 0, 4, 0, 7, 0, 2, 0, 0, 5, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 5, 0, 0, 2, 0, 7, 0, 4, 0]\n  [0, 1, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0]\n  [1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0]\n  [0, 0, 0, 0, 4, 0, 8, 0, 0, 0, 0, 7, 0, 1, 1, 0, 0, 1, 1, 0, 7, 0, 0, 0, 0, 8, 0, 4, 0, 0]\n  [0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 7, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 7, 0, 0, 0, 0, 0, 0, 2, 0]\n  [0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 7, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 7, 0, 0, 0, 0, 0, 0, 2, 0]\n  [0, 0, 0, 0, 4, 0, 8, 0, 0, 0, 0, 7, 0, 1, 1, 0, 0, 1, 1, 0, 7, 0, 0, 0, 0, 8, 0, 4, 0, 0]\n  [1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0]\n  [0, 1, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0]\n  [5, 0, 0, 4, 0, 7, 0, 2, 0, 0, 5, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 5, 0, 0, 2, 0, 7, 0, 4, 0]\n  [5, 5, 4, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 7, 7, 0, 0, 0, 5, 0, 0, 4, 0, 0, 0, 0, 0, 4]\n  [6, 6, 5, 0, 1, 0, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 5]\n  [6, 6, 5, 5, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 5, 5]\n  [0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0, 7]\n  [0, 0, 0, 7, 0, 0, 3, 0, 0, 0, 0, 0, 4, 0, 8, 0, 0, 8, 0, 4, 0, 0, 0, 0, 0, 3, 0, 0, 7, 0]\n  [0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 7, 0, 0, 0, 0, 7, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 0, 4, 0, 0, 4, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 7, 7, 0, 0, 7, 0, 5, 0, 0, 4, 0, 7, 0, 2, 2, 0, 7, 0, 4, 0, 0, 5, 0, 7, 0, 0, 7, 7]\n  [0, 0, 7, 7, 0, 0, 0, 7, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 0, 0, 0, 7, 7]\n]\nExample 2:\nInput Grid:\n[\n  [3, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 3, 1, 0, 8, 0, 0, 8, 0, 1, 3, 3, 8, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 8, 0, 3, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0]\n  [0, 0, 7, 7, 0, 0, 4, 0, 3, 3, 4, 4, 8, 0, 6, 6, 6, 6, 0, 8, 4, 9, 9, 9, 9, 9, 0, 0, 7, 7]\n  [0, 0, 7, 0, 0, 3, 0, 0, 3, 0, 4, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 9, 9, 9, 9, 9, 3, 0, 0, 7]\n  [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 8, 0, 3, 0, 8, 0, 0, 8, 0, 3, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 0, 1, 1, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 1, 1, 0, 0, 3, 0]\n  [0, 0, 4, 0, 1, 1, 0, 2, 8, 0, 6, 6, 8, 0, 1, 1, 1, 1, 0, 8, 6, 6, 0, 8, 2, 0, 1, 1, 0, 4]\n  [0, 3, 0, 0, 1, 1, 2, 2, 0, 0, 6, 6, 0, 0, 1, 0, 0, 1, 0, 0, 6, 6, 0, 0, 2, 2, 1, 1, 0, 0]\n  [0, 8, 3, 3, 1, 0, 8, 0, 0, 0, 1, 0, 0, 5, 7, 0, 0, 7, 5, 0, 0, 1, 0, 0, 0, 8, 0, 1, 3, 3]\n  [8, 0, 3, 0, 0, 1, 0, 0, 0, 8, 0, 0, 5, 0, 0, 7, 7, 0, 0, 5, 0, 0, 8, 0, 0, 0, 1, 0, 0, 3]\n  [3, 3, 4, 4, 8, 0, 6, 6, 1, 0, 2, 2, 7, 0, 0, 7, 7, 0, 0, 7, 2, 2, 0, 1, 6, 6, 0, 8, 4, 4]\n  [3, 0, 4, 0, 0, 0, 6, 6, 0, 0, 2, 0, 0, 7, 7, 0, 0, 7, 7, 0, 0, 2, 0, 0, 6, 6, 0, 0, 0, 4]\n  [1, 0, 8, 0, 3, 0, 8, 0, 0, 5, 7, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 7, 5, 0, 0, 8, 0, 3, 0, 8]\n  [0, 1, 0, 0, 0, 3, 0, 0, 5, 0, 0, 7, 5, 5, 0, 0, 0, 0, 5, 5, 7, 0, 0, 5, 0, 0, 3, 0, 0, 0]\n  [8, 0, 6, 6, 8, 0, 1, 1, 7, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 1, 1, 0, 8, 6, 6]\n  [0, 0, 6, 6, 0, 0, 1, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 0, 0, 1, 0, 0, 6, 6]\n  [0, 0, 6, 6, 0, 0, 1, 0, 0, 9, 9, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 0, 0, 1, 0, 0, 6, 6]\n  [8, 0, 6, 6, 8, 0, 1, 1, 7, 9, 9, 7, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 1, 1, 0, 8, 6, 6]\n  [0, 1, 0, 0, 0, 3, 0, 0, 5, 0, 0, 7, 5, 5, 0, 0, 0, 0, 5, 5, 7, 9, 9, 5, 0, 0, 3, 0, 0, 0]\n  [1, 0, 8, 0, 3, 0, 8, 0, 0, 5, 7, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 9, 9, 0, 0, 8, 0, 3, 0, 8]\n  [3, 0, 4, 0, 0, 0, 6, 6, 0, 0, 2, 0, 0, 7, 7, 0, 0, 7, 7, 0, 0, 9, 9, 0, 6, 6, 0, 0, 0, 4]\n  [3, 3, 4, 4, 8, 0, 6, 6, 1, 0, 2, 2, 7, 0, 0, 7, 7, 0, 0, 7, 2, 2, 0, 1, 6, 6, 0, 8, 4, 4]\n  [8, 0, 3, 0, 0, 1, 0, 0, 0, 8, 0, 0, 5, 0, 0, 7, 7, 0, 0, 5, 0, 0, 8, 0, 0, 0, 1, 0, 0, 3]\n  [0, 8, 3, 3, 1, 0, 8, 0, 0, 0, 1, 0, 0, 5, 7, 0, 0, 7, 5, 0, 0, 1, 0, 0, 0, 8, 0, 1, 3, 3]\n  [0, 3, 0, 0, 1, 1, 2, 2, 0, 0, 6, 6, 0, 0, 1, 0, 0, 1, 0, 0, 6, 6, 0, 0, 2, 2, 1, 1, 0, 0]\n  [0, 0, 4, 0, 1, 1, 0, 2, 8, 0, 6, 6, 8, 0, 1, 1, 1, 1, 0, 8, 9, 9, 9, 9, 9, 9, 1, 1, 0, 4]\n  [0, 0, 0, 3, 0, 0, 1, 1, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 9, 9, 9, 9, 9, 9, 0, 0, 3, 0]\n  [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 8, 0, 3, 0, 8, 0, 0, 8, 0, 3, 0, 8, 0, 1, 1, 1, 0, 0, 0, 0]\n  [0, 0, 7, 0, 0, 3, 0, 0, 3, 0, 4, 0, 0, 0, 6, 6, 6, 9, 9, 9, 9, 9, 9, 9, 0, 0, 3, 0, 0, 7]\n  [0, 0, 7, 7, 0, 0, 4, 0, 3, 3, 4, 4, 8, 0, 6, 6, 6, 9, 9, 9, 9, 9, 9, 9, 0, 4, 0, 0, 7, 7]\n]\n\nOutput Grid:\n[\n  [3, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 3, 1, 0, 8, 0, 0, 8, 0, 1, 3, 3, 8, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 3, 8, 0, 3, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 3, 0, 8, 3, 0, 0, 0, 0, 0]\n  [0, 0, 7, 7, 0, 0, 4, 0, 3, 3, 4, 4, 8, 0, 6, 6, 6, 6, 0, 8, 4, 4, 3, 3, 0, 4, 0, 0, 7, 7]\n  [0, 0, 7, 0, 0, 3, 0, 0, 3, 0, 4, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 4, 0, 3, 0, 0, 3, 0, 0, 7]\n  [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 8, 0, 3, 0, 8, 0, 0, 8, 0, 3, 0, 8, 0, 1, 1, 1, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 0, 1, 1, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 1, 1, 0, 0, 3, 0]\n  [0, 0, 4, 0, 1, 1, 0, 2, 8, 0, 6, 6, 8, 0, 1, 1, 1, 1, 0, 8, 6, 6, 0, 8, 2, 0, 1, 1, 0, 4]\n  [0, 3, 0, 0, 1, 1, 2, 2, 0, 0, 6, 6, 0, 0, 1, 0, 0, 1, 0, 0, 6, 6, 0, 0, 2, 2, 1, 1, 0, 0]\n  [0, 8, 3, 3, 1, 0, 8, 0, 0, 0, 1, 0, 0, 5, 7, 0, 0, 7, 5, 0, 0, 1, 0, 0, 0, 8, 0, 1, 3, 3]\n  [8, 0, 3, 0, 0, 1, 0, 0, 0, 8, 0, 0, 5, 0, 0, 7, 7, 0, 0, 5, 0, 0, 8, 0, 0, 0, 1, 0, 0, 3]\n  [3, 3, 4, 4, 8, 0, 6, 6, 1, 0, 2, 2, 7, 0, 0, 7, 7, 0, 0, 7, 2, 2, 0, 1, 6, 6, 0, 8, 4, 4]\n  [3, 0, 4, 0, 0, 0, 6, 6, 0, 0, 2, 0, 0, 7, 7, 0, 0, 7, 7, 0, 0, 2, 0, 0, 6, 6, 0, 0, 0, 4]\n  [1, 0, 8, 0, 3, 0, 8, 0, 0, 5, 7, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 7, 5, 0, 0, 8, 0, 3, 0, 8]\n  [0, 1, 0, 0, 0, 3, 0, 0, 5, 0, 0, 7, 5, 5, 0, 0, 0, 0, 5, 5, 7, 0, 0, 5, 0, 0, 3, 0, 0, 0]\n  [8, 0, 6, 6, 8, 0, 1, 1, 7, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 1, 1, 0, 8, 6, 6]\n  [0, 0, 6, 6, 0, 0, 1, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 0, 0, 1, 0, 0, 6, 6]\n  [0, 0, 6, 6, 0, 0, 1, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 0, 0, 1, 0, 0, 6, 6]\n  [8, 0, 6, 6, 8, 0, 1, 1, 7, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 1, 1, 0, 8, 6, 6]\n  [0, 1, 0, 0, 0, 3, 0, 0, 5, 0, 0, 7, 5, 5, 0, 0, 0, 0, 5, 5, 7, 0, 0, 5, 0, 0, 3, 0, 0, 0]\n  [1, 0, 8, 0, 3, 0, 8, 0, 0, 5, 7, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 7, 5, 0, 0, 8, 0, 3, 0, 8]\n  [3, 0, 4, 0, 0, 0, 6, 6, 0, 0, 2, 0, 0, 7, 7, 0, 0, 7, 7, 0, 0, 2, 0, 0, 6, 6, 0, 0, 0, 4]\n  [3, 3, 4, 4, 8, 0, 6, 6, 1, 0, 2, 2, 7, 0, 0, 7, 7, 0, 0, 7, 2, 2, 0, 1, 6, 6, 0, 8, 4, 4]\n  [8, 0, 3, 0, 0, 1, 0, 0, 0, 8, 0, 0, 5, 0, 0, 7, 7, 0, 0, 5, 0, 0, 8, 0, 0, 0, 1, 0, 0, 3]\n  [0, 8, 3, 3, 1, 0, 8, 0, 0, 0, 1, 0, 0, 5, 7, 0, 0, 7, 5, 0, 0, 1, 0, 0, 0, 8, 0, 1, 3, 3]\n  [0, 3, 0, 0, 1, 1, 2, 2, 0, 0, 6, 6, 0, 0, 1, 0, 0, 1, 0, 0, 6, 6, 0, 0, 2, 2, 1, 1, 0, 0]\n  [0, 0, 4, 0, 1, 1, 0, 2, 8, 0, 6, 6, 8, 0, 1, 1, 1, 1, 0, 8, 6, 6, 0, 8, 2, 0, 1, 1, 0, 4]\n  [0, 0, 0, 3, 0, 0, 1, 1, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 1, 1, 0, 0, 3, 0]\n  [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 8, 0, 3, 0, 8, 0, 0, 8, 0, 3, 0, 8, 0, 1, 1, 1, 0, 0, 0, 0]\n  [0, 0, 7, 0, 0, 3, 0, 0, 3, 0, 4, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 4, 0, 3, 0, 0, 3, 0, 0, 7]\n  [0, 0, 7, 7, 0, 0, 4, 0, 3, 3, 4, 4, 8, 0, 6, 6, 6, 6, 0, 8, 4, 4, 3, 3, 0, 4, 0, 0, 7, 7]\n]\nExample 3:\nInput Grid:\n[\n  [0, 5, 0, 0, 0, 5, 0, 0, 8, 8, 0, 4, 4, 4, 0, 0, 0, 9, 9, 9, 9, 0, 8, 8, 0, 0, 5, 0, 0, 0]\n  [5, 0, 0, 0, 5, 0, 0, 0, 8, 0, 4, 4, 4, 4, 0, 3, 3, 9, 9, 9, 9, 4, 0, 8, 0, 0, 0, 5, 0, 0]\n  [0, 0, 0, 1, 0, 0, 4, 4, 0, 4, 2, 0, 0, 0, 8, 8, 8, 9, 9, 9, 9, 2, 4, 0, 4, 4, 0, 0, 1, 0]\n  [0, 0, 1, 1, 0, 0, 4, 0, 4, 4, 0, 0, 0, 3, 8, 0, 0, 9, 9, 9, 9, 0, 4, 4, 0, 4, 0, 0, 1, 1]\n  [0, 5, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0, 8, 8, 0, 7, 7, 9, 9, 9, 9, 0, 4, 4, 0, 0, 0, 1, 0, 0]\n  [5, 0, 0, 0, 0, 1, 0, 0, 4, 4, 0, 3, 8, 8, 7, 7, 7, 9, 9, 9, 9, 0, 4, 4, 0, 0, 1, 0, 0, 0]\n  [0, 0, 4, 4, 0, 0, 1, 0, 0, 0, 8, 8, 0, 7, 0, 5, 5, 9, 9, 9, 9, 8, 0, 0, 0, 1, 0, 0, 4, 4]\n  [9, 9, 9, 0, 0, 0, 0, 1, 0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 7, 7, 0, 8, 3, 0, 1, 0, 0, 0, 0, 4]\n  [9, 9, 9, 4, 4, 4, 0, 0, 2, 2, 1, 0, 4, 0, 5, 0, 0, 5, 0, 4, 0, 1, 2, 2, 0, 0, 4, 4, 4, 0]\n  [9, 9, 9, 4, 4, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 3, 0, 4, 4, 4, 4]\n  [9, 9, 9, 0, 0, 0, 8, 8, 1, 0, 3, 0, 5, 0, 0, 6, 6, 0, 0, 5, 0, 3, 0, 1, 8, 8, 0, 0, 0, 2]\n  [9, 9, 9, 0, 0, 3, 8, 0, 0, 0, 0, 3, 0, 5, 6, 0, 0, 6, 5, 0, 3, 0, 0, 0, 0, 8, 3, 0, 0, 0]\n  [9, 9, 9, 0, 8, 8, 0, 7, 4, 0, 5, 0, 0, 6, 7, 0, 0, 7, 6, 0, 0, 5, 0, 4, 7, 0, 8, 8, 0, 0]\n  [9, 9, 9, 3, 8, 8, 7, 7, 0, 0, 0, 5, 6, 6, 0, 7, 7, 0, 6, 6, 5, 0, 0, 0, 7, 7, 8, 8, 3, 0]\n  [0, 0, 8, 8, 0, 7, 0, 5, 5, 0, 0, 6, 7, 0, 2, 0, 0, 2, 0, 7, 6, 0, 0, 5, 5, 0, 7, 0, 8, 8]\n  [0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 6, 0, 0, 7, 0, 2, 2, 0, 7, 0, 0, 6, 5, 0, 0, 5, 7, 7, 0, 8]\n  [0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 6, 0, 0, 7, 0, 2, 2, 0, 7, 0, 0, 6, 5, 0, 0, 5, 7, 7, 0, 8]\n  [0, 0, 8, 8, 0, 7, 0, 5, 5, 0, 0, 6, 7, 0, 2, 0, 0, 2, 0, 7, 6, 0, 0, 5, 5, 0, 7, 0, 8, 8]\n  [4, 4, 0, 3, 8, 8, 7, 7, 0, 0, 0, 5, 6, 6, 0, 7, 7, 0, 6, 6, 5, 0, 0, 0, 7, 7, 8, 8, 3, 0]\n  [4, 4, 0, 0, 8, 8, 0, 7, 4, 0, 5, 0, 0, 6, 7, 0, 0, 7, 6, 0, 0, 5, 0, 4, 7, 0, 8, 8, 0, 0]\n  [4, 4, 0, 0, 0, 3, 8, 0, 0, 0, 0, 3, 0, 5, 6, 0, 0, 6, 5, 0, 3, 0, 0, 0, 0, 8, 3, 0, 0, 0]\n  [0, 4, 2, 0, 0, 0, 8, 8, 1, 0, 3, 0, 5, 0, 0, 6, 6, 0, 0, 5, 0, 3, 0, 1, 8, 8, 0, 0, 0, 2]\n  [8, 0, 4, 4, 4, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 3, 0, 4, 4, 4, 4]\n  [8, 8, 0, 4, 4, 4, 0, 0, 2, 2, 1, 0, 4, 0, 5, 0, 0, 5, 0, 4, 0, 1, 2, 2, 0, 0, 4, 4, 4, 0]\n  [0, 0, 4, 0, 0, 0, 0, 1, 0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 7, 7, 0, 8, 3, 0, 1, 0, 0, 0, 0, 4]\n  [0, 0, 4, 4, 0, 0, 1, 0, 0, 0, 8, 8, 0, 7, 0, 5, 5, 0, 7, 0, 8, 8, 0, 0, 0, 1, 0, 0, 4, 4]\n  [5, 0, 0, 0, 0, 1, 0, 0, 4, 4, 0, 3, 8, 8, 7, 7, 7, 7, 8, 8, 3, 0, 4, 4, 0, 0, 1, 0, 0, 0]\n  [0, 5, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 0, 0]\n  [0, 0, 1, 1, 0, 0, 4, 0, 4, 4, 0, 0, 0, 3, 8, 0, 0, 8, 3, 0, 0, 0, 4, 4, 0, 4, 0, 0, 1, 1]\n  [0, 0, 0, 1, 0, 0, 4, 4, 0, 4, 2, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 2, 4, 0, 4, 4, 0, 0, 1, 0]\n]\n\nOutput Grid:\n[\n  [0, 5, 0, 0, 0, 5, 0, 0, 8, 8, 0, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 0, 8, 8, 0, 0, 5, 0, 0, 0]\n  [5, 0, 0, 0, 5, 0, 0, 0, 8, 0, 4, 4, 4, 4, 0, 3, 3, 0, 4, 4, 4, 4, 0, 8, 0, 0, 0, 5, 0, 0]\n  [0, 0, 0, 1, 0, 0, 4, 4, 0, 4, 2, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 2, 4, 0, 4, 4, 0, 0, 1, 0]\n  [0, 0, 1, 1, 0, 0, 4, 0, 4, 4, 0, 0, 0, 3, 8, 0, 0, 8, 3, 0, 0, 0, 4, 4, 0, 4, 0, 0, 1, 1]\n  [0, 5, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 0, 0]\n  [5, 0, 0, 0, 0, 1, 0, 0, 4, 4, 0, 3, 8, 8, 7, 7, 7, 7, 8, 8, 3, 0, 4, 4, 0, 0, 1, 0, 0, 0]\n  [0, 0, 4, 4, 0, 0, 1, 0, 0, 0, 8, 8, 0, 7, 0, 5, 5, 0, 7, 0, 8, 8, 0, 0, 0, 1, 0, 0, 4, 4]\n  [0, 0, 4, 0, 0, 0, 0, 1, 0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 7, 7, 0, 8, 3, 0, 1, 0, 0, 0, 0, 4]\n  [8, 8, 0, 4, 4, 4, 0, 0, 2, 2, 1, 0, 4, 0, 5, 0, 0, 5, 0, 4, 0, 1, 2, 2, 0, 0, 4, 4, 4, 0]\n  [8, 0, 4, 4, 4, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 3, 0, 4, 4, 4, 4]\n  [0, 4, 2, 0, 0, 0, 8, 8, 1, 0, 3, 0, 5, 0, 0, 6, 6, 0, 0, 5, 0, 3, 0, 1, 8, 8, 0, 0, 0, 2]\n  [4, 4, 0, 0, 0, 3, 8, 0, 0, 0, 0, 3, 0, 5, 6, 0, 0, 6, 5, 0, 3, 0, 0, 0, 0, 8, 3, 0, 0, 0]\n  [4, 4, 0, 0, 8, 8, 0, 7, 4, 0, 5, 0, 0, 6, 7, 0, 0, 7, 6, 0, 0, 5, 0, 4, 7, 0, 8, 8, 0, 0]\n  [4, 4, 0, 3, 8, 8, 7, 7, 0, 0, 0, 5, 6, 6, 0, 7, 7, 0, 6, 6, 5, 0, 0, 0, 7, 7, 8, 8, 3, 0]\n  [0, 0, 8, 8, 0, 7, 0, 5, 5, 0, 0, 6, 7, 0, 2, 0, 0, 2, 0, 7, 6, 0, 0, 5, 5, 0, 7, 0, 8, 8]\n  [0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 6, 0, 0, 7, 0, 2, 2, 0, 7, 0, 0, 6, 5, 0, 0, 5, 7, 7, 0, 8]\n  [0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 6, 0, 0, 7, 0, 2, 2, 0, 7, 0, 0, 6, 5, 0, 0, 5, 7, 7, 0, 8]\n  [0, 0, 8, 8, 0, 7, 0, 5, 5, 0, 0, 6, 7, 0, 2, 0, 0, 2, 0, 7, 6, 0, 0, 5, 5, 0, 7, 0, 8, 8]\n  [4, 4, 0, 3, 8, 8, 7, 7, 0, 0, 0, 5, 6, 6, 0, 7, 7, 0, 6, 6, 5, 0, 0, 0, 7, 7, 8, 8, 3, 0]\n  [4, 4, 0, 0, 8, 8, 0, 7, 4, 0, 5, 0, 0, 6, 7, 0, 0, 7, 6, 0, 0, 5, 0, 4, 7, 0, 8, 8, 0, 0]\n  [4, 4, 0, 0, 0, 3, 8, 0, 0, 0, 0, 3, 0, 5, 6, 0, 0, 6, 5, 0, 3, 0, 0, 0, 0, 8, 3, 0, 0, 0]\n  [0, 4, 2, 0, 0, 0, 8, 8, 1, 0, 3, 0, 5, 0, 0, 6, 6, 0, 0, 5, 0, 3, 0, 1, 8, 8, 0, 0, 0, 2]\n  [8, 0, 4, 4, 4, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 3, 0, 4, 4, 4, 4]\n  [8, 8, 0, 4, 4, 4, 0, 0, 2, 2, 1, 0, 4, 0, 5, 0, 0, 5, 0, 4, 0, 1, 2, 2, 0, 0, 4, 4, 4, 0]\n  [0, 0, 4, 0, 0, 0, 0, 1, 0, 3, 8, 0, 7, 7, 5, 0, 0, 5, 7, 7, 0, 8, 3, 0, 1, 0, 0, 0, 0, 4]\n  [0, 0, 4, 4, 0, 0, 1, 0, 0, 0, 8, 8, 0, 7, 0, 5, 5, 0, 7, 0, 8, 8, 0, 0, 0, 1, 0, 0, 4, 4]\n  [5, 0, 0, 0, 0, 1, 0, 0, 4, 4, 0, 3, 8, 8, 7, 7, 7, 7, 8, 8, 3, 0, 4, 4, 0, 0, 1, 0, 0, 0]\n  [0, 5, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 0, 0]\n  [0, 0, 1, 1, 0, 0, 4, 0, 4, 4, 0, 0, 0, 3, 8, 0, 0, 8, 3, 0, 0, 0, 4, 4, 0, 4, 0, 0, 1, 1]\n  [0, 0, 0, 1, 0, 0, 4, 4, 0, 4, 2, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 2, 4, 0, 4, 4, 0, 0, 1, 0]\n]\nExample 4:\nInput Grid:\n[\n  [0, 0, 0, 1, 7, 0, 6, 0, 0, 0, 0, 6, 3, 3, 0, 2, 2, 0, 3, 3, 6, 0, 0, 0, 0, 6, 0, 7, 1, 0]\n  [0, 7, 1, 0, 0, 7, 0, 0, 0, 4, 6, 6, 3, 0, 2, 0, 0, 2, 0, 3, 6, 6, 4, 0, 0, 0, 7, 0, 0, 1]\n  [0, 1, 5, 0, 6, 0, 0, 0, 0, 6, 3, 3, 0, 2, 7, 7, 7, 7, 2, 0, 3, 3, 6, 0, 0, 0, 0, 6, 0, 5]\n  [1, 0, 0, 5, 0, 0, 0, 0, 6, 6, 3, 3, 2, 0, 7, 0, 0, 7, 0, 2, 3, 3, 6, 6, 0, 0, 0, 0, 5, 0]\n  [7, 0, 6, 0, 8, 8, 6, 0, 3, 9, 9, 9, 4, 4, 1, 0, 0, 1, 4, 4, 2, 0, 3, 3, 0, 6, 8, 8, 0, 6]\n  [0, 7, 0, 0, 8, 0, 0, 0, 3, 9, 9, 9, 4, 4, 0, 0, 0, 0, 4, 4, 0, 2, 0, 3, 0, 0, 0, 8, 0, 0]\n  [6, 0, 0, 0, 6, 0, 2, 0, 0, 9, 9, 9, 1, 0, 0, 0, 0, 0, 0, 1, 7, 7, 2, 0, 0, 2, 0, 6, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 7, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 0, 2, 2, 0, 0, 9, 9, 9]\n  [0, 0, 0, 6, 3, 3, 0, 2, 0, 8, 1, 1, 7, 7, 0, 2, 2, 0, 7, 7, 1, 1, 8, 0, 2, 0, 3, 9, 9, 9]\n  [0, 4, 6, 6, 3, 0, 2, 0, 8, 8, 1, 1, 7, 0, 2, 2, 2, 2, 0, 7, 1, 1, 8, 8, 0, 2, 0, 9, 9, 9]\n  [0, 6, 3, 3, 0, 2, 7, 7, 1, 1, 0, 0, 0, 2, 4, 4, 4, 4, 2, 0, 0, 0, 1, 1, 7, 7, 2, 9, 9, 9]\n  [6, 6, 3, 3, 2, 9, 9, 9, 9, 9, 9, 9, 9, 2, 4, 0, 0, 4, 2, 2, 0, 0, 1, 1, 0, 7, 0, 2, 3, 3]\n  [3, 3, 0, 2, 4, 9, 9, 9, 9, 9, 9, 9, 9, 2, 0, 2, 2, 0, 2, 0, 2, 0, 7, 7, 0, 1, 4, 4, 2, 0]\n  [3, 0, 2, 0, 4, 9, 9, 9, 9, 9, 9, 9, 9, 0, 2, 2, 2, 2, 0, 2, 2, 2, 0, 7, 0, 0, 4, 4, 0, 2]\n  [0, 2, 7, 7, 1, 9, 9, 9, 9, 9, 9, 9, 9, 2, 6, 6, 6, 6, 2, 0, 4, 4, 2, 0, 0, 0, 0, 1, 7, 7]\n  [2, 0, 7, 0, 0, 9, 9, 9, 2, 2, 4, 0, 2, 2, 6, 0, 0, 6, 2, 2, 0, 4, 2, 2, 4, 0, 0, 0, 0, 7]\n  [2, 0, 7, 0, 0, 9, 9, 9, 2, 2, 4, 0, 2, 2, 6, 0, 0, 6, 2, 2, 0, 4, 2, 2, 4, 0, 0, 0, 0, 7]\n  [0, 2, 7, 7, 1, 9, 9, 9, 0, 2, 4, 4, 0, 2, 6, 6, 6, 6, 2, 0, 4, 4, 2, 0, 0, 0, 0, 1, 7, 7]\n  [3, 0, 2, 0, 4, 4, 0, 0, 7, 0, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 0, 7, 0, 0, 4, 4, 0, 2]\n  [3, 3, 0, 2, 4, 4, 1, 0, 7, 7, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 0, 7, 7, 0, 1, 4, 4, 2, 0]\n  [6, 6, 3, 3, 2, 0, 7, 0, 1, 1, 0, 0, 2, 2, 4, 0, 0, 4, 2, 2, 0, 0, 1, 1, 0, 7, 0, 2, 3, 3]\n  [0, 6, 3, 3, 0, 2, 7, 7, 1, 1, 0, 0, 0, 2, 4, 4, 4, 4, 2, 0, 0, 0, 1, 1, 7, 7, 2, 0, 3, 3]\n  [0, 4, 6, 6, 3, 0, 2, 0, 8, 8, 1, 1, 7, 0, 2, 2, 2, 2, 0, 7, 1, 1, 8, 8, 0, 2, 0, 3, 6, 6]\n  [0, 0, 0, 6, 3, 3, 0, 2, 0, 9, 9, 1, 7, 7, 0, 2, 2, 0, 7, 7, 1, 1, 8, 0, 2, 0, 3, 3, 6, 0]\n  [0, 0, 0, 0, 0, 0, 0, 2, 2, 9, 9, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 0, 2, 2, 0, 0, 0, 0, 0]\n  [6, 0, 0, 0, 6, 0, 2, 0, 0, 9, 9, 7, 1, 0, 0, 0, 0, 0, 0, 1, 7, 7, 2, 0, 0, 2, 0, 6, 0, 0]\n  [0, 7, 0, 0, 8, 0, 0, 0, 3, 9, 9, 0, 4, 4, 0, 0, 0, 0, 4, 4, 0, 2, 0, 3, 0, 0, 0, 8, 0, 0]\n  [7, 0, 6, 0, 8, 8, 6, 0, 3, 9, 9, 2, 4, 4, 1, 0, 0, 1, 4, 4, 2, 0, 3, 3, 0, 6, 8, 8, 0, 6]\n  [1, 0, 0, 5, 0, 0, 0, 0, 6, 9, 9, 3, 2, 0, 7, 0, 0, 7, 0, 2, 3, 3, 6, 6, 0, 0, 0, 0, 5, 0]\n  [0, 1, 5, 0, 6, 0, 0, 0, 0, 9, 9, 3, 0, 2, 7, 7, 7, 7, 2, 0, 3, 3, 6, 0, 0, 0, 0, 6, 0, 5]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 1, 7, 0, 6, 0, 0, 0, 0, 6, 3, 3, 0, 2, 2, 0, 3, 3, 6, 0, 0, 0, 0, 6, 0, 7, 1, 0]\n  [0, 7, 1, 0, 0, 7, 0, 0, 0, 4, 6, 6, 3, 0, 2, 0, 0, 2, 0, 3, 6, 6, 4, 0, 0, 0, 7, 0, 0, 1]\n  [0, 1, 5, 0, 6, 0, 0, 0, 0, 6, 3, 3, 0, 2, 7, 7, 7, 7, 2, 0, 3, 3, 6, 0, 0, 0, 0, 6, 0, 5]\n  [1, 0, 0, 5, 0, 0, 0, 0, 6, 6, 3, 3, 2, 0, 7, 0, 0, 7, 0, 2, 3, 3, 6, 6, 0, 0, 0, 0, 5, 0]\n  [7, 0, 6, 0, 8, 8, 6, 0, 3, 3, 0, 2, 4, 4, 1, 0, 0, 1, 4, 4, 2, 0, 3, 3, 0, 6, 8, 8, 0, 6]\n  [0, 7, 0, 0, 8, 0, 0, 0, 3, 0, 2, 0, 4, 4, 0, 0, 0, 0, 4, 4, 0, 2, 0, 3, 0, 0, 0, 8, 0, 0]\n  [6, 0, 0, 0, 6, 0, 2, 0, 0, 2, 7, 7, 1, 0, 0, 0, 0, 0, 0, 1, 7, 7, 2, 0, 0, 2, 0, 6, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 7, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 0, 2, 2, 0, 0, 0, 0, 0]\n  [0, 0, 0, 6, 3, 3, 0, 2, 0, 8, 1, 1, 7, 7, 0, 2, 2, 0, 7, 7, 1, 1, 8, 0, 2, 0, 3, 3, 6, 0]\n  [0, 4, 6, 6, 3, 0, 2, 0, 8, 8, 1, 1, 7, 0, 2, 2, 2, 2, 0, 7, 1, 1, 8, 8, 0, 2, 0, 3, 6, 6]\n  [0, 6, 3, 3, 0, 2, 7, 7, 1, 1, 0, 0, 0, 2, 4, 4, 4, 4, 2, 0, 0, 0, 1, 1, 7, 7, 2, 0, 3, 3]\n  [6, 6, 3, 3, 2, 0, 7, 0, 1, 1, 0, 0, 2, 2, 4, 0, 0, 4, 2, 2, 0, 0, 1, 1, 0, 7, 0, 2, 3, 3]\n  [3, 3, 0, 2, 4, 4, 1, 0, 7, 7, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 0, 7, 7, 0, 1, 4, 4, 2, 0]\n  [3, 0, 2, 0, 4, 4, 0, 0, 7, 0, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 0, 7, 0, 0, 4, 4, 0, 2]\n  [0, 2, 7, 7, 1, 0, 0, 0, 0, 2, 4, 4, 0, 2, 6, 6, 6, 6, 2, 0, 4, 4, 2, 0, 0, 0, 0, 1, 7, 7]\n  [2, 0, 7, 0, 0, 0, 0, 4, 2, 2, 4, 0, 2, 2, 6, 0, 0, 6, 2, 2, 0, 4, 2, 2, 4, 0, 0, 0, 0, 7]\n  [2, 0, 7, 0, 0, 0, 0, 4, 2, 2, 4, 0, 2, 2, 6, 0, 0, 6, 2, 2, 0, 4, 2, 2, 4, 0, 0, 0, 0, 7]\n  [0, 2, 7, 7, 1, 0, 0, 0, 0, 2, 4, 4, 0, 2, 6, 6, 6, 6, 2, 0, 4, 4, 2, 0, 0, 0, 0, 1, 7, 7]\n  [3, 0, 2, 0, 4, 4, 0, 0, 7, 0, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 0, 7, 0, 0, 4, 4, 0, 2]\n  [3, 3, 0, 2, 4, 4, 1, 0, 7, 7, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 0, 7, 7, 0, 1, 4, 4, 2, 0]\n  [6, 6, 3, 3, 2, 0, 7, 0, 1, 1, 0, 0, 2, 2, 4, 0, 0, 4, 2, 2, 0, 0, 1, 1, 0, 7, 0, 2, 3, 3]\n  [0, 6, 3, 3, 0, 2, 7, 7, 1, 1, 0, 0, 0, 2, 4, 4, 4, 4, 2, 0, 0, 0, 1, 1, 7, 7, 2, 0, 3, 3]\n  [0, 4, 6, 6, 3, 0, 2, 0, 8, 8, 1, 1, 7, 0, 2, 2, 2, 2, 0, 7, 1, 1, 8, 8, 0, 2, 0, 3, 6, 6]\n  [0, 0, 0, 6, 3, 3, 0, 2, 0, 8, 1, 1, 7, 7, 0, 2, 2, 0, 7, 7, 1, 1, 8, 0, 2, 0, 3, 3, 6, 0]\n  [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 7, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 0, 2, 2, 0, 0, 0, 0, 0]\n  [6, 0, 0, 0, 6, 0, 2, 0, 0, 2, 7, 7, 1, 0, 0, 0, 0, 0, 0, 1, 7, 7, 2, 0, 0, 2, 0, 6, 0, 0]\n  [0, 7, 0, 0, 8, 0, 0, 0, 3, 0, 2, 0, 4, 4, 0, 0, 0, 0, 4, 4, 0, 2, 0, 3, 0, 0, 0, 8, 0, 0]\n  [7, 0, 6, 0, 8, 8, 6, 0, 3, 3, 0, 2, 4, 4, 1, 0, 0, 1, 4, 4, 2, 0, 3, 3, 0, 6, 8, 8, 0, 6]\n  [1, 0, 0, 5, 0, 0, 0, 0, 6, 6, 3, 3, 2, 0, 7, 0, 0, 7, 0, 2, 3, 3, 6, 6, 0, 0, 0, 0, 5, 0]\n  [0, 1, 5, 0, 6, 0, 0, 0, 0, 6, 3, 3, 0, 2, 7, 7, 7, 7, 2, 0, 3, 3, 6, 0, 0, 0, 0, 6, 0, 5]\n]\n\n=== TEST INPUT ===\n[\n  [8, 0, 7, 0, 7, 7, 1, 1, 0, 3, 0, 6, 0, 8, 0, 0, 0, 0, 8, 0, 6, 0, 3, 0, 1, 1, 7, 7, 0, 7]\n  [0, 8, 0, 0, 7, 7, 1, 1, 3, 3, 6, 6, 8, 8, 0, 0, 0, 0, 8, 8, 6, 6, 3, 3, 1, 1, 7, 7, 0, 0]\n  [9, 9, 9, 9, 9, 9, 9, 8, 0, 6, 7, 7, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 6, 0, 8, 0, 1, 1, 0, 2]\n  [9, 9, 9, 9, 9, 9, 9, 0, 6, 6, 7, 7, 0, 0, 6, 0, 0, 6, 0, 0, 9, 9, 9, 9, 9, 8, 1, 1, 0, 0]\n  [9, 9, 9, 9, 9, 9, 9, 6, 0, 8, 0, 0, 6, 6, 0, 0, 0, 0, 6, 6, 9, 9, 9, 9, 9, 0, 0, 0, 1, 1]\n  [7, 7, 1, 1, 0, 5, 6, 6, 8, 8, 0, 0, 6, 6, 0, 0, 0, 0, 6, 6, 9, 9, 9, 9, 9, 6, 5, 0, 1, 1]\n  [1, 1, 0, 8, 0, 6, 2, 0, 0, 0, 0, 6, 0, 0, 5, 5, 5, 5, 0, 0, 9, 9, 9, 9, 9, 2, 6, 0, 8, 0]\n  [1, 1, 8, 0, 6, 6, 0, 2, 0, 0, 6, 0, 0, 0, 5, 0, 0, 5, 0, 0, 9, 9, 9, 9, 9, 9, 9, 6, 0, 8]\n  [0, 3, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0, 0, 3, 0, 6, 0, 0, 9, 9, 9, 9, 9, 0, 6, 0]\n  [3, 3, 6, 6, 8, 8, 0, 0, 0, 6, 0, 5, 0, 0, 0, 3, 3, 0, 0, 0, 5, 0, 9, 9, 9, 9, 9, 8, 6, 6]\n  [0, 6, 7, 7, 0, 0, 0, 6, 0, 0, 0, 0, 3, 0, 0, 6, 6, 0, 0, 3, 0, 0, 9, 9, 9, 9, 9, 0, 7, 7]\n  [6, 6, 7, 7, 0, 0, 6, 0, 0, 5, 0, 0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 9, 9, 9, 9, 9, 0, 7, 7]\n  [0, 8, 0, 0, 6, 6, 0, 0, 6, 0, 3, 0, 0, 4, 3, 0, 0, 3, 4, 0, 0, 3, 0, 6, 0, 0, 6, 6, 0, 0]\n  [8, 8, 0, 0, 6, 6, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 6, 6, 0, 0]\n  [0, 0, 0, 6, 0, 0, 5, 5, 3, 0, 0, 6, 3, 0, 2, 0, 0, 2, 0, 3, 6, 0, 0, 3, 5, 5, 0, 0, 6, 0]\n  [0, 0, 6, 0, 0, 0, 5, 0, 0, 3, 6, 6, 0, 0, 0, 2, 2, 0, 0, 0, 6, 6, 3, 0, 0, 5, 0, 0, 0, 6]\n  [0, 0, 6, 0, 0, 0, 5, 0, 0, 3, 6, 6, 0, 0, 0, 2, 2, 0, 0, 0, 6, 6, 3, 0, 0, 5, 0, 0, 0, 6]\n  [0, 0, 0, 6, 0, 0, 5, 5, 3, 0, 0, 6, 3, 0, 2, 0, 0, 2, 0, 3, 6, 0, 0, 3, 5, 5, 0, 0, 6, 0]\n  [8, 8, 0, 0, 6, 6, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 6, 6, 0, 0]\n  [0, 8, 0, 0, 6, 6, 0, 0, 6, 0, 3, 0, 0, 4, 3, 0, 0, 3, 4, 0, 0, 3, 0, 6, 0, 0, 6, 6, 0, 0]\n  [6, 6, 7, 7, 0, 0, 6, 0, 0, 5, 0, 0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 5, 0, 0, 6, 0, 0, 7, 7]\n  [0, 6, 7, 7, 0, 0, 0, 6, 0, 0, 0, 0, 3, 0, 0, 6, 6, 0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 7, 7]\n  [3, 3, 6, 6, 8, 8, 0, 0, 0, 6, 0, 5, 0, 0, 0, 3, 3, 0, 0, 0, 5, 0, 6, 0, 0, 0, 8, 8, 6, 6]\n  [0, 3, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 8, 0, 6, 0]\n  [1, 1, 8, 0, 6, 6, 0, 2, 0, 0, 6, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 6, 0, 0, 2, 0, 6, 6, 0, 8]\n  [1, 1, 0, 8, 0, 6, 2, 0, 0, 0, 0, 6, 0, 0, 5, 5, 5, 5, 0, 0, 6, 0, 0, 0, 0, 2, 6, 0, 8, 0]\n  [7, 7, 1, 1, 0, 5, 6, 6, 8, 8, 0, 0, 6, 6, 0, 0, 0, 0, 6, 6, 0, 0, 8, 8, 6, 6, 5, 0, 1, 1]\n  [7, 7, 1, 1, 0, 0, 0, 6, 0, 8, 0, 0, 6, 6, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 1, 1]\n  [0, 0, 0, 0, 1, 1, 8, 0, 6, 6, 7, 7, 0, 0, 6, 0, 0, 6, 9, 9, 9, 9, 9, 9, 9, 8, 1, 1, 0, 0]\n  [7, 0, 2, 0, 1, 1, 0, 8, 0, 6, 7, 7, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 6, 0, 8, 0, 1, 1, 0, 2]\n]\n\nTransform the test input according to the pattern shown in the training examples.",
    "answer": "[[8,0,7,0,7,7,1,1,0,3,0,6,0,8,0,0,0,0,8,0,6,0,3,0,1,1,7,7,0,7],[0,8,0,0,7,7,1,1,3,3,6,6,8,8,0,0,0,0,8,8,6,6,3,3,1,1,7,7,0,0],[7,0,2,0,1,1,0,8,0,6,7,7,0,0,0,6,6,0,0,0,7,7,6,0,8,0,1,1,0,2],[0,0,0,0,1,1,8,0,6,6,7,7,0,0,6,0,0,6,0,0,7,7,6,6,0,8,1,1,0,0],[7,7,1,1,0,0,0,6,0,8,0,0,6,6,0,0,0,0,6,6,0,0,8,0,6,0,0,0,1,1],[7,7,1,1,0,5,6,6,8,8,0,0,6,6,0,0,0,0,6,6,0,0,8,8,6,6,5,0,1,1],[1,1,0,8,0,6,2,0,0,0,0,6,0,0,5,5,5,5,0,0,6,0,0,0,0,2,6,0,8,0],[1,1,8,0,6,6,0,2,0,0,6,0,0,0,5,0,0,5,0,0,0,6,0,0,2,0,6,6,0,8],[0,3,0,6,0,8,0,0,0,0,0,0,6,0,3,0,0,3,0,6,0,0,0,0,0,0,8,0,6,0],[3,3,6,6,8,8,0,0,0,6,0,5,0,0,0,3,3,0,0,0,5,0,6,0,0,0,8,8,6,6],[0,6,7,7,0,0,0,6,0,0,0,0,3,0,0,6,6,0,0,3,0,0,0,0,6,0,0,0,7,7],[6,6,7,7,0,0,6,0,0,5,0,0,0,3,6,6,6,6,3,0,0,0,5,0,0,6,0,0,7,7],[0,8,0,0,6,6,0,0,6,0,3,0,0,4,3,0,0,3,4,0,0,3,0,6,0,0,6,6,0,0],[8,8,0,0,6,6,0,0,0,0,0,3,4,0,0,0,0,0,0,4,3,0,0,0,0,0,6,6,0,0],[0,0,0,6,0,0,5,5,3,0,0,6,3,0,2,0,0,2,0,3,6,0,0,3,5,5,0,0,6,0],[0,0,6,0,0,0,5,0,0,3,6,6,0,0,0,2,2,0,0,0,6,6,3,0,0,5,0,0,0,6],[0,0,6,0,0,0,5,0,0,3,6,6,0,0,0,2,2,0,0,0,6,6,3,0,0,5,0,0,0,6],[0,0,0,6,0,0,5,5,3,0,0,6,3,0,2,0,0,2,0,3,6,0,0,3,5,5,0,0,6,0],[8,8,0,0,6,6,0,0,0,0,0,3,4,0,0,0,0,0,0,4,3,0,0,0,0,0,6,6,0,0],[0,8,0,0,6,6,0,0,6,0,3,0,0,4,3,0,0,3,4,0,0,3,0,6,0,0,6,6,0,0],[6,6,7,7,0,0,6,0,0,5,0,0,0,3,6,6,6,6,3,0,0,0,5,0,0,6,0,0,7,7],[0,6,7,7,0,0,0,6,0,0,0,0,3,0,0,6,6,0,0,3,0,0,0,0,6,0,0,0,7,7],[3,3,6,6,8,8,0,0,0,6,0,5,0,0,0,3,3,0,0,0,5,0,6,0,0,0,8,8,6,6],[0,3,0,6,0,8,0,0,0,0,0,0,6,0,3,0,0,3,0,6,0,0,0,0,0,0,8,0,6,0],[1,1,8,0,6,6,0,2,0,0,6,0,0,0,5,0,0,5,0,0,0,6,0,0,2,0,6,6,0,8],[1,1,0,8,0,6,2,0,0,0,0,6,0,0,5,5,5,5,0,0,6,0,0,0,0,2,6,0,8,0],[7,7,1,1,0,5,6,6,8,8,0,0,6,6,0,0,0,0,6,6,0,0,8,8,6,6,5,0,1,1],[7,7,1,1,0,0,0,6,0,8,0,0,6,6,0,0,0,0,6,6,0,0,8,0,6,0,0,0,1,1],[0,0,0,0,1,1,8,0,6,6,7,7,0,0,6,0,0,6,0,0,7,7,6,6,0,8,1,1,0,0],[7,0,2,0,1,1,0,8,0,6,7,7,0,0,0,6,6,0,0,0,7,7,6,0,8,0,1,1,0,2]]"
  },
  {
    "id": 1,
    "question": "=== TRAINING EXAMPLES ===\n\nExample 1:\nInput Grid:\n[\n  [4, 2, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [2, 6, 2, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n  [6, 4, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [4, 2, 2, 5, 4, 2, 2, 0, 0, 0, 0, 0, 0]\n  [2, 6, 2, 5, 2, 6, 2, 0, 0, 0, 0, 0, 0]\n  [6, 4, 4, 5, 6, 4, 4, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 4, 2, 2, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 2, 6, 2, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 6, 4, 4, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 4, 2, 2, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 2, 6, 2, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 6, 4, 4, 0, 0, 0]\n]\nExample 2:\nInput Grid:\n[\n  [2, 7, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [2, 3, 3, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n  [3, 7, 7, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 1, 0, 0, 1, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [2, 7, 3, 5, 0, 0, 0, 2, 7, 3, 0, 0, 0]\n  [2, 3, 3, 5, 0, 0, 0, 2, 3, 3, 0, 0, 0]\n  [3, 7, 7, 5, 0, 0, 0, 3, 7, 7, 0, 0, 0]\n  [0, 0, 0, 5, 2, 7, 3, 0, 0, 0, 2, 7, 3]\n  [0, 0, 0, 5, 2, 3, 3, 0, 0, 0, 2, 3, 3]\n  [0, 0, 0, 5, 3, 7, 7, 0, 0, 0, 3, 7, 7]\n  [0, 0, 0, 5, 2, 7, 3, 2, 7, 3, 0, 0, 0]\n  [0, 0, 0, 5, 2, 3, 3, 2, 3, 3, 0, 0, 0]\n  [0, 0, 0, 5, 3, 7, 7, 3, 7, 7, 0, 0, 0]\n]\nExample 3:\nInput Grid:\n[\n  [3, 8, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [9, 8, 2, 5, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n  [9, 9, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 1, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [3, 8, 6, 5, 3, 8, 6, 0, 0, 0, 3, 8, 6]\n  [9, 8, 2, 5, 9, 8, 2, 0, 0, 0, 9, 8, 2]\n  [9, 9, 9, 5, 9, 9, 9, 0, 0, 0, 9, 9, 9]\n  [0, 0, 0, 5, 0, 0, 0, 3, 8, 6, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 9, 8, 2, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 9, 9, 9, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 3, 8, 6, 3, 8, 6]\n  [0, 0, 0, 5, 0, 0, 0, 9, 8, 2, 9, 8, 2]\n  [0, 0, 0, 5, 0, 0, 0, 9, 9, 9, 9, 9, 9]\n]\n\n=== TEST INPUT ===\n[\n  [3, 3, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [8, 4, 4, 5, 0, 0, 0, 0, 1, 0, 0, 1, 0]\n  [8, 9, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 1, 0, 0, 1, 0, 0, 0, 0]\n  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nTransform the test input according to the pattern shown in the training examples.",
    "answer": "[[3,3,9,5,0,0,0,3,3,9,3,3,9],[8,4,4,5,0,0,0,8,4,4,8,4,4],[8,9,8,5,0,0,0,8,9,8,8,9,8],[0,0,0,5,3,3,9,0,0,0,3,3,9],[0,0,0,5,8,4,4,0,0,0,8,4,4],[0,0,0,5,8,9,8,0,0,0,8,9,8],[0,0,0,5,3,3,9,3,3,9,0,0,0],[0,0,0,5,8,4,4,8,4,4,0,0,0],[0,0,0,5,8,9,8,8,9,8,0,0,0]]"
  },
  {
    "id": 2,
    "question": "=== TRAINING EXAMPLES ===\n\nExample 1:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 1, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0]\n  [0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 4, 0, 0]\n  [0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 4, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0]\n  [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 1, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0]\n  [0, 4, 4, 4, 4, 4, 0, 0, 0, 3, 4, 0, 0]\n  [0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 4, 1, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 2, 0]\n  [0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0]\n  [0, 0, 0, 2, 1, 0, 1, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\nExample 2:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 3, 4, 3, 0, 0, 0, 2, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 3, 4, 3, 0, 0, 0, 2, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 4, 4, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 3, 3, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n]\nExample 3:\nInput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 1, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nOutput Grid:\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 1, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 1, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 4, 3, 0, 0, 0]\n  [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0]\n  [0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n=== TEST INPUT ===\n[\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 4, 4, 2, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0]\n  [0, 0, 4, 0, 4, 3, 0, 0, 0, 0, 4, 0, 4, 0, 0]\n  [0, 0, 0, 4, 4, 1, 0, 0, 0, 0, 4, 4, 2, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 4, 4, 0, 0, 0, 0, 0, 2, 4, 4, 0, 0, 0, 0]\n  [0, 4, 0, 4, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0]\n  [0, 2, 4, 4, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nTransform the test input according to the pattern shown in the training examples.",
    "answer": "[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,3,0,0,0,0,0,0,0,0,0,0,0],[0,0,4,4,2,0,0,0,0,0,0,4,4,1,0],[0,0,4,0,4,3,0,0,0,0,4,0,4,3,0],[0,0,0,4,4,1,0,0,0,0,4,4,2,0,0],[0,0,0,0,0,0,0,0,0,0,1,3,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,3,1,0,0,0,0],[1,4,4,0,0,0,0,0,2,4,4,0,0,0,0],[3,4,0,4,0,0,0,3,4,0,4,0,0,0,0],[0,2,4,4,0,0,0,1,4,4,0,0,0,0,0],[0,0,3,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]"
  }
]

            HISTORICAL CONTEXT:
            
        ITERATION HISTORY SUMMARY:
        - Total iterations completed: 23
        - Current explore/exploit balance: 80/20
        - Best accuracy achieved: 0.67 (iteration 9)

        APPROACH HISTORY (last 10 iterations):
        [
  {
    "iteration": 13,
    "strategy": "Exploration",
    "accuracy": 0.0,
    "approach": "The script addresses grid transformation problems by employing two LLM-driven agents: a Minimal Change Identifier and a Pattern Interpolator. First, `identify_minimal_change_regions` identifies stable regions in the grid. Then, `interpolate_transformation_pattern` infers the transformation logic based on these regions. The script extracts the test input, applies the transformation using `apply_transformation`, and verifies the result using `verify_transformation` to ensure the output is correct based on the question. The overall workflow involves identifying minimal changes, interpolating the transformation pattern, applying it to the input grid, and finally verifying the transformation."
  },
  {
    "iteration": 14,
    "strategy": "Exploitation",
    "accuracy": 0.3333333333333333,
    "approach": "The script employs LLM-driven rule extraction, refinement, and application to solve grid transformation problems. It decomposes the problem into extracting a transformation rule from examples, refining the rule, and then applying it to a test input. There are three agent roles: an expert grid transformation expert (for `rule_extraction`), an expert grid transformation agent (for `refine_rule` and `apply_rule`). The functions used are `rule_extraction` (extracts transformation rules), `refine_rule` (refines the extracted rule), `apply_rule` (applies the refined rule), `call_llm` (calls the LLM), and `main` (orchestrates the process). The workflow involves `main` calling `rule_extraction`, then `refine_rule`, and finally `apply_rule` to generate the transformed grid, using `call_llm` to interact with the LLM in each step."
  },
  {
    "iteration": 15,
    "strategy": "Exploitation",
    "accuracy": 0.6666666666666666,
    "approach": "The script solves grid transformation problems using LLMs by first extracting a transformation rule, refining it through a verification loop, and then applying it to a test input.  The problem is decomposed into rule extraction, rule refinement/verification, and rule application. The agents involved are a grid transformation analyst (rule_extraction), a rule refinement agent (refine_rule), a verification agent (refine_rule), and a transformation agent (apply_rule).  The `call_llm` function is central, facilitating communication with the LLM in all the other functions. The overall workflow is: `main` calls `rule_extraction`, which calls `call_llm`, then `refine_rule` which calls `call_llm` multiple times to refine and verify, extracts the input from the question, and then `apply_rule` is called to apply the refined rule, and `call_llm` is called to generate the final answer."
  },
  {
    "iteration": 16,
    "strategy": "Exploitation",
    "accuracy": 0.3333333333333333,
    "approach": "The script addresses grid transformation problems using LLM-driven rule extraction, refinement, and application. It decomposes the problem into rule extraction, rule refinement with verification, and rule application. Agents with roles like \"grid transformation analyst\", \"rule refinement expert\", and \"grid transformation agent\" are used to perform specific subtasks. The functions `rule_extraction` extracts rules, `refine_rule` refines the extracted rules using verification, and `apply_rule` applies the refined rule to the input grid; these are orchestrated in `main` to produce the final transformed grid."
  },
  {
    "iteration": 17,
    "strategy": "Exploration",
    "accuracy": 0.3333333333333333,
    "approach": "The script solves grid transformation problems by analyzing training examples, identifying transformation rules, and applying them to a test input grid using LLMs. It decomposes the problem into analysis, transformation, and verification steps, assigning the LLM different roles: analyzer, transformer, and verifier. The functions used are `analyze_training_examples` to analyze patterns, `apply_transformation` to apply the transformation, `verify_transformation` to verify if the transformation is correct, and `call_llm` to call the Gemini LLM. The overall workflow involves analyzing training examples, extracting the test input grid, applying the identified transformation, and verifying the transformation for correctness."
  },
  {
    "iteration": 18,
    "strategy": "Exploration",
    "accuracy": 0.3333333333333333,
    "approach": "This script addresses grid transformation problems by identifying the transformation pattern, applying it, and verifying the result using LLMs. The problem is decomposed into identifying the transformation type, applying the transformation, and function testing. The agent roles include an expert in recognizing grid transformation patterns, an expert in applying grid transformations, and a grid transformation expert for testing. The script uses `call_llm` to interact with the Gemini LLM, `identify_transformation_type` to determine the grid transformation, `apply_transformation` to apply the identified transformation, and `function_test` to verify the result. The workflow is: `main` calls `identify_transformation_type` to determine the transformation, extracts the input grid, calls `apply_transformation` to transform the grid, and then calls `function_test` to verify the output."
  },
  {
    "iteration": 19,
    "strategy": "Exploitation",
    "accuracy": 0.0,
    "approach": "The script uses a chain-of-thought approach with LLMs to transform input grids based on patterns observed in training examples. It decomposes the problem into three stages: rule extraction, rule refinement, and rule application, each handled by a dedicated function that acts as an agent with a specific role. The main functions used include `rule_extraction` which extracts the transformation rule, `refine_rule` which refines the extracted rule for accuracy, `apply_rule` which applies the refined rule to the input grid, `call_llm` which is used to call the Gemini LLM, and `main` which orchestrates the entire process. The overall workflow involves extracting a rule from examples, refining it, and then applying it to a test input grid to generate the transformed output."
  },
  {
    "iteration": 20,
    "strategy": "Exploration",
    "accuracy": 0.0,
    "approach": "The script addresses grid transformation problems by generating and validating multiple hypotheses using the Gemini LLM. It decomposes the problem into hypothesis generation, testing, and application, assigning the LLM the roles of an expert in analyzing grid transformations and applying rules. The `generate_hypotheses` function creates multiple potential transformation rules, `test_hypotheses` verifies them against training data, and `apply_transformation` applies the best validated rule to the test input. The `call_llm` function is used by each function to send requests to the Gemini LLM. The overall workflow involves generating hypotheses, testing them, selecting the best one, extracting the test input, and applying the transformation to generate the final output."
  },
  {
    "iteration": 21,
    "strategy": "Exploitation",
    "accuracy": 0.0,
    "approach": "The script solves grid transformation problems using LLM-driven rule extraction, refinement, and application. It employs a chain-of-thought approach, where the problem is decomposed into extracting a transformation rule, refining it, and then applying it to a test input grid. Three LLM agent roles are used: an expert grid transformation expert, an expert grid transformation agent for refinement, and another expert grid transformation agent for applying the rule.\n\nThe core functions are `rule_extraction`, `refine_rule`, and `apply_rule`, which sequentially use the LLM to extract, refine, and apply transformation rules. `call_llm` is used by all three functions to interact with the Gemini LLM. The `main` function orchestrates the workflow: `rule_extraction` extracts a rule from the question, `refine_rule` corrects any errors in the extracted rule, and `apply_rule` transforms the input grid using the refined rule, with regex used to extract the test input grid from the question."
  },
  {
    "iteration": 22,
    "strategy": "Exploration",
    "accuracy": 0.0,
    "approach": "The script solves grid transformation problems by identifying \"anchor\" values and propagating their influence to neighboring cells using an LLM. The problem is decomposed into identifying anchor values, analyzing neighborhood influence, and transforming the input grid. Three distinct agent roles are implicitly defined within the prompt of the functions: an expert in identifying key values, an expert at analyzing grid transformations, and an expert in applying grid transformations. The script uses `call_llm` to interact with the Gemini LLM. The function calls are structured as follows: `identify_anchor_values` -> `analyze_neighborhood_influence` -> `transform_grid`, with the output of each function serving as input for the subsequent one; regex is used to extract the test input. Overall, the script extracts the test grid, identifies anchor values and their influence using the LLM, then transforms the test grid based on this analysis."
  }
]

        COMMON ERROR PATTERNS:
        []

        PRIMARY ISSUES (last 3 iterations):
        [
  {
    "iteration": 13,
    "issue": "The most critical problem is the inaccurate and incomplete extraction of transformation rules from the training examples. The current approach is not robust enough to handle the complexity and variability of the transformations, leading to incorrect solutions."
  },
  {
    "iteration": 14,
    "issue": "The primary issue is the **inability to accurately generalize and apply transformation rules from training examples to test inputs**, leading to incorrect output grids in terms of both size and content. The system struggles to translate observed patterns into a robust algorithm for manipulating the grid. It seems like there might be a lack of connection between the input and output grids."
  },
  {
    "iteration": 15,
    "issue": "The primary issue is the system's inability to accurately identify the underlying transformation pattern and generalize it to unseen test cases, leading to an incorrect transformation of the input grid. The logic behind deciding which value to copy and where to paste needs to be improved."
  },
  {
    "iteration": 16,
    "issue": "The most critical problem is the **inability to accurately abstract and generalize patterns from the training examples to the test input, specifically in the context of grid transformations and dimensionality changes.** The system attempts to mimic patterns but fails to understand the underlying logic or relationships between different elements in the grid."
  },
  {
    "iteration": 17,
    "issue": "The most critical problem is the **inaccurate application of the learned grid transformation pattern**. This stems from an insufficient understanding of the underlying relationships between the input and output grids in the training examples. The system needs a more robust mechanism to interpret the nuances of the transformation rules and apply them correctly to new, unseen inputs."
  },
  {
    "iteration": 18,
    "issue": "The primary issue is the system's **inability to accurately learn and generalize visual patterns from the provided training examples.** This leads to incorrect code generation and flawed execution logic, resulting in outputs that deviate from the golden answers. The root cause is that the system does not have a reliable means of inferring transformation rules from examples. It needs a more robust pattern recognition and generalization capability."
  },
  {
    "iteration": 19,
    "issue": "The most critical problem is the system's flawed pattern recognition and application logic. The AI struggles to internalize the mapping between input and output grids, specifically how values change and are positioned based on the provided training examples. The system fails to understand complex relational mappings that drive the transformation and results in inaccurate substitutions."
  },
  {
    "iteration": 20,
    "issue": "The primary issue is the **failure to correctly infer and apply the intended transformation rule from the training examples to the test input.** This stems from inadequate hypothesis generation and validation and a reliance on simple, incorrect transformations like flipping."
  },
  {
    "iteration": 21,
    "issue": "The most critical problem is the system's failure to accurately identify and generalize the transformation pattern from the training examples. The code generated is often too rigid and tied to the specifics of the training data, resulting in incorrect transformations of the test input."
  },
  {
    "iteration": 22,
    "issue": "The most critical problem is **incorrect value propagation and generation**, where the system hallucinates and propagates values that are outside of what exists in the dataset. This shows that its understanding of the transformation rule that it is supposed to implement is flawed."
  }
]

        TARGETED IMPROVEMENTS:
        [
  "Consider using attention mechanisms to focus on the most relevant parts of the training examples.",
  "Implement Range Checking:** Explicitly check that all generated values fall within the valid range observed in the input grid and training data. Raise an error if a value is outside this range to identify the source of hallucination.",
  "Encourage the system to generate more abstract and generalized code. This could involve using variables and loops instead of hardcoded values.",
  "Develop a scoring function that evaluates the transformed output against the original input and the training examples.",
  "Add print statements that output the matrix to see where things are going wrong in the logic.",
  "Explore different machine learning models capable of learning complex patterns from limited data (e.g., few-shot learning techniques).",
  "Employ more sophisticated feature extraction techniques to identify key characteristics of the transformations.",
  "Use the scoring function to guide the code generation process, favoring solutions that align better with the established patterns.",
  "Implement techniques like data augmentation to create more diverse training examples, forcing the system to learn more robust patterns.",
  "Refine Logic:** Re-examine the logic that identifies the relevant \"neighboring\" values to propagate, ensuring that the chosen values align with the patterns demonstrated in the training examples."
]
        

EXAMPLE OF EFFECTIVE LLM USAGE PATTERNS:

```python
#!/usr/bin/env python
"""
llm_techniques.py - A collection of LLM interaction patterns with varying numbers of examples
"""

import os
import re
import json
import math
from typing import List, Dict, Any, Optional, Union

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. 
    DO NOT modify this or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

def chain_of_thought_reasoning(problem: str) -> str:
    """
    Solve a problem using step-by-step reasoning.

    Uses a single example to demonstrate the chain-of-thought approach.
    """
    system_instruction = "You are an expert problem solver who breaks down problems step-by-step."

    prompt = f"""
    Solve this problem step-by-step:

    Example:
    Problem: If John has 5 apples and gives 2 to Mary, then buys 3 more, how many apples does John have?

    Step 1: Start with John's initial apples: 5 apples
    Step 2: Subtract the apples given to Mary: 5 - 2 = 3 apples
    Step 3: Add the newly purchased apples: 3 + 3 = 6 apples
    Therefore: John has 6 apples.

    Problem: {problem}

    Let's solve this step-by-step:
    """

    return call_llm(prompt, system_instruction)

def few_shot_learning(problem: str, complexity: str = "medium") -> str:
    """
    Solve a problem using few-shot learning with a variable number of examples.

    The number of examples varies based on the problem complexity:
    - "simple": 1 example
    - "medium": 2 examples
    - "complex": 3-5 examples
    """
    system_instruction = "You are an expert problem solver who learns from examples."

    # Vary the number of examples based on complexity
    if complexity == "simple":
        prompt = f"""
        I'll show you an example, then ask you to solve a new problem.

        Example:
        Input: What is the capital of France?
        Output: The capital of France is Paris.

        Now, solve this new problem:
        Input: {problem}
        Output:
        """
    elif complexity == "medium":
        prompt = f"""
        I'll show you a couple of examples, then ask you to solve a new problem.

        Example 1:
        Input: What is the capital of France?
        Output: The capital of France is Paris.

        Example 2:
        Input: What is the largest ocean on Earth?
        Output: The largest ocean on Earth is the Pacific Ocean.

        Now, solve this new problem:
        Input: {problem}
        Output:
        """
    else:  # complex
        prompt = f"""
        I'll show you several examples, then ask you to solve a new problem.

        Example 1:
        Input: What is the capital of France?
        Output: The capital of France is Paris.

        Example 2:
        Input: What is the largest ocean on Earth?
        Output: The largest ocean on Earth is the Pacific Ocean.

        Example 3:
        Input: Who wrote the play "Romeo and Juliet"?
        Output: The play "Romeo and Juliet" was written by William Shakespeare.

        Example 4:
        Input: What is the chemical symbol for gold?
        Output: The chemical symbol for gold is Au.

        Example 5:
        Input: What year did World War II end?
        Output: World War II ended in 1945.

        Now, solve this new problem:
        Input: {problem}
        Output:
        """

    return call_llm(prompt, system_instruction)

def verification_with_feedback(problem: str, solution: str, max_attempts: int = 3) -> str:
    """
    Verify a solution and provide feedback for improvement.
    Uses moderate number of examples (2) to demonstrate verification criteria.
    """
    system_instruction = "You are a critical evaluator who verifies solutions and provides detailed feedback."

    # Initial verification with two examples
    verification_prompt = f"""
    Verify if this solution correctly addresses the problem:

    Example 1:
    Problem: Calculate the area of a rectangle with length 5m and width 3m.
    Solution: The area is 5m × 3m = 15m².
    Verification: VALID - The solution correctly calculates the area by multiplying length by width.

    Example 2:
    Problem: Find the next number in the sequence: 2, 4, 8, 16, ...
    Solution: The next number is 32 because each number is multiplied by 3.
    Verification: INVALID - The pattern is that each number is multiplied by 2, not 3. The correct next number is 32.

    Problem: {problem}
    Solution: {solution}

    Verify if the solution is valid and complete. Return:
    - "VALID: [brief explanation]" if the solution is correct
    - "INVALID: [detailed explanation of issues]" if there are any problems
    """

    verification_result = call_llm(verification_prompt, system_instruction)

    # Check if refinement is needed
    if "INVALID" in verification_result and max_attempts > 1:
        refinement_prompt = f"""
        Your solution needs improvement:

        Problem: {problem}

        Your solution:
        {solution}

        Feedback:
        {verification_result}

        Please provide a revised solution that addresses all the issues mentioned.
        """

        improved_solution = call_llm(refinement_prompt, system_instruction)

        # Recursive call with one fewer attempt
        return verification_with_feedback(problem, improved_solution, max_attempts - 1)

    return solution if "VALID" in verification_result else verification_result + "\n\n" + solution

def multi_perspective_analysis(problem: str, perspectives: List[str] = None) -> str:
    """
    Analyze a problem from multiple perspectives, with examples for only the first perspective.

    This demonstrates varying example usage - the first perspective has 2 examples,
    while others have none to show how to vary example density.
    """
    system_instruction = "You are an analytical thinker who can examine problems from diverse perspectives."

    if perspectives is None:
        perspectives = ["logical", "creative", "critical"]

    analyses = []

    # First perspective uses examples
    first_perspective = perspectives[0]
    first_perspective_prompt = f"""
    Analyze this problem from a {first_perspective} perspective:

    Example 1:
    Problem: A city is experiencing increasing traffic congestion.
    {first_perspective.capitalize()} perspective: This appears to be a resource allocation problem. We need to quantify current road capacity, traffic flow rates, peak usage times, and alternative route availability. With this data, we can identify bottlenecks and evaluate solutions like traffic light optimization, lane adjustments, or public transportation improvements.

    Example 2:
    Problem: A company's sales have declined for three consecutive quarters.
    {first_perspective.capitalize()} perspective: We should analyze the sales data by product line, region, and customer segment to identify specific decline patterns. We should compare against market trends, competitor performance, and economic indicators to determine internal versus external factors. Each potential cause should be tested against available evidence.

    Problem: {problem}

    Provide a thorough {first_perspective} perspective:
    """

    analyses.append({
        "perspective": first_perspective,
        "analysis": call_llm(first_perspective_prompt, system_instruction)
    })

    # Other perspectives don't use examples - demonstrating variation
    for perspective in perspectives[1:]:
        perspective_prompt = f"""
        Analyze this problem from a {perspective} perspective:

        Problem: {problem}

        Focus on aspects that a {perspective} thinker would notice.
        Provide a thorough {perspective} perspective:
        """

        analyses.append({
            "perspective": perspective,
            "analysis": call_llm(perspective_prompt, system_instruction)
        })

    # Synthesize the perspectives
    synthesis_prompt = f"""
    Synthesize these different perspectives into a comprehensive analysis:

    Problem: {problem}

    Perspectives:
    {chr(10).join([f"{p['perspective'].capitalize()} Perspective:\n{p['analysis']}" for p in analyses])}

    Create a unified analysis that incorporates insights from all perspectives.
    """

    return call_llm(synthesis_prompt, system_instruction)

def self_consistency_approach(problem: str, n_paths: int = 3) -> str:
    """
    Generate multiple reasoning paths and select the most consistent answer.

    Uses a moderate number of examples (2) to demonstrate the approach.
    """
    system_instruction = "You are a thorough problem solver who considers multiple approaches."

    # Generate multiple reasoning paths
    reasoning_paths = []

    # First path with examples
    first_path_prompt = f"""
    Solve this problem step by step:

    Example 1:
    Problem: If a train travels at 60 mph, how long will it take to travel 150 miles?
    Reasoning Path 1:
    Step 1: Identify the formula relating distance, speed, and time: time = distance ÷ speed
    Step 2: Substitute the values: time = 150 miles ÷ 60 mph
    Step 3: Calculate: time = 2.5 hours
    Therefore, it will take 2.5 hours to travel 150 miles.

    Example 2:
    Problem: What is the value of 3x + 5 = 20?
    Reasoning Path 1:
    Step 1: Subtract 5 from both sides: 3x = 15
    Step 2: Divide both sides by 3: x = 5
    Therefore, x = 5.

    Problem: {problem}

    Show your step-by-step reasoning to solve this problem:
    """

    reasoning_paths.append(call_llm(first_path_prompt, system_instruction))

    # Generate additional paths with fewer examples
    for i in range(1, n_paths):
        path_prompt = f"""
        Solve this problem using a different approach than before:

        Problem: {problem}

        Show your step-by-step reasoning using a unique approach:
        """

        reasoning_paths.append(call_llm(path_prompt, system_instruction))

    # Extract answers from each path
    answers = []
    for i, path in enumerate(reasoning_paths):
        extract_prompt = f"""
        Extract the final numerical or categorical answer from this reasoning:

        {path}

        Provide ONLY the final answer, with no explanation:
        """

        answers.append({
            "path_index": i,
            "reasoning": path,
            "answer": call_llm(extract_prompt, "Extract only the final answer.")
        })

    # Determine the most consistent answer
    consistency_prompt = f"""
    These are different approaches to solving the same problem:

    Problem: {problem}

    {chr(10).join([f"Approach {a['path_index']+1}:\nReasoning: {a['reasoning']}\nAnswer: {a['answer']}" for a in answers])}

    Which answer is most consistent across approaches? If there's disagreement, which reasoning path is most sound?
    Provide the final answer with explanation.
    """

    return call_llm(consistency_prompt, system_instruction)

def best_of_n_approach(problem: str, n: int = 3) -> str:
    """
    Generate multiple solutions and select the best one.

    Varies example count by solution index (1st solution has 3 examples, 2nd has 1, 3rd has none).
    """
    system_instruction = "You are an expert problem solver who generates multiple approaches."

    # Generate multiple diverse solutions with varying examples
    solutions = []

    # First solution with 3 examples
    first_solution_prompt = f"""
    Generate a detailed solution to this problem:

    Example 1:
    Problem: Design a way to reduce food waste in restaurants.
    Solution 1: Implement a dynamic inventory management system that tracks ingredients in real-time and predicts usage based on historical data. This system would alert staff when ingredients are nearing expiration, suggest daily specials to use these ingredients, and provide reports on waste patterns. It could integrate with ordering systems to optimize purchase quantities and reduce overstock.

    Example 2:
    Problem: Create a method to improve student engagement in online classes.
    Solution 1: Develop a gamified learning platform that awards points and badges for participation, completion, and helping peers. Include interactive elements like polls, breakout rooms, and collaborative projects. Implement a system of short, focused content delivery (10-15 minutes) followed by active application to maintain attention spans.

    Example 3:
    Problem: Design a water conservation system for urban homes.
    Solution 1: Create an integrated water recycling system that captures greywater from showers, sinks, and washing machines, filters it, and redirects it for toilet flushing and garden irrigation. Include smart meters that display water usage in real-time and suggest conservation tips. Add rainwater collection from roofs with automated distribution based on garden moisture sensors.

    Problem: {problem}

    Provide a comprehensive, detailed solution:
    """

    solutions.append(call_llm(first_solution_prompt, system_instruction))

    # Second solution with 1 example
    if n > 1:
        second_solution_prompt = f"""
        Generate a different solution to this problem using an alternative approach:

        Example:
        Problem: Design a way to reduce food waste in restaurants.
        Solution 2: Implement a community connection program where restaurants partner with local shelters and food banks for daily donation of unused ingredients and prepared food. Create standardized packaging and pickup protocols, with tax benefit documentation automated through an app. Train staff on proper handling for donation, and track community impact as a marketing tool.

        Problem: {problem}

        Provide a completely different approach than conventional solutions:
        """

        solutions.append(call_llm(second_solution_prompt, system_instruction))

    # Third solution with no examples
    if n > 2:
        third_solution_prompt = f"""
        Generate a third, innovative solution to this problem:

        Problem: {problem}

        Think outside the box and provide a creative solution that others might not consider:
        """

        solutions.append(call_llm(third_solution_prompt, system_instruction))

    # Evaluate solutions
    evaluations = []
    for i, solution in enumerate(solutions):
        evaluation_prompt = f"""
        Evaluate this solution on a scale of 1-10 for effectiveness, feasibility, and originality:

        Problem: {problem}

        Solution {i+1}:
        {solution}

        Provide a detailed evaluation with specific strengths and weaknesses:
        """

        evaluations.append(call_llm(evaluation_prompt, "You are a critical evaluator."))

    # Select the best solution
    selection_prompt = f"""
    Compare these solutions and select the best one:

    Problem: {problem}

    {chr(10).join([f"Solution {i+1}:\n{solutions[i]}\n\nEvaluation:\n{evaluations[i]}" for i in range(len(solutions))])}

    Which solution is the strongest overall? Explain your selection.
    """

    return call_llm(selection_prompt, "You are a solution selector.")

def react_pattern(problem: str, max_steps: int = 5) -> str:
    """
    Solve problems through iterative Reasoning and Acting (ReAct) approach.

    Uses 1 detailed example to demonstrate the approach.
    """
    system_instruction = "You are a problem-solving agent that follows the ReAct pattern: Reason about the current state, take an Action, observe the result, and repeat until reaching a solution."

    # Initialize ReAct process
    prompt = f"""
    Solve this problem using the ReAct pattern - alternate between Reasoning and Acting until you reach a final answer.

    Example:
    Problem: What is the capital of the country where the Great Barrier Reef is located, and what is the population of that capital?

    Thought 1: I need to determine which country the Great Barrier Reef is in, then find its capital, and finally the population of that capital.
    Action 1: Search[Great Barrier Reef location]
    Observation 1: The Great Barrier Reef is located off the coast of Queensland in northeastern Australia.

    Thought 2: Now I know the Great Barrier Reef is in Australia. I need to find Australia's capital city.
    Action 2: Search[capital of Australia]
    Observation 2: The capital of Australia is Canberra.

    Thought 3: Now I need to find the population of Canberra.
    Action 3: Search[population of Canberra]
    Observation 3: As of 2021, the population of Canberra is approximately 431,500.

    Thought 4: I have found all the required information. The capital of Australia (where the Great Barrier Reef is located) is Canberra, and its population is approximately 431,500.
    Action 4: Finish[The capital of Australia is Canberra, with a population of approximately 431,500.]

    Now solve this new problem:
    {problem}

    Thought 1:
    """

    # Initial reasoning and action planning
    response = call_llm(prompt, system_instruction)
    full_response = response

    # Extract the action from the response
    action = extract_react_action(response)

    # Continue the ReAct loop until we reach a "Finish" action or max steps
    steps = 1
    while action and action["type"] != "Finish" and steps < max_steps:
        steps += 1

        # Get observation based on action type
        observation = "No valid observation."

        if action["type"] == "Search":
            observation = simulate_search(action["content"])
        elif action["type"] == "Calculate":
            observation = simulate_calculation(action["content"])
        elif action["type"] == "Lookup":
            observation = simulate_lookup(action["content"])

        # Continue the ReAct process with the new observation
        continuation_prompt = f"""
        {full_response}
        Observation {action["step"]}: {observation}

        Thought {steps+1}:
        """

        next_response = call_llm(continuation_prompt, system_instruction)
        full_response = f"{full_response}\nObservation {action['step']}: {observation}\n\n{next_response}"

        # Extract the next action
        action = extract_react_action(next_response)

    return full_response

def extract_react_action(text: str) -> Dict[str, Any]:
    """Helper function to extract action from ReAct response"""
    action_match = re.search(r"Action (\d+): (\w+)\[(.*?)\]", text)
    if not action_match:
        return None

    step = int(action_match.group(1))
    action_type = action_match.group(2)
    content = action_match.group(3)

    return {
        "step": step,
        "type": action_type, 
        "content": content
    }

def simulate_search(query: str) -> str:
    """Simulate a search action by calling the LLM"""
    return call_llm(f"Provide a factual answer about: {query}", 
                   "You are a helpful search engine providing concise information.")

def simulate_calculation(expression: str) -> str:
    """Simulate a calculation action"""
    try:
        result = eval(expression)
        return f"The result is {result}"
    except Exception as e:
        return f"Error in calculation: {str(e)}"

def simulate_lookup(term: str) -> str:
    """Simulate a lookup action"""
    return call_llm(f"Provide specific information about: {term}",
                   "You are a knowledgebase providing specific information.")

def feature_extraction(input_text: str, domain: str = "general") -> str:
    """
    Extract key features from input text.

    This function shows the pattern of adapting examples based on domain.
    """
    system_instruction = "You are a feature extraction specialist."

    # Domain-specific examples
    if domain == "text":
        prompt = f"""
        Analyze this text and extract key features:

        Example 1:
        Input: The company reported quarterly earnings of $3.5 million, which represents a 12% increase from last year.
        Features:
        - Entity: "the company" (organization)
        - Financial data: "$3.5 million" (earnings)
        - Temporal reference: "quarterly" (time period)
        - Comparative data: "12% increase" (change)
        - Baseline: "last year" (comparison point)

        Example 2:
        Input: The patient presents with fever, cough, and fatigue, which began approximately 3 days ago.
        Features:
        - Entity: "the patient" (person)
        - Symptoms: "fever", "cough", "fatigue" (medical conditions)
        - Temporal reference: "3 days ago" (onset)
        - Progression: "began" (development indicator)

        Input: {input_text}

        Extract key features, including:
        - Entities and their types
        - Attributes and values
        - Relationships
        - Temporal information
        - Quantitative data
        """
    elif domain == "data":
        prompt = f"""
        Analyze this dataset and extract key features:

        Example:
        Input: Monthly sales data for 5 products across 12 months, showing seasonal patterns for outdoor items and stable demand for indoor items.
        Features:
        - Data type: Time series (monthly)
        - Variables: Products (5 categories), Sales (numerical)
        - Patterns: Seasonal variation (outdoor products), Stability (indoor products)
        - Potential analysis: Seasonality testing, Trend analysis, Product clustering

        Input: {input_text}

        Extract key features, including:
        - Data types and structures
        - Variables and their relationships
        - Apparent patterns or trends
        - Potential analysis approaches
        """
    else:  # general domain with fewer examples
        prompt = f"""
        Analyze this input and extract key features:

        Example:
        Input: A smartphone with 5G capability, 128GB storage, and a 6.7-inch display, priced at $999.
        Features:
        - Product type: Smartphone (electronic device)
        - Connectivity: 5G (network capability)
        - Storage: 128GB (capacity)
        - Display: 6.7-inch (size specification)
        - Price: $999 (monetary value)

        Input: {input_text}

        Extract key features, focusing on:
        - Main entities or objects
        - Attributes and specifications
        - Quantities and measurements
        - Categories and classifications
        - Relationships between elements
        """

    return call_llm(prompt, system_instruction)

def pattern_identification(examples: List[str], domain: str = "general") -> str:
    """
    Identify patterns across multiple examples.

    Uses a varying number of examples in the prompt based on domain.
    """
    system_instruction = "You are a pattern recognition specialist."

    # Format the user-provided examples
    formatted_examples = "\n".join([f"Example {i+1}:\n{ex}" for i, ex in enumerate(examples)])

    # Domain-specific patterns with varying example counts
    if domain == "sequence":
        prompt = f"""
        Examine these examples and identify underlying sequence patterns:

        Example Set 1:
        Sequence: 2, 4, 8, 16, 32, ...
        Pattern: Each number is multiplied by 2 to get the next number.

        Example Set 2:
        Sequence: 3, 6, 11, 18, 27, ...
        Pattern: The differences between consecutive numbers form an arithmetic sequence: 3, 5, 7, 9, ...

        Example Set 3:
        Sequence: 1, 4, 9, 16, 25, ...
        Pattern: These are perfect squares: 1², 2², 3², 4², 5², ...

        Your examples:
        {formatted_examples}

        Identify all possible patterns in these examples. For each pattern:
        1. Describe the pattern precisely
        2. Show how it applies to each example
        3. Predict the next items if the pattern continues
        """
    elif domain == "visual":
        prompt = f"""
        Examine these visual examples and identify underlying patterns:

        Example Set:
        Example 1: A triangle inside a circle
        Example 2: A square inside a circle
        Example 3: A pentagon inside a circle
        Pattern: Increasing number of sides for the shape inside the circle

        Your examples:
        {formatted_examples}

        Identify all possible visual patterns. For each pattern:
        1. Describe the pattern precisely
        2. Show how it applies to each example
        3. Predict what would come next in the pattern
        """
    else:  # general domain with single example
        prompt = f"""
        Examine these examples and identify all underlying patterns:

        Example Set:
        Items: Apple, Banana, Cherry, Date, Fig
        Pattern: Alphabetical order of fruit names

        Your examples:
        {formatted_examples}

        Identify all possible patterns. For each pattern:
        1. Describe the pattern precisely
        2. Show how it applies to each example
        3. Explain why this pattern is significant
        4. Predict the next items if the pattern continues
        """

    return call_llm(prompt, system_instruction)

def wait_injection(problem: str) -> str:
    """
    Use the 'wait' injection technique to improve reasoning.

    Uses no explicit examples to show minimal example case.
    """
    system_instruction = "You are a careful problem solver who reconsiders initial conclusions."

    # Get initial reasoning
    initial_prompt = f"""
    Solve this problem step by step:
    {problem}
    """

    initial_reasoning = call_llm(initial_prompt, system_instruction)

    # Find a good injection point - around 50-70% through the reasoning
    words = initial_reasoning.split()
    injection_point = len(words) // 2

    # Create parts for injection
    first_part = " ".join(words[:injection_point])

    # Inject wait and reconsideration
    wait_prompt = f"""
    Solve this problem step by step:
    {problem}

    {first_part}

    ...wait... let me reconsider this...

    I should check if there are any assumptions I made that might not be valid.
    Let me approach this problem again, more carefully:
    """

    return call_llm(wait_prompt, system_instruction)

def hypothesis_testing(problem: str, examples: List[Dict] = None) -> str:
    """
    Generate and test hypotheses against examples.

    Uses 2 examples to demonstrate the pattern.
    """
    system_instruction = "You are a scientific thinker who generates and tests hypotheses."

    # If examples are not provided, use default ones
    if not examples:
        examples = [
            {"input": "A", "output": "1"},
            {"input": "B", "output": "2"},
            {"input": "C", "output": "3"}
        ]

    formatted_examples = json.dumps(examples, indent=2)

    prompt = f"""
    Generate multiple hypotheses about the pattern in this problem and test them against examples:

    Problem: {problem}
    Examples: {formatted_examples}

    Example Hypothesis Testing 1:
    Problem: What's the rule for transforming letters to numbers?
    Examples: [A→1, B→2, C→3]

    Hypothesis 1: The rule is to assign each letter its position in the alphabet.
    Test: 
    - A is position 1: Matches
    - B is position 2: Matches
    - C is position 3: Matches
    Result: This hypothesis is consistent with all examples.

    Hypothesis 2: The rule is to assign each letter a value equal to its ASCII code minus 64.
    Test:
    - A (ASCII 65) - 64 = 1: Matches
    - B (ASCII 66) - 64 = 2: Matches
    - C (ASCII 67) - 64 = 3: Matches
    Result: This hypothesis is also consistent with all examples.

    Example Hypothesis Testing 2:
    Problem: What's the next number in the sequence: 2, 4, 6, 8, ...?
    Examples: [1→2, 2→4, 3→6, 4→8]

    Hypothesis 1: Each number is double its position.
    Test:
    - Position 1: 2 × 1 = 2: Matches
    - Position 2: 2 × 2 = 4: Matches
    - Position 3: 2 × 3 = 6: Matches
    - Position 4: 2 × 4 = 8: Matches
    Result: This hypothesis is consistent with all examples.

    For the current problem:
    1. Generate at least 3 distinct hypotheses that could explain the pattern
    2. Test each hypothesis against all examples
    3. Evaluate which hypothesis best explains the data
    4. Make a prediction based on the strongest hypothesis
    """

    return call_llm(prompt, system_instruction)

def data_analyzer(examples: List[Dict], domain: str = "general") -> str:
    """
    Analyze dataset patterns before solving.

    Uses no explicit examples to demonstrate minimal example case.
    """
    system_instruction = "You are a data pattern analyst specializing in identifying patterns and structures."

    formatted_examples = json.dumps(examples, indent=2)

    prompt = f"""
    Analyze these examples to identify patterns and solution approaches:

    Examples: {formatted_examples}

    Provide a comprehensive analysis with these sections:

    ## DATASET CHARACTERISTICS
    What patterns exist in the data? What structures or formats are present?

    ## CHALLENGE ASSESSMENT
    What makes these problems difficult? What edge cases exist?

    ## APPROACH RECOMMENDATIONS
    What solution strategies would work well? How should the problem be decomposed?

    ## IMPLEMENTATION CONSIDERATIONS
    What verification steps are needed? What intermediate representations help?

    Focus on concrete, specific insights that directly relate to solving problems of this type.
    """

    return call_llm(prompt, system_instruction)

def expert_panel(problem: str, experts: List[str] = None) -> str:
    """
    Simulate a panel of experts analyzing a problem.

    Uses varying numbers of examples for different experts (2 for first, 1 for second, 0 for others).
    """
    system_instruction = "You can simulate diverse expert perspectives on complex problems."

    if not experts:
        experts = ["mathematician", "programmer", "designer"]

    experts_insights = []

    # First expert with 2 examples
    first_expert = experts[0]
    first_expert_prompt = f"""
    As an expert {first_expert}, analyze this problem:

    Example 1:
    Problem: How to optimize traffic flow in a congested urban area?
    {first_expert.capitalize()} analysis: I would model this as a multi-variable optimization problem. We need to define the network of roads as a directed graph, where intersections are nodes and roads are edges. Each edge has a capacity and current flow. We can then use techniques like linear programming or network flow algorithms to maximize throughput while minimizing waiting time. Key constraints include physical road capacity, traffic light timing, and peak demand patterns.

    Example 2:
    Problem: What's the most efficient way to deploy solar panels across a city?
    {first_expert.capitalize()} analysis: This requires spatial optimization based on irradiance maps. I would create a model that accounts for roof orientation, angle, shading from surrounding structures, and regional weather patterns. The objective function would maximize energy generation while minimizing cost, with constraints for available roof space and structural limitations. We could solve this using mixed-integer programming methods.

    Problem: {problem}

    Provide a thorough analysis from your perspective as a {first_expert}:
    """

    experts_insights.append({
        "expert": first_expert,
        "analysis": call_llm(first_expert_prompt, system_instruction)
    })

    # Second expert with 1 example
    if len(experts) > 1:
        second_expert = experts[1]
        second_expert_prompt = f"""
        As an expert {second_expert}, analyze this problem:

        Example:
        Problem: How to optimize traffic flow in a congested urban area?
        {second_expert.capitalize()} analysis: I would approach this by developing algorithms that can process real-time traffic data. We'd need distributed sensors at key intersections feeding data into a central system. The system would use machine learning to predict traffic patterns and dynamically adjust traffic light timing. I'd implement a microservice architecture with fault tolerance, and ensure the system could handle the throughput of data from thousands of sensors with minimal latency.

        Problem: {problem}

        Provide a thorough analysis from your perspective as a {second_expert}:
        """

        experts_insights.append({
            "expert": second_expert,
            "analysis": call_llm(second_expert_prompt, system_instruction)
        })

    # Remaining experts with no examples
    for expert in experts[2:]:
        expert_prompt = f"""
        As an expert {expert}, analyze this problem:

        Problem: {problem}

        Provide a thorough analysis from your perspective as a {expert}:
        """

        experts_insights.append({
            "expert": expert,
            "analysis": call_llm(expert_prompt, system_instruction)
        })

    # Facilitate discussion and consensus
    discussion_prompt = f"""
    The following experts are discussing this problem:

    Problem: {problem}

    {chr(10).join([f"{e['expert'].capitalize()}:\n{e['analysis']}" for e in experts_insights])}

    Simulate a discussion between these experts where they:
    1. Respond to each other's insights
    2. Identify agreements and disagreements
    3. Build on each other's ideas

    Then develop a consensus solution that incorporates the key insights from all perspectives.
    """

    return call_llm(discussion_prompt, system_instruction)

def debate_approach(problem: str) -> str:
    """
    Simulate a debate between different viewpoints to explore a problem.

    Uses no explicit examples to demonstrate minimal example case.
    """
    system_instruction = "You can simulate a productive debate between different perspectives."

    # Generate initial position
    position_prompt = f"""
    Provide a solution to this problem:

    Problem: {problem}

    Offer a clear, well-reasoned solution approach.
    """

    initial_solution = call_llm(position_prompt, system_instruction)

    # Generate critique
    critique_prompt = f"""
    Critique this solution:

    Problem: {problem}

    Proposed solution:
    {initial_solution}

    Identify specific weaknesses, overlooked considerations, or potential issues with this approach.
    """

    critique = call_llm(critique_prompt, "You are a critical evaluator.")

    # Generate defense/refinement
    defense_prompt = f"""
    Respond to this critique of your solution:

    Problem: {problem}

    Your solution:
    {initial_solution}

    Critique:
    {critique}

    Either defend your approach or refine it to address the valid points in the critique.
    """

    defense = call_llm(defense_prompt, system_instruction)

    # Generate synthesis
    synthesis_prompt = f"""
    Based on this debate:

    Problem: {problem}

    Initial solution:
    {initial_solution}

    Critique:
    {critique}

    Defense/refinement:
    {defense}

    Provide an improved solution that incorporates valid points from both sides of the debate.
    """

    return call_llm(synthesis_prompt, system_instruction)

def comprehensive_verification(solution: str, problem: str, test_cases: List[Dict] = None) -> str:
    """
    Verify a solution using multiple methods.

    Uses different numbers of examples for different verification methods.
    """
    system_instruction = "You are a thorough solution verifier who catches subtle issues."

    verifications = []

    # Logical consistency check - 2 examples
    logical_check_prompt = f"""
    Verify if this solution is logically consistent:

    Example 1:
    Solution: To find the area of a triangle, multiply the base and height, then divide by 2.
    Logical Check: This solution is consistent with the formula for triangle area: A = (b × h) ÷ 2. It correctly identifies that we need the base length, height, and the division by 2.

    Example 2:
    Solution: To determine if a number is prime, check if it's divisible by any numbers from 2 to the number itself.
    Logical Check: This solution has a logical flaw. We only need to check divisibility up to the square root of the number, not all the way to the number itself. Also, we should specify that 1 is not a prime number by definition.

    Solution: {solution}

    Perform a logical consistency check. Look for:
    - Internal contradictions
    - Unwarranted assumptions
    - Logical fallacies
    - Mathematical errors
    - Conceptual misunderstandings
    """

    verifications.append({
        "method": "Logical Consistency",
        "result": call_llm(logical_check_prompt, system_instruction)
    })

    # Test case verification - 1 example
    if test_cases:
        test_case_prompt = f"""
        Apply this solution to test cases:

        Example:
        Solution: To convert Celsius to Fahrenheit, multiply by 9/5 and add 32.
        Test Case: 0°C
        Application: 0 × 9/5 + 32 = 0 + 32 = 32°F
        Verification: Correct. 0°C is indeed equal to 32°F.

        Solution: {solution}

        Test Cases:
        {chr(10).join([f"Test Case {i+1}:\nInput: {tc.get('input', 'N/A')}\nExpected: {tc.get('expected', 'N/A')}" for i, tc in enumerate(test_cases)])}

        Apply the solution to each test case and verify if it produces the expected result.
        """

        verifications.append({
            "method": "Test Case Verification",
            "result": call_llm(test_case_prompt, system_instruction)
        })

    # Edge case analysis - no examples
    edge_case_prompt = f"""
    Analyze how this solution handles edge cases:

    Problem: {problem}
    Solution: {solution}

    Identify potential edge cases and analyze how the solution handles them.
    Consider extreme values, boundary conditions, empty inputs, and special cases.
    """

    verifications.append({
        "method": "Edge Case Analysis",
        "result": call_llm(edge_case_prompt, system_instruction)
    })

    # Create verification summary
    summary_prompt = f"""
    Based on all verification results:

    {chr(10).join([f"{v['method']}:\n{v['result']}" for v in verifications])}

    Is the solution fully verified? If not, what specific issues need to be addressed?
    Provide a comprehensive verification summary with specific recommendations for improvement.
    """

    return call_llm(summary_prompt, system_instruction)

def dynamic_memory_pattern(problem: str, test_examples: List[Dict] = None, max_iterations: int = 3) -> str:
    """
    Use memory buffer to store and refine intermediate solutions iteratively.

    Uses a small number of examples embedded in the refinement prompts.
    """
    system_instruction = "You are an iterative problem solver who continually improves solutions."

    if not test_examples:
        test_examples = [{"input": "example input", "expected": "example output"}]

    # Initialize memory buffer
    memory_buffer = []

    # Generate initial candidate solutions with varying approaches
    initial_solutions = []

    # First solution with example
    first_solution_prompt = f"""
    Solve this problem with step-by-step reasoning:

    Example:
    Problem: Calculate the sum of the first 100 positive integers.
    Solution: I can use the formula for the sum of an arithmetic sequence: S = n(a₁ + aₙ)/2
    where n is the number of terms, a₁ is the first term, and aₙ is the last term.

    For the first 100 positive integers:
    n = 100
    a₁ = 1
    aₙ = 100

    S = 100(1 + 100)/2
    S = 100(101)/2
    S = 10100/2
    S = 5050

    Therefore, the sum of the first 100 positive integers is 5050.

    Problem: {problem}

    Provide a detailed step-by-step solution:
    """

    initial_solutions.append(call_llm(first_solution_prompt, system_instruction))

    # Second solution with different approach
    second_solution_prompt = f"""
    Solve this problem using a different approach than you would normally use:

    Problem: {problem}

    Try to approach this from an unusual or creative angle:
    """

    initial_solutions.append(call_llm(second_solution_prompt, system_instruction))

    # Third solution focusing on edge cases
    third_solution_prompt = f"""
    Solve this problem with special attention to edge cases:

    Problem: {problem}

    Be sure to address potential edge cases and corner conditions:
    """

    initial_solutions.append(call_llm(third_solution_prompt, system_instruction))

    # Evaluate and store each solution
    for i, solution in enumerate(initial_solutions):
        # Simulate evaluation
        evaluation_prompt = f"""
        Evaluate this solution:

        Problem: {problem}
        Solution: {solution}
        Test examples:
        {chr(10).join([f"Example {i+1}:\nInput: {ex.get('input', 'N/A')}\nExpected: {ex.get('expected', 'N/A')}" for i, ex in enumerate(test_examples)])}

        Rate this solution on:
        1. Correctness (1-10)
        2. Efficiency (1-10)
        3. Clarity (1-10)

        Provide specific feedback for improvement and an overall score (1-10).
        """

        evaluation = call_llm(evaluation_prompt, "You are a critical solution evaluator.")

        # Extract a score (simple text parsing)
        try:
            score_match = re.search(r"overall score[:\s]*(\d+)", evaluation, re.IGNORECASE)
            score = int(score_match.group(1)) if score_match else 5
        except:
            score = 5

        # Store in memory buffer
        memory_buffer.append({
            'solution': solution,
            'evaluation': evaluation,
            'score': score,
            'iteration': 0,
            'approach_type': ["systematic", "creative", "edge_case_focused"][i]
        })

    # Iterative refinement using memory
    for iteration in range(1, max_iterations + 1):
        # Sort entries by score
        memory_buffer.sort(key=lambda x: x['score'], reverse=True)

        # Get top entries to refine
        top_entries = memory_buffer[:2]

        # Generate refined solutions based on memory
        refined_solutions = []
        for entry in top_entries:
            refinement_prompt = f"""
            Refine this solution based on evaluation feedback:

            Problem: {problem}

            Previous solution (score {entry['score']}/10):
            {entry['solution']}

            Evaluation feedback:
            {entry['evaluation']}

            Example of successful refinement:
            Original: The function should loop through the array and return the first element that matches the condition.
            Feedback: This approach doesn't handle empty arrays or cases where no element matches.
            Refined: The function should first check if the array is empty and return an appropriate default value. Then it should loop through the array and return the first matching element. If no element matches, it should return a specified default value.

            Now, provide an improved solution that specifically addresses the feedback points.
            """

            refined = call_llm(refinement_prompt, system_instruction)

            # Evaluate refined solution
            refined_eval_prompt = f"""
            Evaluate this refined solution:

            Problem: {problem}
            Solution: {refined}
            Test examples:
            {chr(10).join([f"Example {i+1}:\nInput: {ex.get('input', 'N/A')}\nExpected: {ex.get('expected', 'N/A')}" for i, ex in enumerate(test_examples)])}

            Rate this solution on:
            1. Correctness (1-10)
            2. Efficiency (1-10)
            3. Clarity (1-10)

            Provide specific feedback for further improvement and an overall score (1-10).
            """

            refined_evaluation = call_llm(refined_eval_prompt, "You are a critical solution evaluator.")

            # Extract a score
            try:
                score_match = re.search(r"overall score[:\s]*(\d+)", refined_evaluation, re.IGNORECASE)
                refined_score = int(score_match.group(1)) if score_match else 5
            except:
                refined_score = 5

            # Add to refined solutions
            refined_solutions.append({
                'solution': refined,
                'evaluation': refined_evaluation,
                'score': refined_score,
                'iteration': iteration,
                'parent': entry,
                'approach_type': entry['approach_type']
            })

        # Add refined solutions to memory
        memory_buffer.extend(refined_solutions)

    # Select best solutions based on performance
    memory_buffer.sort(key=lambda x: x['score'], reverse=True)
    top_solutions = memory_buffer[:3]

    # Synthesize final solution from top performers
    synthesis_prompt = f"""
    Create a final solution based on these top-performing approaches:

    Problem: {problem}

    {chr(10).join([f"Approach {i+1} (score {s['score']}/10):\n{s['solution']}" for i, s in enumerate(top_solutions)])}

    Example of good synthesis:
    Problem: Design an algorithm to find duplicates in an array.
    Approach 1: Using a nested loop (O(n²) complexity)
    Approach 2: Using a hash set (O(n) complexity but O(n) space)
    Approach 3: Sorting first, then linear scan (O(n log n) complexity, O(1) extra space)
    Synthesis: For this problem, Approach 2 offers the best time complexity. I'll use a hash set to track seen elements, which gives us O(n) time complexity. However, I'll incorporate the edge case handling from Approach 1 and the memory optimization technique from Approach 3 for large inputs.

    Create a solution that incorporates the strengths of all approaches while addressing their weaknesses.
    """

    final_solution = call_llm(synthesis_prompt, system_instruction)

    # Create a summary of the refinement process
    evolution_prompt = f"""
    Summarize how this solution evolved through iterations:

    Starting approaches:
    {initial_solutions[0][:100]}... (score: {memory_buffer[0]['score']})
    {initial_solutions[1][:100]}... (score: {memory_buffer[1]['score']})
    {initial_solutions[2][:100]}... (score: {memory_buffer[2]['score']})

    Final solution:
    {final_solution}

    Provide insights on how the solution improved across iterations.
    """

    evolution_summary = call_llm(evolution_prompt, system_instruction)

    return f"{final_solution}\n\n=== Solution Evolution Summary ===\n{evolution_summary}"

def pattern_combination_guide() -> str:
    """
    Provide a guide for effectively combining multiple LLM interaction patterns.

    Uses no examples to focus on the pure concept.
    """
    system_instruction = "You are a system design expert specializing in LLM interaction patterns."

    prompt = """
    Provide a guide for effectively combining multiple LLM interaction patterns.

    Focus on:
    1. Which patterns work well together and why
    2. Specific implementation considerations for combinations
    3. When to use different combinations
    4. How to manage complexity in combined patterns

    Structure your guide with clear sections and practical advice.
    """

    return call_llm(prompt, system_instruction)

def pattern_adaptation_guide() -> str:
    """
    Provide a guide for adapting LLM interaction patterns to specific contexts.

    Uses no examples to focus on the pure concept.
    """
    system_instruction = "You are a prompt engineering expert specializing in LLM customization."

    prompt = """
    Provide a guide for adapting LLM interaction patterns to specific contexts.

    Cover:
    1. How to customize prompts for different domains
    2. How to adjust pattern complexity based on task requirements
    3. How to incorporate domain-specific knowledge into patterns
    4. How to evaluate and iterate on pattern adaptations

    Structure your guide with clear sections and actionable techniques.
    """

    return call_llm(prompt, system_instruction)

def pattern_usage_example() -> str:
    """
    Provide a concrete example of adapting and combining LLM interaction patterns.

    Uses 1 detailed example to demonstrate the approach.
    """
    system_instruction = "You are an LLM application designer specializing in practical implementations."

    prompt = """
    Provide a detailed example showing how to adapt and combine LLM interaction patterns for a specific task.

    For this example, demonstrate how you would solve this task:
    "Analyzing a dataset of customer reviews to identify product improvement opportunities"

    Show:
    1. How you would select appropriate patterns
    2. How you would adapt each pattern to the specific domain
    3. How you would combine patterns into a cohesive workflow
    4. Sample code and prompts for key steps

    Make your example concrete, practical, and reusable.
    """

    return call_llm(prompt, system_instruction)

def usage_example() -> str:
    """
    Provide a comprehensive example of effectively combining multiple LLM interaction patterns.

    Uses a single detailed example to demonstrate complex pattern combinations for general applications.
    """
    system_instruction = "You are an expert in LLM pattern design who creates sophisticated solutions by combining techniques."

    prompt = """
    Provide a detailed example of how to effectively combine multiple LLM interaction patterns to solve complex problems.

    # Example: Combining Multiple Patterns for Advanced Problem Solving

    ## Original Challenge
    Creating a system that can analyze complex text, identify key insights, and generate well-reasoned recommendations.

    ## Pattern Selection and Combination Strategy

    1. Start with Feature Extraction to identify key elements:
    ```python
    # Extract key information from input text
    extraction_prompt = f'''
    Analyze this text and extract key features:

    {input_text}

    Focus specifically on:
    - Main entities and their attributes
    - Relationships between entities
    - Explicit and implicit constraints
    - Quantitative data points
    - Key objectives and success criteria

    For each feature, explain why it's significant for the analysis.
    '''

    extracted_features = call_llm(extraction_prompt, system_instruction="You are a precise information extraction specialist.")
    ```

    2. Apply Multi-Perspective Analysis with domain experts:
    ```python
    # Generate analyses from different expert perspectives
    perspectives = ["data_analyst", "domain_expert", "strategic_advisor"]
    perspective_analyses = []

    for perspective in perspectives:
        perspective_prompt = f'''
        As a {perspective}, analyze this situation:

        Input text: {input_text}

        Key features identified:
        {extracted_features}

        Provide a thorough analysis focusing on aspects a {perspective} would prioritize.
        Highlight insights that might be missed by other perspectives.
        '''

        analysis = call_llm(perspective_prompt, 
                           system_instruction=f"You are an expert {perspective} with deep experience in this field.")
        perspective_analyses.append({"perspective": perspective, "analysis": analysis})

    # Synthesize the perspectives
    synthesis_prompt = f'''
    Combine these different expert analyses into a comprehensive understanding:

    {json.dumps(perspective_analyses, indent=2)}

    Identify:
    - Where the perspectives agree and disagree
    - Complementary insights that build on each other
    - Points of tension that require further investigation

    Create a unified analysis that leverages the strengths of each perspective.
    '''

    unified_analysis = call_llm(synthesis_prompt, system_instruction="You are a synthesis specialist.")
    ```

    3. Implement Chain-of-Thought with Self-Consistency:
    ```python
    # Generate multiple reasoning chains toward recommendations
    reasoning_paths = []

    for i in range(3):  # Generate 3 different reasoning paths
        reasoning_prompt = f'''
        Based on this unified analysis:
        {unified_analysis}

        Think step-by-step toward recommendation{i+1}.
        Focus on a different priority or approach than previous reasoning paths.

        Step 1: Identify key challenges and opportunities
        Step 2: Evaluate potential approaches
        Step 3: Consider implementation requirements
        Step 4: Assess risks and mitigations
        Step 5: Develop specific recommendations
        '''

        reasoning = call_llm(reasoning_prompt, 
                            system_instruction="You are a methodical problem solver who thinks step by step.")
        recommendations = extract_recommendations(reasoning)
        reasoning_paths.append({"reasoning": reasoning, "recommendations": recommendations})

    # Evaluate consistency across reasoning paths
    consistency_prompt = f'''
    Analyze these different reasoning approaches:
    {json.dumps(reasoning_paths, indent=2)}

    For each key recommendation:
    - Is it supported by multiple reasoning paths?
    - Are there contradictions between different paths?
    - Which path provides the strongest justification?

    Determine the most robust recommendations with their supporting rationale.
    '''

    consistent_recommendations = call_llm(consistency_prompt, 
                                        system_instruction="You are a critical evaluator.")
    ```

    4. Add Verification and Debate for rigorous testing:
    ```python
    # Simulate debate to stress-test recommendations
    debate_prompt = f'''
    Critique these recommendations from multiple perspectives:
    {consistent_recommendations}

    Perspective 1: Implementation Feasibility
    - What practical challenges might arise?
    - Are there resource or technical constraints?
    - How realistic is the timeline?

    Perspective 2: Potential Downsides
    - What negative outcomes might occur?
    - Are there ethical concerns?
    - What stakeholders might be adversely affected?

    Perspective 3: Alternatives Analysis
    - What alternative approaches weren't considered?
    - Are there simpler solutions?
    - What approaches have worked in similar situations?
    '''

    critique = call_llm(debate_prompt, system_instruction="You are a critical challenger.")

    # Refine recommendations based on critique
    for attempt in range(max_refinement_attempts):
        refinement_prompt = f'''
        Refine these recommendations based on critical feedback:

        Original recommendations:
        {consistent_recommendations}

        Critical feedback:
        {critique}

        Provide improved recommendations that address the valid concerns while
        maintaining the core value. Be specific about:
        - How each concern is addressed
        - What trade-offs are being made
        - Why this represents an improvement
        '''

        refined_recommendations = call_llm(refinement_prompt, 
                                         system_instruction="You are a solution refiner.")

        # Verify improvements
        verification_prompt = f'''
        Verify if these refined recommendations properly address the previous critiques:

        Original recommendations:
        {consistent_recommendations}

        Critiques:
        {critique}

        Refined recommendations:
        {refined_recommendations}

        For each major critique, indicate:
        - ADDRESSED: How the refinement addresses it
        - PARTIALLY ADDRESSED: What aspects still need work
        - NOT ADDRESSED: Why the critique wasn't adequately addressed

        Overall verification: Are the refined recommendations an improvement?
        '''

        verification = call_llm(verification_prompt, 
                               system_instruction="You are a verification specialist.")

        if "IMPROVEMENT: YES" in verification:
            break

        # Update critique for next refinement iteration
        critique = extract_unaddressed_critiques(verification)
    ```

    5. Final Synthesis with Best-of-N Selection:
    ```python
    # Generate multiple final versions
    final_versions = []

    for i in range(3):
        final_prompt = f'''
        Create a final recommendation report that integrates:

        1. The key insights from the unified analysis:
        {unified_analysis}

        2. The consistent recommendations from multiple reasoning paths:
        {consistent_recommendations}

        3. The refinements based on critical feedback:
        {refined_recommendations}

        Format {i+1}: {["concise executive summary", "detailed analysis", "action-oriented plan"][i]}

        Focus on creating a {["strategic", "comprehensive", "practical"][i]} set of recommendations.
        '''

        final_version = call_llm(final_prompt, system_instruction="You are a recommendation specialist.")

        # Evaluate version quality
        evaluation_prompt = f'''
        Evaluate this recommendation report on:
        - Clarity (1-10)
        - Comprehensiveness (1-10)
        - Actionability (1-10)
        - Persuasiveness (1-10)
        - Logical consistency (1-10)

        Recommendation report:
        {final_version}

        Provide numerical scores and brief justifications.
        '''

        evaluation = call_llm(evaluation_prompt, system_instruction="You are a quality evaluator.")
        scores = extract_scores(evaluation)

        final_versions.append({
            "version": final_version,
            "evaluation": evaluation,
            "total_score": sum(scores.values())
        })

    # Select best version
    final_versions.sort(key=lambda x: x["total_score"], reverse=True)
    best_version = final_versions[0]["version"]
    ```

    ## Key Integration Points
    - Feature Extraction provides structured input for Multi-Perspective Analysis
    - Multi-Perspective Analysis feeds unified context to Chain-of-Thought
    - Self-Consistency ensures robustness of reasoning paths
    - Debate and Verification rigorously test and improve recommendations
    - Best-of-N Selection optimizes the final output format and content

    ## Benefits of Pattern Combination
    - Each pattern addresses different aspects of the complex problem
    - Later patterns build upon the outputs of earlier patterns
    - Verification catches issues that might be missed in a linear approach
    - Multiple perspectives create more robust solutions
    - Self-consistency reduces likelihood of spurious reasoning

    This example demonstrates how combining patterns creates a solution pipeline that's much more powerful than any single pattern alone, particularly for complex analytical and recommendation tasks.
    """

    return call_llm(prompt, system_instruction)

def test_time_training(problem_with_examples: str, max_iterations: int = 5) -> str:
    """
    Implement test-time training pattern: develop a hypothesis, test it on training examples,
    refine based on results, and apply to the test case only after verification.

    This pattern is essential when multiple examples demonstrate the same underlying pattern 
    that must be discovered and applied to a test case.

    Uses varied examples to demonstrate how incorrect hypotheses are detected and refined.
    """
    system_instruction = "You are a pattern recognition specialist who rigorously tests hypotheses against training examples."

    # Extract examples and identify test case
    extraction_prompt = f"""
    Extract the training examples and test case from this problem:

    {problem_with_examples}

    Format your response as follows:

    TRAINING_EXAMPLES:
    Example 1:
    Input: [first training input]
    Output: [first training output]

    Example 2:
    Input: [second training input]
    Output: [second training output]

    [Continue for all training examples]

    TEST_CASE:
    Input: [test input]

    DOMAIN:
    [problem domain]

    Be precise and comprehensive in extracting all information.
    """

    extraction_response = call_llm(extraction_prompt, system_instruction)

    # Parse the structured response
    training_examples = []
    test_case = {}
    domain = "unknown"

    # Extract training examples
    if "TRAINING_EXAMPLES:" in extraction_response:
        training_section = extraction_response.split("TRAINING_EXAMPLES:")[1].split("TEST_CASE:")[0].strip()
        example_blocks = re.split(r'\n\s*\n', training_section)

        for block in example_blocks:
            if not block.strip():
                continue

            input_match = re.search(r'Input: (.*?)(?:\n|$)', block)
            output_match = re.search(r'Output: (.*?)(?:\n|$)', block)

            if input_match and output_match:
                training_examples.append({
                    "input": input_match.group(1).strip(),
                    "output": output_match.group(1).strip()
                })

    # Extract test case
    if "TEST_CASE:" in extraction_response:
        test_section = extraction_response.split("TEST_CASE:")[1].split("DOMAIN:")[0].strip()
        input_match = re.search(r'Input: (.*?)(?:\n|$)', test_section)

        if input_match:
            test_case = {"input": input_match.group(1).strip()}

    # Extract domain
    if "DOMAIN:" in extraction_response:
        domain = extraction_response.split("DOMAIN:")[1].strip()

    # Generate initial hypothesis based on only the first example
    first_example_prompt = f"""
    Examine this SINGLE training example and formulate an initial hypothesis about the pattern:

    Example:
    Input: {training_examples[0]['input']}
    Output: {training_examples[0]['output']}

    Based ONLY on this example, what rule or pattern might explain it?
    Provide a detailed hypothesis about the transformation from input to output.
    """

    initial_hypothesis = call_llm(first_example_prompt, system_instruction)

    # Testing and refinement loop
    current_hypothesis = initial_hypothesis
    hypothesis_validated = False

    for iteration in range(max_iterations):
        # Test the hypothesis against ALL training examples
        testing_prompt = f"""
        Test this hypothesis against ALL of these training examples:

        Hypothesis:
        {current_hypothesis}

        Training Examples:
        {chr(10).join([f"Example {i+1}:\nInput: {ex['input']}\nOutput: {ex['output']}" for i, ex in enumerate(training_examples)])}

        Example of thorough testing:

        Hypothesis: In the sequence, each number is doubled to get the next number.

        Training Examples:
        Example 1:
        Input: 2, 4, 8, 16
        Output: 32

        Example 2:
        Input: 5, 25, 125, 625
        Output: 3125

        Example 3:
        Input: 1, 1, 1, 1
        Output: 1

        Testing on Example 1: "2, 4, 8, 16" → expected "32"
        Analysis: If we double the last number: 16 × 2 = 32
        Result: ✓ Matches expected output "32"

        Testing on Example 2: "5, 25, 125, 625" → expected "3125"
        Analysis: If we double the last number: 625 × 2 = 1250
        Result: ✗ Does NOT match expected output "3125"

        Testing on Example 3: "1, 1, 1, 1" → expected "1"
        Analysis: If we double the last number: 1 × 2 = 2
        Result: ✗ Does NOT match expected output "1"

        Overall: The hypothesis fails on Examples 2 and 3. It needs refinement.

        Now, test your hypothesis on EACH training example:
        1. Apply the hypothesized rule to the input
        2. Check if the result matches the expected output
        3. Provide a detailed step-by-step analysis for each example

        Conclude whether your hypothesis explains ALL training examples or needs refinement.
        """

        test_results = call_llm(testing_prompt, system_instruction)

        # Check if hypothesis is validated
        validation_check = "correctly explains all" in test_results.lower() or "hypothesis is valid" in test_results.lower()
        validation_check = validation_check and not ("fails" in test_results.lower() or "does not match" in test_results.lower())

        if validation_check:
            hypothesis_validated = True
            break

        # Refine hypothesis based on test results
        refinement_prompt = f"""
        Your hypothesis needs refinement based on the test results:

        Current Hypothesis:
        {current_hypothesis}

        Test Results:
        {test_results}

        Example of good refinement:

        Original Hypothesis: In the sequence, each number is doubled to get the next number.

        Test Results: The hypothesis works for Example 1 ("2, 4, 8, 16" → "32") but fails on Examples 2 and 3:
        - For "5, 25, 125, 625" → expected "3125", doubling gives 1250, which is wrong
        - For "1, 1, 1, 1" → expected "1", doubling gives 2, which is wrong

        Refined Hypothesis: Each number in the sequence is multiplied by the first number in the sequence to get the next number.
        Testing:
        - Example 1: First number is 2. Last number is 16. 16 × 2 = 32 ✓
        - Example 2: First number is 5. Last number is 625. 625 × 5 = 3125 ✓
        - Example 3: First number is 1. Last number is 1. 1 × 1 = 1 ✓

        Now, refine your hypothesis to address the failures identified in the test results.
        Analyze patterns across ALL examples. Look for a single rule that works for EVERY case.
        Be creative in considering alternative patterns that might explain all examples.
        """

        current_hypothesis = call_llm(refinement_prompt, system_instruction)

    # Apply validated hypothesis to the test case
    if not hypothesis_validated:
        # Force a final hypothesis refinement if not validated after max iterations
        final_refinement_prompt = f"""
        After multiple iterations, we need a final refined hypothesis that best explains all training examples:

        Training Examples:
        {chr(10).join([f"Example {i+1}:\nInput: {ex['input']}\nOutput: {ex['output']}" for i, ex in enumerate(training_examples)])}

        Current Hypothesis:
        {current_hypothesis}

        Analyze all examples together. Look for patterns across different sequences:
        - How does the first number relate to the pattern?
        - Is each sequence following its own internal logic?
        - What single rule could explain the transformation in EVERY example?

        Provide your best hypothesis that correctly explains ALL training examples.
        Test it against each example before submitting.
        """

        current_hypothesis = call_llm(final_refinement_prompt, system_instruction)

    # Apply the hypothesis to the test case
    application_prompt = f"""
    Now that we have a validated hypothesis, apply it to the test case:

    Hypothesis:
    {current_hypothesis}

    Test Case:
    Input: {test_case['input']}

    Example of detailed application:

    Hypothesis: Each number in the sequence is multiplied by the first number in the sequence to get the next number.

    Test Case: "3, 9, 27, 81"
    Analysis: 
    1. The first number in the sequence is 3
    2. The last number in the sequence is 81
    3. Applying our rule: 81 × 3 = 243

    Therefore, the next number is 243.

    Now, apply your hypothesis to the test case:
    1. Show your detailed step-by-step application of the rule
    2. Verify each step for accuracy
    3. Provide the final answer

    Be thorough and precise in your application.
    """

    application_result = call_llm(application_prompt, system_instruction)

    # Generate a comprehensive solution that explains the process
    final_solution_prompt = f"""
    Create a comprehensive solution that explains the entire test-time training process:

    Problem:
    {problem_with_examples}

    Initial Hypothesis (based on first example only):
    {initial_hypothesis}

    Testing and Refinement Process:
    {test_results}

    Final Validated Hypothesis:
    {current_hypothesis}

    Application to Test Case:
    {application_result}

    Provide a structured solution with these sections:

    1. INITIAL PATTERN RECOGNITION: How we formed our first hypothesis looking at only one example

    2. HYPOTHESIS TESTING: How we tested this hypothesis against ALL examples and discovered it didn't work for all cases

    3. HYPOTHESIS REFINEMENT: How we refined our thinking to find a rule that works across ALL examples

    4. VALIDATION: How we verified our refined hypothesis against all training examples

    5. APPLICATION: How we applied the validated rule to the test case

    6. ADVANTAGES OF TEST-TIME TRAINING: Explain how this approach prevented errors by confirming our hypothesis against multiple examples before submission

    7. FINAL ANSWER: The clear, concise answer to the test case

    Emphasize how the availability of multiple training examples allowed us to test and refine our hypotheses, preventing incorrect submissions.
    """

    return call_llm(final_solution_prompt, system_instruction)
```MULTI-EXAMPLE PROMPTING GUIDANCE:
        1. CRITICAL: Use MULTIPLE examples (2-5) in EVERY LLM prompt, not just one
        2. Vary the number of examples based on task complexity - more complex tasks need more examples
        3. Select diverse examples that showcase different patterns and edge cases
        4. Structure your few-shot examples to demonstrate clear step-by-step reasoning
        5. Consider using both "easy" and "challenging" examples to help the LLM learn from contrasts
        6. The collection of examples should collectively cover all key aspects of the problem
        7. When available, use examples from previous iterations that revealed specific strengths or weaknesses.
        8. USE REAL EXAMPLES FROM THE DATASET WHERE POSSIBLE!!

        Example of poor single-example prompting:
        ```python
        def extract_entities(text):
            prompt = f'''
            Extract entities from this text.

            Example:
            Text: John will meet Mary at 3pm on Tuesday.
            Entities: {{"people": ["John", "Mary"], "time": "3pm", "day": "Tuesday"}}

            Text: {text}
            Entities:
            '''
            return call_llm(prompt)
        ```

        Example of effective multi-example prompting:
        ```python
        def extract_entities(text):
            prompt = f'''
            Extract entities from this text.

            Example 1:
            Text: John will meet Mary at 3pm on Tuesday.
            Entities: {{"people": ["John", "Mary"], "time": "3pm", "day": "Tuesday"}}

            Example 2:
            Text: The team needs to submit the report by Friday at noon.
            Entities: {{"people": ["the team"], "time": "noon", "day": "Friday", "object": "report"}}

            Example 3:
            Text: Alex cannot attend the conference from Jan 3-5 due to prior commitments.
            Entities: {{"people": ["Alex"], "event": "conference", "date_range": ["Jan 3-5"], "reason": "prior commitments"}}

            Text: {text}
            Entities:
            '''
            return call_llm(prompt)
        ```

        === DIRECT LLM REASONING APPROACH ===

        CRITICAL: Previous scripts have shown that complex code generation with JSON parsing and multi-step pipelines often 
        leads to errors and low performance. Instead, focus on leveraging the LLM's natural reasoning abilities:

        1. SIMPLIFY YOUR APPROACH:
           - Minimize the number of processing steps - simpler is better
           - Directly use LLM for pattern recognition rather than writing complex code
           - Avoid trying to parse or manipulate JSON manually - pass it as text to the LLM

        2. DIRECT TRANSFORMATION:
           - Instead of trying to extract features and then apply them, use the LLM to do the transformation directly
           - Use examples to teach the LLM the pattern, then have it apply that pattern to new inputs
           - Avoid attempting to write complex algorithmic solutions when pattern recognition will work better

        3. ROBUST ERROR HANDLING:
           - Include multiple approaches in case one fails (direct approach + fallback approach)
           - Use simple validation to check if outputs are in the expected format
           - Include a last-resort approach that will always return something valid

        4. AVOID COMMON PITFALLS:
           - Do NOT attempt to use json.loads() or complex JSON parsing - it often fails
           - Do NOT create overly complex Python pipelines that require perfect indentation
           - Do NOT create functions that generate or execute dynamic code
           - Do NOT create unnecessarily complex data transformations

        5. SUCCESSFUL EXAMPLES:
           - The most successful approaches have used direct pattern matching with multiple examples
           - Scripts with simple validation and fallback approaches perform better
           - Scripts with fewer processing steps have higher success rates
        
        IMPLEMENTATION STRATEGIES:
        1. Maintain a "example bank" of successful and failed examples to select from
        2. Implement n-shot prompting with n=3 as default, but adapt based on performance
        3. For complex tasks, use up to 5 examples; for simpler tasks, 2-3 may be sufficient
        4. Include examples with a range of complexity levels, rather than all similar examples



        VALIDATION AND VERIFICATION GUIDANCE:
        1. CRITICAL: Consider implementing validation loops for EACH key processing step, not just final outputs
        2. Design your system to detect, diagnose, and recover from specific errors. This will help future learnings
        3. For every LLM extraction or generation, add a verification step that checks:
           - Whether the output is well-formed and complete
           - Whether the output is logically consistent with the input
           - Whether all constraints are satisfied
           - If verification fails, send the output back into an earlier part of the pipeline with specific feedback from the error
        4. Add feedback loops that retry failures with specific feedback
        5. Include diagnostic outputs that reveal exactly where failures occur. Add print statements and intermediate outputs such that you can see them later to determine why things are going wrong.
        6. Include capability to trace through execution steps to identify failure points

        Example of pipeline without verification:
        ```python
        def process_question(question):
            entities = extract_entities(question)
            constraints = identify_constraints(question)
            solution = generate_solution(entities, constraints)
            return solution
        ```

        Example of robust pipeline with verification:
        ```python
        def process_question(question, max_attempts=3):
            # Step 1: Extract entities with verification
            entities_result = extract_entities_with_verification(question)
            if not entities_result.get("is_valid"):
                print(f"Entity extraction failed: {entities_result.get('validation_feedback')}")
                return f"Error in entity extraction: {entities_result.get('validation_feedback')}"

            # Step 2: Identify constraints with verification
            constraints_result = identify_constraints_with_verification(question, entities_result["entities"])
            if not constraints_result.get("is_valid"):
                print(f"Constraint identification failed: {constraints_result.get('validation_feedback')}")
                return f"Error in constraint identification: {constraints_result.get('validation_feedback')}"

            # Step 3: Generate solution with verification
            solution_result = generate_solution_with_verification(
                question, 
                entities_result["entities"], 
                constraints_result["constraints"]
            )
            if not solution_result.get("is_valid"):
                print(f"Solution generation failed: {solution_result.get('validation_feedback')}")
                return f"Error in solution generation: {solution_result.get('validation_feedback')}"

            return solution_result["solution"]



        VALIDATION IMPLEMENTATION STRATEGIES:
        1. Create detailed verification functions for each major processing step: this will help us debug
        2. Implement max_attempts limits on all retry loops (typically 3-5 attempts)
        3. Pass specific feedback from verification to subsequent retry attempts
        4. Log all verification failures to help identify systemic issues
        5. Design fallback behaviors when verification repeatedly fails
        6. Crucially, verification should be used to catch errors in the processing pipeline and feed them back into an earlier part of the pipeline for refinement with feedback for a set number of attempts. Verification for its own sake isn't very helpful, especially as the final step.

        

            PREVIOUSLY TRIED APPROACHES (LAST 5 SCRIPTS). YOUR APPROACH MUST BE SUBSTANTIVELY DIFFERENT THAN THESE:
            
PREVIOUSLY TRIED APPROACHES (LAST 5 SCRIPTS):

=== SCRIPT FROM ITERATION 22 (Exploration, ACCURACY: 0.00) ===
Approach: The script solves grid transformation problems by identifying "anchor" values and propagating their influence to neighboring cells using an LLM. The problem is decomposed into identifying anchor values, analyzing neighborhood influence, and transforming the input grid. Three distinct agent roles are implicitly defined within the prompt of the functions: an expert in identifying key values, an expert at analyzing grid transformations, and an expert in applying grid transformations. The script uses `call_llm` to interact with the Gemini LLM. The function calls are structured as follows: `identify_anchor_values` -> `analyze_neighborhood_influence` -> `transform_grid`, with the output of each function serving as input for the subsequent one; regex is used to extract the test input. Overall, the script extracts the test grid, identifies anchor values and their influence using the LLM, then transforms the test grid based on this analysis.

```python
#!/usr/bin/env python
"""This script explores a new approach to solving grid transformation problems by focusing on identifying "anchor" values and their influence on neighboring cells. The hypothesis is that transformations are driven by key "anchor" values, and their proximity determines how other cells change. A neighborhood influence propagation technique will be employed.

This approach differs from previous ones by:

1. Focusing on "anchor" values: The script will find key values that are most frequent in the training examples and apply a transformation based on what happens to their neighborhood
2.  Influence Propagation: The script will find patterns between "anchor" values and how nearby cells change
3. Applying neighborhood change based on influence: A process to extract the test matrix and transform the neighborhood with the identified influence propagations

"""

import os
import re
from typing import List, Dict, Any, Optional, Union

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt."""
    try:
        from google import genai
        from google.genai import types

        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

def identify_anchor_values(question: str) -> str:
    """Identifies anchor values from the training examples."""
    prompt = f"""You are an expert in identifying key values in grid transformations.
    Analyze the training examples in the following question to identify the most frequent values, or "anchor" values, that seem to drive the transformations.

    Example:
    question: === TRAINING EXAMPLES === Example 1: Input Grid: [[1, 2], [3, 4]] Output Grid: [[2, 3], [4, 1]] === TEST INPUT === [[5, 6], [7, 8]] Transform the test input.
    Anchor Values: 1, 2, 3, 4 (all values appear to be equally important).

	question: === TRAINING EXAMPLES === Example 1: Input Grid: [[0, 0], [0, 4]] Output Grid: [[4, 4], [4, 4]] === TEST INPUT === [[0, 0], [0, 0]] Transform the test input.
    Anchor Values: 4 (4 seems to propagate).

    question: {question}
    Anchor Values:"""
    anchor_values = call_llm(prompt)
    return anchor_values

def analyze_neighborhood_influence(question: str, anchor_values: str) -> str:
    """Analyzes how anchor values influence their neighboring cells."""
    prompt = f"""You are an expert at analyzing grid transformations.
    Analyze the training examples in the following question and determine how the identified anchor values influence their neighboring cells in the output grid.

    Example:
    question: === TRAINING EXAMPLES === Example 1: Input Grid: [[0, 0], [0, 4]] Output Grid: [[4, 4], [4, 4]] === TEST INPUT === [[5, 6], [7, 8]] Transform the test input.
    Anchor Values: 4
    Neighborhood Influence: The value '4' seems to propagate to all neighboring cells, replacing their original values.

    question: {question}
    Anchor Values: {anchor_values}
    Neighborhood Influence:"""
    neighborhood_influence = call_llm(prompt)
    return neighborhood_influence

def transform_grid(input_grid: str, anchor_values: str, neighborhood_influence: str) -> str:
    """Transforms the input grid based on anchor values and their neighborhood influence."""
    prompt = f"""You are an expert in applying grid transformations.
    Apply the transformation to the provided input grid, based on the anchor values and their influence on neighboring cells.

    Example:
    input_grid: [[5, 6], [7, 8]]
    anchor_values: 8
    neighborhood_influence: The value '8' seems to shift values left
    Transformed Grid: [[6, 5], [8, 7]]

    input_grid: {input_grid}
    anchor_values: {anchor_values}
    neighborhood_influence: {neighborhood_influence}
    Transformed Grid:"""
    transformed_grid = call_llm(prompt)
    return transformed_grid

def main(question: str) -> str:
    """Main function to solve the problem."""
    try:
        # 1. Identify anchor values
        anchor_values = identify_anchor_values(question)

        # 2. Analyze neighborhood influence
        neighborhood_influence = analyze_neighborhood_influence(question, anchor_values)

        # 3. Extract the test input grid
        test_input_match = re.search(r"=== TEST INPUT ===\n(.*?)\nTransform", question, re.DOTALL)
        if not test_input_match:
            return "Error: Could not find TEST INPUT in the question."
        input_grid = test_input_match.group(1).strip()

        # 4. Transform the grid
        transformed_grid = transform_grid(input_grid, anchor_values, neighborhood_influence)

        return transformed_grid
    except Exception as e:
        return f"An error occurred: {e}"
```

=== SCRIPT FROM ITERATION 21 (Exploitation, ACCURACY: 0.00) ===
Approach: The script solves grid transformation problems using LLM-driven rule extraction, refinement, and application. It employs a chain-of-thought approach, where the problem is decomposed into extracting a transformation rule, refining it, and then applying it to a test input grid. Three LLM agent roles are used: an expert grid transformation expert, an expert grid transformation agent for refinement, and another expert grid transformation agent for applying the rule.

The core functions are `rule_extraction`, `refine_rule`, and `apply_rule`, which sequentially use the LLM to extract, refine, and apply transformation rules. `call_llm` is used by all three functions to interact with the Gemini LLM. The `main` function orchestrates the workflow: `rule_extraction` extracts a rule from the question, `refine_rule` corrects any errors in the extracted rule, and `apply_rule` transforms the input grid using the refined rule, with regex used to extract the test input grid from the question.

```python
#!/usr/bin/env python
"""
Refines iteration 9 and 15 to solve grid transformation problems through structured rule extraction, refinement, and application.
Addresses primary failure modes: pattern extraction and generalization. Incorporates iterative refinement with specific feedback.
Uses direct LLM reasoning approach to minimize parsing errors. Employs chain-of-thought reasoning and robust error handling.
"""

import os
import re
from typing import List, Dict, Any, Optional, Union

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. DO NOT deviate from this example template or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

def rule_extraction(question: str) -> str:
    """
    Extract a transformation rule in structured format using LLM reasoning.
    Includes an example to guide the LLM.
    """
    prompt = f"""
    You are an expert grid transformation expert. Analyze the provided question and extract the transformation rule.

    Example:
    question:
    === TRAINING EXAMPLES ===
    Example 1:
    Input Grid: [[1, 2], [3, 4]]
    Output Grid: [[4, 3], [2, 1]]
    === TEST INPUT ===
    [[5, 6], [7, 8]]
    Transform the test input according to the pattern shown in the training examples.

    Extracted Rule: The input grid is flipped horizontally and vertically. Specifically, output[0][0] = input[1][1], output[0][1] = input[1][0], output[1][0] = input[0][1], and output[1][1] = input[0][0].

    question: {question}
    Extracted Rule:
    """
    extracted_rule = call_llm(prompt)
    return extracted_rule

def refine_rule(question: str, extracted_rule: str) -> str:
  """Refine the extracted rule, to attempt to correct errors. Includes example."""
  prompt = f"""
  You are an expert grid transformation agent. Refine the following extracted rule: {extracted_rule}

  Example:
    question:
    === TRAINING EXAMPLES ===
    Example 1:
    Input Grid: [[1, 2], [3, 4]]
    Output Grid: [[4, 3], [2, 1]]
    === TEST INPUT ===
    [[5, 6], [7, 8]]
    Transform the test input according to the pattern shown in the training examples.

  Extracted Rule: The input grid is flipped horizontally and vertically.
  Refined Rule: The input grid is flipped horizontally and vertically. Specifically, output[0][0] = input[1][1], output[0][1] = input[1][0], output[1][0] = input[0][1], and output[1][1] = input[0][0].

  Refine the rule based on the question: {question}. Return the refined rule.
  """
  refined_rule = call_llm(prompt)
  return refined_rule

def apply_rule(input_grid: str, transformation_rule: str) -> str:
    """Apply the refined transformation rule to the test input. Includes example."""
    prompt = f"""
    You are an expert grid transformation agent. Apply the rule to the input_grid.

    input_grid: {input_grid}
    transformation_rule: {transformation_rule}

    Example:
    transformation_rule: The input grid is flipped horizontally and vertically. Specifically, output[0][0] = input[1][1], output[0][1] = input[1][0], output[1][0] = input[0][1], and output[1][1] = input[0][0].
    input_grid: [[5, 6], [7, 8]]
    Output: [[8, 7], [6, 5]]

    Apply the rule to the grid and return the transformed grid. Provide ONLY the grid.
    """
    transformed_grid = call_llm(prompt)
    return transformed_grid

def main(question: str) -> str:
    """Main function to solve the problem. Includes robust error handling."""
    try:
        # 1. Extract the transformation rule
        extracted_rule = rule_extraction(question)
        if "Error" in extracted_rule:
            return f"Rule Extraction Error: {extracted_rule}"

        # 2. Refine the transformation rule, to attempt to correct errors
        refined_rule = refine_rule(question, extracted_rule)
        if "Error" in refined_rule:
            return f"Rule Refinement Error: {refined_rule}"

        # 3. Extract the test input grid
        test_input_match = re.search(r"=== TEST INPUT ===\n(.*?)\nTransform", question, re.DOTALL)
        if not test_input_match:
            return "Error: Could not find TEST INPUT in the question."
        input_grid = test_input_match.group(1).strip()

        # 4. Apply the refined transformation rule to the test input grid
        transformed_grid = apply_rule(input_grid, refined_rule)
        if "Error" in transformed_grid:
            return f"Rule Application Error: {transformed_grid}"

        return transformed_grid
    except Exception as e:
        print(f"An error occurred: {e}")
        return f"An error occurred: {e}"
```

=== SCRIPT FROM ITERATION 20 (Exploration, ACCURACY: 0.00) ===
Approach: The script addresses grid transformation problems by generating and validating multiple hypotheses using the Gemini LLM. It decomposes the problem into hypothesis generation, testing, and application, assigning the LLM the roles of an expert in analyzing grid transformations and applying rules. The `generate_hypotheses` function creates multiple potential transformation rules, `test_hypotheses` verifies them against training data, and `apply_transformation` applies the best validated rule to the test input. The `call_llm` function is used by each function to send requests to the Gemini LLM. The overall workflow involves generating hypotheses, testing them, selecting the best one, extracting the test input, and applying the transformation to generate the final output.

```python
#!/usr/bin/env python
"""This script explores a novel approach to solving grid transformation problems by focusing on iterative hypothesis generation and validation using a chain-of-thought with explicit testing of each hypothesis.

This is different from previous approaches by:

1.  Using the training examples to GENERATE multiple potential hypotheses about the transformation rule. Previous systems primarily used rules that were derived from prompt engineering or direct information extraction. This approach will derive the rule by explicitly asking for multiple possibilities.
2.  TESTING these hypotheses systematically against the examples.
3.  Choosing the hypothesis that best fits ALL examples.
4.  Applying the selected and tested hypotheses to the test input to generate the transformed grid.

This approach is designed to improve robustness and generalization by explicitly exploring and validating different potential rules, rather than relying on a single, potentially flawed, initial extraction. This relies on a direct LLM reasoning approach.
"""

import os
import re
from typing import List, Dict, Any, Optional, Union

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt."""
    try:
        from google import genai
        from google.genai import types

        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

def generate_hypotheses(question: str, num_hypotheses: int = 3) -> List[str]:
    """Generates multiple hypotheses about the transformation rule from the training examples."""
    prompt = f"""You are an expert at analyzing grid transformation problems.
    Analyze the training examples in the provided question and generate {num_hypotheses} different hypotheses about the transformation rule.
    Consider various possibilities, including: shifting elements, replicating patterns, value-based modifications, and spatial relationships.
    Focus on generating logically distinct and plausible hypotheses.

    Example:
    question: === TRAINING EXAMPLES === Example 1: Input Grid: [[1, 2], [3, 4]] Output Grid: [[4, 3], [2, 1]] === TEST INPUT === [[5, 6], [7, 8]] Transform the test input.
    Hypotheses:
    1. The grid is flipped horizontally and vertically.
    2. The grid is rotated 180 degrees.
    3. The value at position [i][j] is swapped with the value at position [1-i][1-j].

    question: {question}
    Hypotheses:
    """
    hypotheses = call_llm(prompt)
    # Splitting the response into individual hypotheses for later testing
    return hypotheses.split("\n")

def test_hypotheses(question: str, hypotheses: List[str]) -> Dict[str, bool]:
    """Tests each hypothesis against the training examples and returns a dictionary of results."""
    prompt = f"""You are an expert at verifying hypotheses about grid transformations.
    Test each of the following hypotheses against the training examples provided in the question.
    For each hypothesis, determine whether it correctly explains the transformation in ALL training examples.

    Example:
    question: === TRAINING EXAMPLES === Example 1: Input Grid: [[1, 2], [3, 4]] Output Grid: [[4, 3], [2, 1]] === TEST INPUT === [[5, 6], [7, 8]] Transform the test input.
    Hypotheses:
    1. The grid is flipped horizontally and vertically.
    2. The grid is rotated 180 degrees.
    3. The value at position [i][j] is swapped with the value at position [1-i][1-j].
    Results:
    1. The grid is flipped horizontally and vertically. - Correct
    2. The grid is rotated 180 degrees. - Correct
    3. The value at position [i][j] is swapped with the value at position [1-i][1-j]. - Correct

    question: {question}
    Hypotheses:
    {chr(10).join([f"{i+1}. {h}" for i, h in enumerate(hypotheses)])}
    Results:
    """
    results = call_llm(prompt)
    # Parsing to return a dictionary of results for easy access and testing.
    results_dict = {}
    for i, hypothesis in enumerate(hypotheses):
        try:
            result_string = results.split(str(i+1) + ".")[1].split("\n")[0]
            results_dict[hypothesis] = "Correct" in result_string
        except IndexError:
            results_dict[hypothesis] = False  # Handle cases where the hypothesis is not found in the results
    return results_dict

def apply_transformation(input_grid: str, transformation_rule: str) -> str:
    """Applies the transformation rule to the test input."""
    prompt = f"""You are an expert in applying grid transformations.
    Apply the following transformation rule to the input grid.

    Input grid: {input_grid}
    Transformation rule: {transformation_rule}

    Example Application:
    Transformation rule: The grid is flipped horizontally and vertically.
    Input grid: [[5, 6], [7, 8]]
    Output: [[8, 7], [6, 5]]

    Apply the rule and return ONLY the transformed grid.
    """
    transformed_grid = call_llm(prompt)
    return transformed_grid

def main(question: str) -> str:
    """Main function to solve the problem."""
    try:
        # 1. Generate hypotheses about the transformation rule
        hypotheses = generate_hypotheses(question)

        # 2. Test the hypotheses against the training examples
        results = test_hypotheses(question, hypotheses)

        # 3. Select the best hypothesis (the one that correctly explains all examples)
        best_hypothesis = None
        for hypothesis, correct in results.items():
            if correct:
                best_hypothesis = hypothesis
                break

        if not best_hypothesis:
            return "Error: No hypothesis could be validated from the set. Unable to generate a useful output."

        # 4. Extract the test input grid
        test_input_match = re.search(r"=== TEST INPUT ===\n(.*?)\nTransform", question, re.DOTALL)
        if not test_input_match:
            return "Error: Could not find TEST INPUT in the question."
        input_grid = test_input_match.group(1).strip()

        # 5. Apply the transformation rule to the test input grid
        transformed_grid = apply_transformation(input_grid, best_hypothesis)

        return transformed_grid
    except Exception as e:
        print(f"An error occurred: {e}")
        return f"An error occurred: {e}"
```

=== SCRIPT FROM ITERATION 19 (Exploitation, ACCURACY: 0.00) ===
Approach: The script uses a chain-of-thought approach with LLMs to transform input grids based on patterns observed in training examples. It decomposes the problem into three stages: rule extraction, rule refinement, and rule application, each handled by a dedicated function that acts as an agent with a specific role. The main functions used include `rule_extraction` which extracts the transformation rule, `refine_rule` which refines the extracted rule for accuracy, `apply_rule` which applies the refined rule to the input grid, `call_llm` which is used to call the Gemini LLM, and `main` which orchestrates the entire process. The overall workflow involves extracting a rule from examples, refining it, and then applying it to a test input grid to generate the transformed output.

```python
#!/usr/bin/env python
"""
Refines the grid transformation approach focusing on structured rule extraction and refinement,
incorporating verification loops and detailed examples in LLM prompts.
"""

import os
import re
from typing import List, Dict, Any, Optional, Union

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response.
    DO NOT modify this or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )
        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

def rule_extraction(question: str, max_attempts=3) -> str:
    """Extract transformation rule with example and verification."""
    prompt = f"""
    You are an expert grid transformation analyst. Extract a rule from the examples.

    Example:
    question: === TRAINING EXAMPLES === Example 1: Input Grid: [[1, 2], [3, 4]] Output Grid: [[4, 3], [2, 1]] === TEST INPUT === [[5, 6], [7, 8]] Transform the test input according to the pattern shown in the training examples.
    Extracted Rule: {{"description": "2x2 matrix", "operations": "flip horizontal and vertical", "output_description": "flipped matrix"}}

    question: {question}
    Extracted Rule:
    """
    for attempt in range(max_attempts):
        extracted_rule = call_llm(prompt)
        if extracted_rule:  # Basic check for non-empty response
            return extracted_rule
        print(f"Rule extraction failed, attempt {attempt + 1}/{max_attempts}")
    return "Error: Rule extraction failed after multiple attempts."

def refine_rule(question: str, extracted_rule: str, max_attempts=3) -> str:
    """Refine rule with example, verification and descriptive output."""
    prompt = f"""
    You are an expert at refining rules. Refine this rule based on examples from the question.

    Example:
    question: === TRAINING EXAMPLES === Example 1: Input Grid: [[1, 2], [3, 4]] Output Grid: [[4, 3], [2, 1]] === TEST INPUT === [[5, 6], [7, 8]] Transform the test input according to the pattern shown in the training examples.
    Extracted Rule: {{"description": "2x2 matrix", "operations": "flip horizontal and vertical", "output_description": "flipped matrix"}}
    Refined Rule: {{"description": "2x2 matrix", "operations": "output[0][0] = input[1][1], output[0][1] = input[1][0], output[1][0] = input[0][1], output[1][1] = input[0][0]", "output_description": "flipped matrix"}}

    question: {question}
    Extracted Rule: {extracted_rule}
    Refined Rule:
    """
    for attempt in range(max_attempts):
        refined_rule = call_llm(prompt)
        if refined_rule:
            return refined_rule
        print(f"Rule refinement failed, attempt {attempt + 1}/{max_attempts}")
    return "Error: Rule refinement failed after multiple attempts."

def apply_rule(input_grid: str, transformation_rule: str, max_attempts=3) -> str:
    """Apply rule with example and verification."""
    prompt = f"""
    Apply the rule to the input grid. You are an expert grid transformation agent.

    Example:
    transformation_rule: {{"description": "2x2 matrix", "operations": "output[0][0] = input[1][1], output[0][1] = input[1][0], output[1][0] = input[0][1], output[1][1] = input[0][0]", "output_description": "flipped matrix"}}
    input_grid: [[5, 6], [7, 8]]
    Output: [[8, 7], [6, 5]]

    input_grid: {input_grid}
    transformation_rule: {transformation_rule}
    Output:
    """
    for attempt in range(max_attempts):
        transformed_grid = call_llm(prompt)
        if transformed_grid:
            return transformed_grid
        print(f"Rule application failed, attempt {attempt + 1}/{max_attempts}")
    return "Error: Rule application failed after multiple attempts."

def main(question: str) -> str:
    """Main function with improved error handling."""
    try:
        extracted_rule = rule_extraction(question)
        if "Error:" in extracted_rule:
            return extracted_rule

        refined_rule = refine_rule(question, extracted_rule)
        if "Error:" in refined_rule:
            return refined_rule

        test_input_match = re.search(r"=== TEST INPUT ===\n(.*?)\nTransform", question, re.DOTALL)
        if not test_input_match:
            return "Error: Could not find TEST INPUT in the question."
        input_grid = test_input_match.group(1).strip()

        transformed_grid = apply_rule(input_grid, refined_rule)
        if "Error:" in transformed_grid:
            return transformed_grid

        return transformed_grid
    except Exception as e:
        print(f"An error occurred: {e}")
        return f"An error occurred: {str(e)}"
```

=== SCRIPT FROM ITERATION 18 (Exploration, ACCURACY: 0.33) ===
Approach: This script addresses grid transformation problems by identifying the transformation pattern, applying it, and verifying the result using LLMs. The problem is decomposed into identifying the transformation type, applying the transformation, and function testing. The agent roles include an expert in recognizing grid transformation patterns, an expert in applying grid transformations, and a grid transformation expert for testing. The script uses `call_llm` to interact with the Gemini LLM, `identify_transformation_type` to determine the grid transformation, `apply_transformation` to apply the identified transformation, and `function_test` to verify the result. The workflow is: `main` calls `identify_transformation_type` to determine the transformation, extracts the input grid, calls `apply_transformation` to transform the grid, and then calls `function_test` to verify the output.

```python
#!/usr/bin/env python
"""This script explores a new approach to solving grid transformation problems by using a pattern-based identification and transformation strategy. This contrasts previous approaches that focus on LLM rule extraction.

This approach differs from previous ones by:

1.  Identifying and categorizing common grid transformation patterns (shift, rotate, fill, etc).
2.  Using targeted prompting to identify the appropriate pattern.
3.  Applying LLM based rule transformation with an LLM to carry out the pattern transformation based on previous context.
4.  Using function test and verification steps to ensure a good output by checking against the examples.
"""

import os
import re
from typing import List, Dict, Any, Optional, Union

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt."""
    try:
        from google import genai
        from google.genai import types

        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

def identify_transformation_type(question: str) -> str:
    """Identifies the type of transformation required."""
    prompt = f"""You are an expert in recognizing grid transformation patterns.
    Identify the primary transformation type in the following question.

    Example:
    question: === TRAINING EXAMPLES === Example 1: Input Grid: [[1, 2], [3, 4]] Output Grid: [[2, 1], [4, 3]] === TEST INPUT === [[5, 6], [7, 8]] Transform the test input.
    Transformation Type: Horizontal Flip

    question: {question}
    Transformation Type:"""
    transformation_type = call_llm(prompt)
    return transformation_type

def apply_transformation(input_grid: str, transformation_type: str, question: str) -> str:
    """Applies the identified transformation to the input grid."""
    prompt = f"""You are an expert in applying grid transformations.
    Apply the {transformation_type} transformation to the input grid.

    Example:
    input_grid: [[5, 6], [7, 8]]
    transformation_type: Horizontal Flip
    Transformed Grid: [[6, 5], [8, 7]]

    input_grid: {input_grid}
    transformation_type: {transformation_type}
    Question: {question}
    Transformed Grid:"""
    transformed_grid = call_llm(prompt)
    return transformed_grid

def function_test(input_grid: str, transformed_grid: str, question: str) -> str:
    """Test function to test transformation."""
    prompt = f"""You are an grid transformation expert. Test the new grid to make sure that the pattern has been successfully applied based on the question provided and the transformed grid that was made.
    Example of a successful function test, with explanation.
        question:
            === TRAINING EXAMPLES ===
            Example 1:
                Input Grid: [[1, 2], [3, 4]]
                Output Grid: [[2, 1], [4, 3]]
            === TEST INPUT ===
            [[5, 6], [7, 8]]
            Transform the test input according to the pattern shown in the training examples.
        transformed_grid: [[6, 5], [8, 7]]
    Result: [[6, 5], [8, 7]]
    The new grid displays a successful test because the columns swapped successfully based on the question provided.

    Example of an unsuccesful function test, with explanation.
        question:
            === TRAINING EXAMPLES ===
            Example 1:
                Input Grid: [[1, 2], [3, 4]]
                Output Grid: [[2, 1], [4, 3]]
            === TEST INPUT ===
            [[5, 6], [7, 8]]
            Transform the test input according to the pattern shown in the training examples.
        transformed_grid: [[5, 6], [7, 8]]
    Result: [[5, 6], [7, 8]]
    The new grid displays a failed test because the transformation was not applied.

    question: {question}
    transformation: {transformed_grid}
    Result: 
    """
    result = call_llm(prompt)
    return result

def main(question: str) -> str:
    """Main function to solve the problem."""
    try:
        # 1. Identify the transformation type
        transformation_type = identify_transformation_type(question)

        # 2. Extract the test input grid
        test_input_match = re.search(r"=== TEST INPUT ===\n(.*?)\nTransform", question, re.DOTALL)
        if not test_input_match:
            return "Error: Could not find TEST INPUT in the question."
        input_grid = test_input_match.group(1).strip()

        # 3. Apply the transformation
        transformed_grid = apply_transformation(input_grid, transformation_type, question)

        # 4. Apply function test to ensure the transformation occured successfully
        function_test_result = function_test(input_grid, transformed_grid, question)

        if "failed" in function_test_result:
            return f"Error: Function test has failed. {function_test_result}"

        return transformed_grid
    except Exception as e:
        return f"An error occurred: {e}"
```


            LEARNINGS FROM PREVIOUS ITERATIONS:
            
        ACCUMULATED LEARNINGS FROM PREVIOUS ITERATIONS:
        ```
# GRID TRANSFORMATION DATASET - RESEARCH LOG

This document serves as a running log of our learnings and experiments related to the grid transformation task. It focuses on concrete, dataset-specific insights and findings, rather than general system design principles.

## 1. DATASET PATTERNS & CHARACTERISTICS

*   **Grid Representation:** Grids are represented as lists of lists, with integer values representing colors/states.
*   **Value Range:** Values in grids tend to be small integers (0-9). Often these are binary grids or low integers reflecting the repetition. The value "4" is also frequently present.
*   **Grid Structure and Zero-Padding:** Questions consistently present grid transformation problems using 2D lists (matrices) filled predominantly with zeros and a few other integers (e.g., 1, 2, 3, 4, 6, 7, 8, 9). The large proportion of zeros often forms a "padding" or background, while the non-zero integers represent the "foreground" elements undergoing transformation. This suggests that the *relative position of non-zero elements within a sparse grid* is crucial for identifying transformation rules. Specific to some problems, the zeros either represent empty space or specific values within the grid. This ambiguity needs to be handled well.
*   **Question Structure:** Questions are formatted as a series of "Example Input Grid," "Example Output Grid" pairs, followed by a "Test Input" grid and the instruction to transform the test input. Each example is clearly labeled ("Example 1:", "Example 2:", etc."). Questions consistently follow a "TRAINING EXAMPLES ... TEST INPUT ... Transform the test input" structure.
*   **Multi-Example Prompting Format:** Questions are formatted with "=== TRAINING EXAMPLES ===" followed by multiple "Example X: Input Grid:\n[...]\nOutput Grid:\n[...]" pairs. Then, "=== TEST INPUT ===\n[...]" and the prompt "Transform the test input according to the pattern shown in the training examples." This highlights the task's reliance on *few-shot learning*. The system's performance is directly tied to its ability to discern and generalize transformation rules from a small number of examples.
*   **Grid Dimensions:** The size of the input grids varies across examples within a single question. Within a single question, input and output grids may have consistent dimensions, but there is often some padding present. The answer grid's size is determined by the transformation pattern, and is not always the same as the input grid. Sizes range from small 3x3 grids to larger 21x21 grids, or even larger 30x30 grids. A key characteristic is the frequent change in grid dimensions between the input and output. The system must infer how the original grid is expanded or contracted. Extrapolating patterns to new grid sizes or element arrangements is a challenge.
*   **Transformation Focus:** Questions focus on spatial relationships and transformations of the grid's contents.
*   **Transformation Types:**
    *   **Grid Expansion/Replication:** The input grid is expanded into a larger grid, with values replicated based on the original pattern (e.g., Example 0 from initial analysis).
    *   **Conditional Value Modification:** Values within the grid are changed based on their position or the values of their neighbors (e.g., Examples 1, 2, 3, 4 from initial analysis). Rules are often spatial and relative.
    *   **Resizing/Reshaping:** Grid structure changes size or shape.
    *   **Shifting/Rearranging Subgrids:** A common pattern involves shifting or rearranging subgrids within the larger grid. The transformation often involves moving specific values or blocks of values to different locations.
    *   **Propagation:** A common pattern involves identifying specific numbers or shapes in the input grid and then propagating or transforming them in a structured way to generate the output grid (e.g., triangular propagation, mirroring). Transformations seem to follow a pattern of propagating values from certain "anchor" cells to their neighbors.
    *   **Counting Elements and Positional Changes**: Some transformations involve counting elements and altering their positions.
    *   **Copy and Paste:** A frequent pattern observed in the training examples is copying a specific value from one location of the grid to another based on defined conditions. This copying action often depends on finding specific "trigger" values within certain parts of the grid.
    *   **Row Swapping:** Transformations may involve swapping rows within the grid.
    *   **Color Reduction with Row Extraction:** Some transformations involve reducing colors and extracting specific rows.
    *   Rotations, reflections, element replacements based on position or value, or combinations of these. The complexity of these transformations is a key challenge.
    *   Combinations of the above are possible.
*   **Grid Structure and Repetition:** A key characteristic is the consistent presence of repeating patterns within these grids (rows, columns, or sub-grids with identical values). The training examples are crucial for demonstrating these patterns. Grids are frequently framed by a border of identical numbers. An example of incorrect replication occurred during iteration 19 with the system outputting a variation `[4, 4, 9, 9], [4, 4, 4, 4], [4, 4, 9, 9], [9, 9, 4, 4], [4, 4, 4, 4], [9, 9, 4, 4]` instead of repeating `[4,4,9,9],[4,4,4,4],[4,4,9,9]` as in the output.
*   **Transformation Logic Encoding:** The transformation logic is encoded implicitly within the relationship between the input and output grids of the training examples. This logic often involves identifying specific numbers or patterns in the input and replacing them with other numbers in predictable locations within the output grid.
*   **Transformation Logic Variety:** The transformation logic itself varies significantly between problems within the dataset. Some transformations involve propagating values to neighbors, others involve repeating columns, and still others might extract subgrids based on patterns found within the non-zero elements. This *diversity of transformation types* poses a significant challenge for a simple pattern matching approach, as a single, universal strategy is unlikely to succeed across the entire dataset. Transformations can be complex, involving changes to element values based on their position, neighboring values, or other intricate relationships. This complexity is dataset-specific; success relies on uncovering these non-obvious rules.
*   **Multi-Example Dependency:** Successfully extracting the transformation rule relies heavily on multiple training examples. A single example is often insufficient to disambiguate the underlying pattern. Test-time analysis of the training examples to dynamically adapt to the specific problem is crucial.
*   **Fill Patterns:** Many examples require a "fill" pattern, or reflecting values found in the input grid throughout the output grid with a certain symmetry.
*   **Spatial Transformations:** The transformation rules are spatial and involve manipulations of numbers within the grid based on their positions and values of neighboring cells. Transformations involve understanding spatial relationships between grid elements and applying operations based on those relationships (e.g., replicating patterns, shifting elements, identifying symmetrical structures).
*   **Limited Symbol Variety:** The grids use a limited set of symbols (integers, primarily), but the spatial arrangement and relationships between them are key.
*   **Core Transformation Logic:** The core challenge revolves around deciphering the transformation logic. This could involve shrinking/expanding the grid, changing values based on neighbors, or applying other spatial relationships.
*   **Local and Structural Transformations:** The transformations are often *local* and *structural*. That is to say that the correct answer can be obtained by observing local pattern changes. Contextualizing local changes within the entire grid structure is important.
*   **Inference of Transformation Type and Parameters:** The dataset uniquely requires the system to infer the *type* of transformation (shift, rotation, etc.) and the *parameters* (direction, amount) from a small number of examples.
*   **Varied Transformation Types:** The transformations are diverse, including but not limited to element shifting, pattern replication, counting elements and positional changes. This heterogeneity demands a flexible and adaptable transformation identification mechanism.
*   **Concise Output:** The output grid is often significantly smaller or has a fundamentally different structure than the input, indicating a summarization or feature extraction process rather than a simple pixel-level manipulation.
*   **Transformation patterns and relationships:** Transformation patterns often involve relationships between numbers in the input grid and their corresponding placement or modification in the output grid. These relationships can involve translating, rotating, or replacing specific values based on their context. An example of this is identifying that '7' and '4' get mapped to different places in the grid (Iteration 19). The LLM struggles to identify that the 7 and 4 numbers get mapped to other places in the matrix.
*   **Focus on sub-sections or features:** The grid sizes vary, with some examples involving full grid transformations and others focusing on specific sub-sections or features within the grid.
*   The transformation rules often involve identifying specific numbers in the input grid (e.g., 3, 5, 8) and changing the values of other cells based on the location of these identified numbers.
*   Training examples often involve the movement, duplication, or alteration of specific numbers (e.g., 7, 8, 5) within the grid. These numbers act as "trigger" elements for the transformation.
*   Transformations are often locally constrained, meaning the change in a cell depends on the value or position of neighboring cells (the "attractor" behavior).
*   A key characteristic is the presence of 'special' numbers within the grid (e.g., 8 in many examples), which often serve as anchors or triggers for the transformation rule. The rules often involve modifying neighboring cells based on the location and value of these special numbers.
*   **Symbolic Reasoning:** The transformations involve symbolic manipulation. Numbers within the grid don't represent quantities but rather *types* or *states* that are moved, replicated, or replaced based on context.
*   **Context-Dependent Rules:** Rules for transformation aren't universal but depend on the local neighborhood of a cell and its relationship to other cells with specific values. The system is unable to detect that '3' is removed, while 3's located at the bottom get replicated, indicating that the same numbers are transformed differently based on their location within the grid.
*   **Grid Transformations with Hidden Rules:** The dataset presents grid transformation problems where the relationship between input and output grids is not explicitly stated. The task requires identifying a hidden pattern or transformation rule from a set of training examples and applying it to a new test input grid.
*   **Abstraction and Spatial Relationships:** Many transformations involve understanding spatial relationships between grid elements and applying operations based on those relationships (e.g., replicating patterns, shifting elements, identifying symmetrical structures).
*   **Abstraction Level:** The task requires a high level of visual abstraction and pattern recognition. The system must infer the underlying rules of transformation from a limited number of examples.
*   **Varying Grid Sizes:** The grids in different examples and even within the same question can have varying dimensions (rows and columns). This adds complexity to pattern recognition (Iteration 19).
*   **Invariant and Variant Regions:** The grids often contain a mix of invariant regions and areas that undergo transformation, adding complexity (Iteration 22).
*   The logic of what causes propagation and what values remain unchanged is not always clear (Iteration 22).

## 2. EFFECTIVE TASK-SPECIFIC STRATEGIES

**Promising Strategies:**

*   **Multi-Agent Approach:** The multi-agent approach, with specialized LLM agents for context identification, example selection, transformation application, and verification, shows promise. Decomposing the problem into smaller, more manageable tasks allows each agent to focus on a specific aspect of the transformation. (Iteration 11)
*   **Decomposition into sub-tasks (Analyze, Transform, Verify):** Breaking down the problem into distinct stages (analysis, transformation, verification) is a useful strategy. It allows for modular design and targeted application of LLM capabilities. (Iteration 17, Iteration 18)
*   **LLM Role Assignment:** Assigning specific roles (analyzer, transformer, verifier) to the LLM for each stage is helpful in guiding the LLM's reasoning process and leveraging its strengths in different areas. (Iteration 17)

**Ineffective Strategies:**

*   **Purely LLM-Driven Pattern Matching:** Relying solely on the LLM to directly learn and apply the transformation rules has proven unreliable. (See Experiment Log - Iteration 0). Demonstrated again in Iteration 1, 2, and 7 with 0% accuracy. The "exploitation" strategy, which relies on the LLM to directly translate examples into code, has also proven inadequate (Iteration 12). LLMs Alone are Insufficient - Relying solely on LLMs without incorporating algorithmic processing or numerical analysis leads to poor performance on tasks requiring precise grid transformations. Chain-of-thought prompting with LLMs also falls short in this category (Iteration 19).
*   **Multi-Example Prompting Alone:** Simply providing multiple examples in the prompt is not enough to solve the grid transformation problems reliably. The LLM, in its current form, lacks the capability to robustly extract and implement the correct transformation logic. (See Experiment Log - Iteration 2).
*   **Test-Time Training:** The "test-time training" approach, which relies on the LLM to develop and validate a hypothesis before applying it, was unsuccessful for this dataset. (See Experiment Log - Iteration 3).
*   **Explicit Positional Reasoning with Verification Loop:** Explicit positional reasoning, combined with a verification loop and feedback mechanism, has not improved accuracy. This suggests the LLM cannot effectively correlate errors with the extracted rule and adjust its reasoning accordingly (Iteration 4).
*   **Unconstrained Exploration Strategy:** A broad, unconstrained exploration strategy is not effective at solving the core transformation challenges without better constraints. (See Experiment Log - Iteration 5). The "Exploration" strategy, in its current implementation, doesn't lead to effective learning of transformation rules.
*   **Local Structural Motif Identification and Application (Iteration 6):** The approach of identifying and applying "local structural motifs" completely failed for this dataset, resulting in 0.0 accuracy. The hypothesis that identifying motifs and mapping their transformation provides a robust way to generalize transformations was rejected.
*   **LLM-driven decomposition approach (Iteration 8):** The LLM-driven decomposition approach, in its current form, is not effective for this dataset. The attempt to identify a transformable subgrid, derive transformation rules, and apply those rules failed.
*   **Exploration with Structured Rule Extraction and Iterative Refinement (Iteration 9):** The "exploration" strategy, involving LLM-based structured rule extraction and iterative refinement, did not achieve satisfactory accuracy (0.67). This suggests that the current approach to rule extraction and refinement is not robust enough to handle the complexity of the grid transformation patterns in this dataset. The hypothesis that structured representation and iterative refinement would significantly improve generalization was not supported.
*   **Exploration Strategy Ineffective (Iteration 10):** The exploration strategy, as implemented, has proven ineffective. The reliance on a single "grid transformation expert" LLM call for each step results in highly flawed solutions.
*   **Exploration based on minimal change identification and pattern interpolation (Iteration 13):** This strategy was unsuccessful, suggesting the dataset's transformation rules are too complex for this approach.
*   **Exploitation Strategy Ineffective (Iteration 14):** The exploitation strategy of using LLM-driven rule extraction, refinement, and application is insufficient for solving the grid transformation problems in the dataset.
*   **Value determination based on Location:** The system is prone to determining the target value to copy based purely on a single example. This results in hardcoding of the target value into the solution and an inability to generalize to new inputs. (Iteration 15)
*   **Exploitation Strategy Ineffective (Iteration 16):** The exploitation strategy failed to generalize learned patterns to unseen test cases. This suggests that the LLM-based rule extraction and refinement, while seemingly logical, struggles to capture the nuances of these grid transformations.
*   **Verification Stage Ineffective:** The verification step, while conceptually sound, isn't effective at catching the errors made during the transformation stage, suggesting issues with the verification criteria or LLM's ability to evaluate transformations.
*   **Hypothesis Generation and Validation Ineffective (Iteration 20):** Simply generating multiple hypotheses and validating them is insufficient to solve the grid transformation problems in this dataset.
    *   **Exploitation Strategy Ineffective (Iteration 21):** The exploitation strategy with this particular LLM-driven approach has been shown to result in zero accuracy.
    *   **Anchor-Based Propagation (Iteration 22):** The experiment rejects the hypothesis that simply identifying "anchor" values and propagating their influence using a single chain of LLM calls is sufficient for solving these grid transformation problems.

*Currently, with an accuracy of 0.0 (Iteration 20, 21, and 22), no strategy stands out as particularly effective. Further iterations and analysis are needed to identify successful techniques.*

## 3. COMMON FAILURE MODES ON THIS DATASET

*   **Pattern Extraction Failure:** The core failure lies in the LLM's inability to accurately extract and generalize the transformation pattern from the training examples. The model generates outputs drastically different from the expected golden answers. For instance, it produces simple diagonal matrices when a complex grid transformation is required. For example, given the training examples:
    ```
    === TRAINING EXAMPLES === Example 1:
    Input Grid:
    [[3, 1, 2],
     [3, 1, 2],
     [3, 1, 2]]

    Output Grid:
    [[4, 5, 6],
     [4, 5, 6],
     [4, 5, 6]]

    Example 2:
    Input Grid:
    [[2, 3, 8],
     [2, 3, 8],
     [2, 3, 8]]

    Output Grid:
    [[6, 4, 9],
     [6, 4, 9],
     [6, 4, 9]]

    Example 3:
    Input Grid:
    [[5, 8, 6],
     [5, 8, 6],
     [5, 8, 6]]

    Output Grid:
    [[1, 9, 2],
     [1, 9, 2],
     [5, 8, 6]]

    Example 4:
    Input Grid:
    [[9, 4, 2],
     [9, 4, 2],
     [9, 4, 2]]

    Output Grid:
    [[8, 3, 6],
     [8, 3, 6],
     [8, 3, 6]]

    === TEST INPUT ===
    [[8, 1, 3],
     [8, 1, 3],
     [8, 1, 3]]

    Transform the test input according to the pattern shown in the training examples.
    ```
    The expected output is "[[9,5,4],[9,5,4],[9,5,4]]" but the LLM often returns a diagonal matrix or other incorrect output. Insufficient Pattern Interpretation - The script struggles to accurately decipher the transformation pattern from the training examples. The predicted output grid often bears little resemblance to the expected one, indicating a failure to grasp the underlying transformation logic.
*   **Incorrect Pattern Deduction:** The LLM fails to generalize the transformation rule from the examples. Instead of identifying the core transformation logic, the model focuses on superficial correlations or repetitions. The LLM struggles to correctly identify and formalize the underlying transformation rules. Instead of capturing the general pattern, it makes flawed assumptions about the relationships between numbers and cell locations.
*   **Inability to Handle Complex Rules:** The model struggles with transformations that involve more than simple element-wise operations or direct spatial relationships. Examples with more intricate patterns result in incorrect outputs. When the transformation rules involve multiple conditions or dependencies (e.g., changing a cell's value based on the presence of multiple numbers in specific locations), the LLM fails to correctly encode this complexity in the code. It can handle single conditions but struggles with combinations.
*   **Sensitivity to Noise:** The model is susceptible to "noise" in the examples.
*   **Ambiguity:** The training examples might not perfectly define the transformation. There could be multiple plausible rules.
*   **Generalization:** The model needs to generalize the rule to the test input, which might have different dimensions or arrangements. The LLM struggles with generalizing from examples.
*   **Text Parsing/Representation:** Converting the text-based grid representation into a usable data structure (without brittle JSON parsing) is a challenge.
*   **Computational Complexity:** Naive implementations of grid transformations can be computationally expensive, especially for larger grids.
*   **Edge Cases/Complexities:**
    *   **Empty Grids:** What happens when the input grid is empty or contains only zeros?
    *   **Varying Input Sizes:** How does the rule adapt when the input grid dimensions are significantly different from the training examples?
    *   **Multiple Transformations:** Can a single question involve both grid expansion *and* value modification?
    *   **Symmetry/Rotation:** Are there cases where the transformation involves rotation or reflection of the grid?
    *   **Color/Value Dependencies:** Does the transformation depend on specific color values or their relationships (e.g., "if a cell is surrounded by color X, change it to color Y")?
*   **Incorrect Value Substitution:** The LLM struggles to correctly identify *which* values need to be substituted and *what* they should be replaced with. For instance, it might misinterpret the training examples and apply a substitution rule to the wrong numbers, leading to incorrect values in the output grid.
*   **Extrapolation and Dimensionality Errors:** The LLM incorrectly extrapolated patterns in the training data, generating larger grids than expected in the test output. This indicates a failure to respect dimensionality constraints.
*   **Lack of Contextual Awareness:** The LLM failed to account for context within the grid. For example, the examples above show a test input that differs from the training examples. The LLM failed to generalize between these scenarios.
*   **Incorrect Pattern Recognition from Limited Examples:** The primary failure mode stems from the LLM's inability to accurately deduce the underlying transformation rule from the few provided training examples. For instance, the model misinterpreting the transformation logic, failing to propagate non-zero values to the correct neighboring locations. This indicates a limitation in the LLM's *reasoning and generalization abilities* when faced with complex spatial relationships.
*   **Incorrect Code Translation of (Misunderstood) Patterns:** Even when the LLM identifies a plausible pattern, it often struggles to translate this understanding into correct and executable code. The generated code inaccurately implements the intended neighbor propagation logic, yielding an incorrect output grid. This highlights a disconnect between *pattern recognition and procedural implementation.*
*   **Sensitivity to Grid Dimensions and Element Distribution:** The transformations appear to be sensitive to specific grid dimensions and the spatial arrangement of non-zero elements. The system incorrectly repeats column values across the grid, misinterpreting the rule based on the distribution of values within the provided examples. This suggests a need for *robust strategies that are invariant to irrelevant grid properties.*
*   **Pattern Recognition is a Bottleneck:** The failure to accurately identify the transformation pattern is a significant bottleneck. Even when the model attempts to generate code based on a (flawed) understanding of the pattern, the resulting output is incorrect. The ability of LLMs to do pattern matching on complex inputs is suspect.
*   **Grid Size Discrepancy:** The LLM sometimes fails to produce an output grid of the same dimensions as the expected output. This suggests an issue with understanding or adhering to the grid structure. This is exemplified in the case where the system outputs a 3x3 matrix while the golden answer is a 21x21 matrix. Handling Dimensionality Changes - The LLM often struggles to predict the size and shape of the output grid when the dimensions change. It may not correctly infer the expansion or contraction factors or how the elements should be arranged in the new grid.
*   **Ignoring Input Data:** The LLM-generated responses often bear little to no resemblance to the input grids, indicating that the model is not effectively utilizing the provided information to guide its transformations.
*   **Hallucination:** The LLM outputs grids that have nothing to do with the original input, suggesting the LLM hallucinates or has problems with reasoning.
*   **Incorrect Rule Extraction (Iteration 4):** The LLM struggles to extract accurate transformation rules from the training examples. The agent fails to generalize and capture the underlying logic of the grid transformations. For example, when presented with a fill grid, the LLM misinterpreted what values to fill and where, leading to an empty grid or seemingly random numbers in the output.
*   **Positional Reasoning Errors (Iteration 4):** Positional reasoning alone is not enough to ensure accurate transformations. The positional reasoning approach does not prevent the LLM from making errors in applying rules based on the positions of numbers in the grid.
*   **Verification Loop Ineffectiveness (Iteration 4):** The verification loop does not effectively refine the extracted rules, indicating that the feedback mechanism is not sufficient to correct the LLM's errors. The LLM lacks the capacity to correlate the error with the rule and adjust accordingly.
*   **Unreliable String to Integer Conversion (Iteration 5):** The system fails when it cannot reliably convert string representations of grid values into integers. This suggests the LLM sometimes introduces formatting issues or unexpected characters when extracting cell values or transformation rules.
*   **Reasoning Errors About Grid Transformations (Iteration 5):** The model struggles to derive the correct transformation rules from the training examples, leading to either incorrect output grids or an "Invalid transformation" error, indicating the system couldn't determine a consistent rule.
*   **Cell-by-cell Approach Bottleneck (Iteration 5):** Relying directly on the LLM for both cell analysis and transformation without proper validation/filtering leads to inconsistencies.
*   **Inability to Abstract Transformation Logic (Iteration 6):** The LLM struggles to go beyond superficial pattern matching to extract the underlying *logic* behind the grid transformations. For example, it might recognize that a '1' in the input leads to a row of '1's in the output, but fail to understand *why* or *where* that row should be placed relative to the input grid.
*   **Motif Extraction Ambiguity (Iteration 6):** The LLM fails to identify the relevant motifs in the training examples and how these motifs are transformed to generate the output grid. This causes it to apply the wrong transformations to the test input, resulting in a completely different matrix. For example, it may identify a motif, but the transformation rule applied is wrong (it might assume a number changes to a "3", when that is incorrect).
*   **Output Shape/Dimensionality Errors (Iteration 6)**: The generated output grids often have a different shape or dimensionality than the expected output. This indicates a fundamental failure in understanding how the transformation affects the overall structure of the grid, not just the values within it.
*   **Spatial Relationship Misinterpretation (Iteration 7):** The LLM struggles to accurately translate spatial relationships between grid elements into code. For example, identifying that 2s must appear to the left and above 1s, but failing to implement code to generate 2s in all necessary places.
*   **Pattern Generalization Failure (Iteration 7):** The LLM struggles to generalize patterns observed in training examples to the test input grid. For example, the LLM fails to identify how the values in the test grid should be transformed by incorrectly identifying "the value 3 as a key".
*   **Output Grid Structure Problems (Iteration 7):** LLM fails to recognize changes to the overall structure in the transformed grid (e.g., changes to grid size).
*   **Incorrect Value Placement/Shifting (Iteration 8):** The core issue is the LLM's failure to accurately generalize the transformation rules and apply them to the test input. For example, values are placed in the wrong locations.
*   **Incorrect Transformation Rule Identification (Iteration 8)**: The LLM seems to either fail to identify the correct transformation rule or provides a rule that doesn't represent a transformation, instead providing a separate grid.
*   **Pattern Recognition and Translation (Iteration 9):** The primary failure lies in the agent's difficulty in accurately recognizing complex visual patterns and translating them into precise code logic. For example, the agent struggles to deduce the exact rules governing the placement and propagation of numbers in the output grid based on their location in the input grid.
*   **Incorrect Rule Application (Iteration 9):** Even when a general rule is identified, the agent often fails to implement it correctly in code. This leads to transformations that don't match the expected output (e.g., the code in the first failure case attempts to create a triangular transformation but does so incorrectly, resulting in the wrong output grid).
*   **Difficulty Translating Visual Intuition into Algorithmic Rules (Iteration 9):** The current error patterns highlight the difficulty of translating visual intuition into precise algorithmic rules.
*   **Incorrect Transformation Logic Identification (Iteration 10):** The primary failure occurs in the `identify_core_transformation_logic` function. The LLM fails to accurately deduce the underlying rule from the provided training examples. This leads to the generation of incorrect or incomplete transformation rules. For instance, in the first error example, the code incorrectly identifies a diagonal shifting pattern.
*   **Inadequate Verification (Iteration 10):** The `verify_transformation_logic` function does not adequately catch the errors in the identified transformation logic. This could be due to insufficient test cases or a flawed verification process that relies on the same faulty logic.
*   **Brittle Algorithm Implementation (Iteration 10):** Even when a transformation rule is partially correct, the implemented algorithm in `apply_transformation_to_test_input` may be too brittle or specific, failing to generalize to unseen inputs. The LLM generates iterative, step-wise logic, that fails to generalize to all the training examples, let alone the test input.
*   **Inability to Generalize Transformation Rules (Iteration 11):** The system often fails to accurately apply the transformation logic learned from the training examples to the test input. For example, the system incorrectly places a value in the output grid because it couldn't identify the correct pattern for number placement based on the examples (Error example 1 in Iteration 11).
*   **Difficulty in Handling Complex Patterns (Iteration 11):** When transformations involve multiple factors or subtle dependencies, the system struggles to produce the correct output. For example, the system failed to consistently modify values based on their surrounding context, leading to incorrect changes in specific grid locations (Error example 2 in Iteration 11).
*   **Overfitting to Training Examples:** The approach fails when the LLM extracts overly specific rules that are directly tied to the training examples' grid configurations but do not generalize to the test input. For example, instead of learning a general rule about relative positions of numbers, the LLM might hardcode specific row and column indices to apply transformations, which will obviously fail on the test input if the numbers appear in different locations.
*   **Inaccurate Rule Extraction (Iteration 13):** The LLM agents failed to accurately extract and generalize the transformation rules from the training examples. The complexity of the rules, involving conditional logic and spatial relationships between numbers, overwhelmed the current approach.
*   **Verification Failure (Iteration 13):** The "verify_transformation" step frequently flagged incorrect transformations, demonstrating a good capacity to *identify* errors, but a poor ability to *correctly generate* transformations. The LLM could articulate why a proposed output was wrong, but couldn't then produce a correct output. This suggests a disconnect between understanding the rules and applying them.
*   **Limited Generalization (Iteration 13):** The model struggled to generalize from the limited number of training examples, especially when the transformations involved subtle variations or combinations of rules. The model correctly identified a rule about "attractors," but incorrectly applied it to the entire grid.
*   **Incorrect Rule Generalization (Iteration 14):** The model often fails to generalize the transformation rule from the training examples. For instance, the model misinterpreted the pattern and populated the entire grid with the number 4, instead of extracting the 6s and their spatial relationship.
*   **Inability to handle varied grid sizes (Iteration 14):** The model seems to have trouble to generate output grids with proper dimensions, especially when the output has different dimensions than the input grid. The model's output may have dimensions unrelated to the input or expected output.
*   **Spatial reasoning limitations (Iteration 14):** The model struggles with spatial reasoning, failing to correctly identify which cells need to be modified based on the position of key numbers (like 8). The logic for placing "3"s around "8"s is flawed.
*   **Incorrect Rule Extraction (Iteration 15):** The system struggles to accurately deduce the transformation rule from the training examples. This is evident in the error example provided. The system incorrectly identified the transformation as "replacing values in column 4 with 4" based on the location of a 4 in row 11, rather than recognizing that the value 8 from the last part of the grid should be copied to the first part of the grid, and the conditions for selecting '8' as a copy value are based on the training set.
*   **Failure to Generalize (Iteration 15):** Even if a rule is partially correct, the system often fails to generalize it to the test input. The system might extract a rule that works for the training examples but doesn't account for edge cases or variations present in the test input.
*   **Incorrect Rule Abstraction (Iteration 16):** The primary failure is the system's inability to correctly abstract the transformation rules from the examples. For instance, in the first failure example, the system fails to recognize the pattern involving the '6', '8', '1', '7', and '9' elements and their correct placement after transformation, leading to a completely different output structure compared to the ground truth.
*   **Local vs. Global Context (Iteration 16):** The LLM often seems to focus on immediate neighboring cells without understanding the larger pattern or dependencies in the grid.
*   **Over-Reliance on LLM and Lack of Numerical Reasoning:** The script might be too dependent on the LLM's general knowledge without sufficient numerical reasoning or algorithmic processing.
*   **Pattern Recognition Failure (Iteration 18):** The core failure lies in the inability to correctly identify the transformation pattern from the training examples. For instance, in the row-swapping example, the code correctly identifies the non-zero rows but applies an incorrect transformation by swapping the first non-zero rows with the last rows regardless of what number is present.
*   **Output Format Mismatch (Iteration 18):** Even when a transformation is partially correct, the output format often deviates from the expected format. For example, in the color reduction problem, the code returns a list of lists when a single list is expected.
*   **Lack of Generalization (Iteration 18):** The system fails to generalize the learned patterns to the test input. The rules inferred from the training examples are not robust enough to handle variations in grid size, content, or transformation complexity.
*   **Flawed Pattern Recognition (Iteration 19):** The core failure lies in the inability of the LLM to accurately identify and internalize the transformation rules. This is evident in the system's inaccurate substitutions. For instance, in the first error example from Iteration 19, the system fails to replicate the exact repetition pattern observed in the training examples. Instead of repeating `[4,4,9,9],[4,4,4,4],[4,4,9,9]` as in the output, the system outputs a variation `[4, 4, 9, 9], [4, 4, 4, 4], [4, 4, 9, 9], [9, 9, 4, 4], [4, 4, 4, 4], [9, 9, 4, 4]`.
*   **Relational Mapping Issues (Iteration 19):** The LLM struggles to understand and apply complex relational mappings. The second error example from iteration 19 shows that the system was unable to identify that the 7 and 4 numbers get mapped to other places in the grid.
*   **Handling Variable Grid Dimensions (Iteration 19):** The system is not good at dealing with varying grid dimensions or understanding the appropriate output grid size.
*   **Hypothesis Generation Limitations:** The primary failure mode is the inability to generate valid hypotheses about the underlying transformation rule. The system often reports "No hypothesis could be validated from the set." This suggests the hypothesis generation is either producing irrelevant rules or the validation process is too strict or flawed, rejecting potentially correct rules (Iteration 20).
*   **Oversimplified Hypotheses:** When hypotheses are generated, they are often simplistic (e.g., flipping the grid) and fail to capture the more complex patterns in the training examples, leading to incorrect transformations of the test input (Iteration 20).
*   **Output/Application Issues:** Even when the script attempts a transformation (like flipping), the output isn't generated in a readable format (e.g., just code is returned instead of the transformed grid), indicating issues with the application or output stages (Iteration 20).
*   **Disconnect between Rule Identification and Application:** The LLM struggles
        

            CAPABILITY ASSESSMENT & IMPROVEMENT GUIDANCE:
            
        CAPABILITY ASSESSMENT & IMPROVEMENT GUIDANCE:
        SYSTEM ANALYSIS & GUIDANCE


        

            EXPLORATION GUIDANCE:
            1. Review the historical approaches, error patterns, and accumulated learnings carefully
            2. Review the FULL CODE of previous scripts to understand what has already been tried
            3. Design a new approach that is DISTINCTLY DIFFERENT from previous attempts. This approach should have a specific NEW HYPOTHESIS or variable you are trying to test. 
            4. CRITICAL: Include EMBEDDED EXAMPLES directly within your LLM prompts
            5. For each key function, show a complete worked example, or include multiple examples, including:
               - Input example that resembles the dataset
               - Step-by-step reasoning through the example
               - Properly formatted output
            6. Apply the insights from the ACCUMULATED LEARNINGS section to avoid repeating past mistakes
            7. Pay SPECIAL ATTENTION to the weaknesses and improvement suggestions from the capability assessment
            8. Consider implementing one or more of these LLM usage patterns:
               - Repeated validation with feedback loops
               - Multi-perspective analysis with synthesis
               - Dynamic input-dependent routing with an orchestrator
               - Hybrid approaches combining LLM with deterministic functions
               - Best-of-n solution generation and selection
               - ReAct pattern for interactive reasoning and action
               - If it is unknown how successful a processing state or part of the pipeline is, include verification steps to different parts of the pipeline in order to help deduce which parts are successful and where the system is breaking
               - Answer checkers to validate the final answer against the problem statement. If the answer is incorrect, the checker can send the answer back to an earlier part of the system for for refinement with feedback

            Here's how to call the Gemini API. Use this example without modification and don't invent configuration options:
            def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. DO NOT deviate from this example template or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

            Since this is an EXPLORATION phase:
            - Try a fundamentally different approach to reasoning about the problem. Test a NEW HYPOTHESIS or variable, and add verification steps to deduce if this new change is helpful.
            - THIS IS KEY: Break down the problem into new, distinct reasoning steps based on past performance before you start coding
            - For EACH key LLM prompt, include a relevant example with:
              * Sample input similar to the dataset
              * Expected reasoning steps
              * Desired output format
            - Apply a verifier call to different parts of the pipeline in order to understand what parts of the pipeline of calls is successful and where the system is breaking
            - Pay special attention to addressing the primary issues from previous iterations
            - Ensure your new approach addresses the weaknesses identified in the capability assessment

            CRITICAL REQUIREMENTS:
            1. The script MUST properly handle all string literals - be extremely careful with quotes and triple quotes
            2. The script MUST NOT exceed 150 lines of code to prevent truncation
            3. Include detailed comments explaining your reasoning approach
            4. EVERY SINGLE LLM PROMPT must include at least one embedded example showing:
               - Sample input with reasoning
               - Desired output format
            5. Make proper use of error handling
            6. Implement robust capabilities to address the specific weaknesses identified in the capability assessment
            7. Do NOT use json.loads() in the LLM calls to process input data. JSON formatting is good to use to structure information as inputs and outputs, but attempting to have functions process JSON data explicitly with strict built-in functionality is error prone due to formatting issues and additional text that appears as documentation, reasoning, or comments. When passing data into another LLM call, you can read it as plain text rather than trying to load it in strict json format, is the better approach.

            Return a COMPLETE, RUNNABLE Python script that:
            1. Has a main function that takes a question string as input and returns the answer string
            2. Makes multiple LLM calls for different reasoning steps
            3. Has proper error handling for API calls
            4. Includes embedded examples in EVERY LLM prompt
            5. Is COMPLETE - no missing code, no "..." placeholders
            6. Closes all string literals properly

            This should be FUNDAMENTALLY DIFFERENT from all previous approaches. Do not reuse the same overall structure.

            BE EXTREMELY CAREFUL TO PROPERLY CLOSE ALL STRING QUOTES AND TRIPLE QUOTES!
            