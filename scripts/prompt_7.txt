
            You are improving a Python script that solves problems from a dataset.
            Your goal is to REFINE and ENHANCE the best performing approaches by combining their strengths and addressing specific weaknesses identified in error analysis.

            Here are example problems from previously seen data:
            [
  {
    "id": 0,
    "question": "PASSAGE: According to 2011 census of India, Kumbakonam had a population of 140,156 with a sex-ratio of 1,021 females for every 1,000 males, much above the national average of 929. A total of 12,791 were under the age of six, constituting 6,495 males and 6,296 females.The average literacy of the city was 83.21%, compared to the national average of 72.99%. There were a total of 9,519 workers, comprising 32 cultivators, 83 main agricultural labourers, 1,206 in house hold industries, 7,169 other workers, 1,029 marginal workers, 24 marginal cultivators, 45 marginal agricultural labourers, 212 marginal workers in household industries and 0 other marginal workers.\n\nQUESTION: How many workers weren't marginal cultivators?",
    "answer": "9495"
  },
  {
    "id": 1,
    "question": "PASSAGE: This Week 12 showdown between the Colts and Eagles was originally scheduled for 1:00 ET, but due to the NFL's \"flexible-scheduling\" system this year, the NFL moved the game to Sunday night at 8:15 ET. This was the Colts' third primetime game this year on NBC, and the Eagles' first. There were 10 scores in this game, 5 each half. The first three scores of the game were by Colts rookie RB Joseph Addai. He had a 15-yard TD run, a 10-yard TD run, and another 15-yard TD run after that. His fourth rushing touchdown of the game came in the second half. The Eagles' first score came with about a minute to go in the half. Quarterback Jeff Garcia threw a 1-yard touchdown pass to L.J. Smith on that drive. On the Colts' next drive, combined with a couple passes and a 13-yard run by Dominic Rhodes, the Colts put K Adam Vinatieri in field goal range to get some more points before the end of the half. At the half, the Colts had a 17-point lead, 24-7. After a Reggie Wayne touchdown catch, the Colts were up big on the Eagles, 31-7. On the ensuing possession for the Eagles, Garcia found Reggie Brown in the end zone for a  3-yard score. But with less than 11 minutes left in the game, the Eagles scored once more and reduced the Colts' lead to 10 points. On the following possession, the Colts ran the ball 13 times with no passes and Joseph Addai had the last 8 carries on that drive including another 4-yard scamper, his fourth touchdown of the game. That touchdown also tied the Colts franchise record for the most rushing touchdowns in a single game. With less than four minutes to go in the game, the Eagles were desperate to score some points, but while Jeff Garcia was deep in his own territory, he dropped back to pass and was hit by both DE Robert Mathis and DE Dwight Freeney. Mathis knocked the ball out of Garcia's hand right before his arm started going forwards and CB Kelvin Hayden picked up the ball and ran it back for a touchdown. The Colts were up by 24 points after that last score. On the next possession, the Eagles put in backup QB A. J. Feeley in place of Garcia, and Feeley ended up getting the football knocked out of his hand by Robert Mathis (his second forced fumble of the game) and the Colts recovered and ended up running out the clock to conclude the game. Joseph Addai tied the NFL record for most touchdowns in a game by a rookie, with 4 touchdowns in this game. During this game, the Colts lost SS Antoine Bethea, TE Dallas Clark and OT Ryan Diem all to injuries in the first half, and they did not return.\n\nQUESTION: How many touchdowns did Joseph Addai score in the first half?",
    "answer": "3"
  },
  {
    "id": 2,
    "question": "PASSAGE: Following a shocking loss to the 3-7 Kansas City Chiefs the previous week, the Steelers traveled to M&T Bank Stadium for another divisional game. Ben Roethlisberger, who suffered a concussion in the previous week's overtime loss, was the designated 3rd (emergency) quarterback. Backup Charlie Batch also was hurt in that game, which left 2nd-year QB Dennis Dixon, who previously had one pass in his NFL career, to start. The Steelers received the opening kickoff, but went three-and-out. On the ensuing possession, the Ravens drove down the field with ease, capping off their drive with a touchdown run by Willis McGahee. In the second quarter, Dixon hit WR Santonio Holmes on a play-action pass for a 33-yard TD, tying the game. The Ravens answered on the following drive, with a 52-yard strike from Joe Flacco to Mark Clayton, setting up a 10-yard touchdown pass to Derrick Mason. In the third quarter, on the Ravens opening possession, Mark Clayton made a 9-yard reception but fumbled the ball and it was recovered by Tyrone Carter. The Steelers drove, but were held to a field goal by Jeff Reed. Later in the 4th quarter, Joe Flacco was sacked by Lawrence Timmons and fumbled the ball, recovered by the Steelers near midfield. The drive resulted in a 24-yard run on a QB option by Dixon, giving the Steelers their first lead of the night. On the Ravens next possession Joe Flacco completed a pass to Derrick Mason for 17&#160;yards, and then found Ray Rice for a 44-yard reception, setting the Ravens up inside the Steeler 10&#160;yard line with less than 2&#160;minutes left. Billy Cundiff tied the game with a 24-yard field goal. On the following Steeler possession, Dennis Dixon was nearly intercepted by Lardarius Webb. The Steelers were forced to punt, giving the ball back to the Ravens with about 1:30 left in the game. The Ravens managed to drive to the Steeler 40&#160;yard line, where their drive stalled. With the clock counting inside 10&#160;seconds left and no timeouts, the field goal team managed to get into formation, and get the kick off. The 56&#160;yard attempt by Billy Cundiff was dead center, but about 2&#160;yards short, sending the game into overtime. In overtime, the Steelers won the coin toss and got the ball, but were forced to punt. The Ravens, also forced to punt deep in their own territory, gave the ball to Pittsburgh around the Steeler 40&#160;yard line. On a 3rd and 5, Dennis Dixon threw an interception to LB Paul Kruger, who returned the ball 26&#160;yards to the Steeler 28&#160;yard line. Already in field goal range, the Ravens ran the ball down to the Pittsburgh 11&#160;yard line where Billy Cundiff made a 29-yard field goal to win the game. With their second consecutive overtime loss, the Steelers fell to 6-5.\n\nQUESTION: How many more points did the Ravens score than the Steelers?",
    "answer": "3"
  }
]

            
        ITERATION HISTORY SUMMARY:
        - Total iterations completed: 7
        - Current explore/exploit balance: 20/80
        - Best accuracy achieved: 1.00 (iteration 1)

        APPROACH HISTORY (last 7 iterations):
        [
  {
    "iteration": 0,
    "strategy": "Exploration",
    "accuracy": 0.6666666666666666,
    "approach": "The script employs a multi-stage, LLM-driven approach to answer questions, using chain-of-thought reasoning and verification. It decomposes the problem into question analysis, relevant passage extraction, answer generation, and answer verification. The agent roles include question analyzer, passage extractor, answer generator, and answer verifier, each defined by system instructions in their respective functions. The functions used are `main`, `analyze_question`, `extract_relevant_passage`, `generate_answer`, `verify_answer`, and `call_llm`. The `main` function orchestrates the process, calling `analyze_question` to understand the question, `extract_relevant_passage` to find relevant context, `generate_answer` to formulate an initial answer, and `verify_answer` to refine the response, using `call_llm` to interface with the Gemini model for each step."
  },
  {
    "iteration": 1,
    "strategy": "Exploitation",
    "accuracy": 1.0,
    "approach": "The script uses a multi-stage LLM approach with chain-of-thought prompting to answer questions by identifying the question type, extracting relevant information, generating an answer, and then verifying the answer. The script uses the following functions: `main` orchestrates the entire process, `analyze_question` identifies the question type and keywords, `extract_relevant_passage` retrieves relevant text, `generate_answer` formulates an initial answer, `verify_answer` validates the answer, and `call_llm` interacts with the Gemini LLM, using system instructions and prompts to guide the LLM's reasoning at each step. The workflow starts with `main` calling `analyze_question`, followed by `extract_relevant_passage`, `generate_answer`, and `verify_answer`, each leveraging `call_llm` to interact with the LLM."
  },
  {
    "iteration": 2,
    "strategy": "Exploitation",
    "accuracy": 1.0,
    "approach": "The script uses a multi-stage LLM approach with example-driven reasoning to answer questions, incorporating question analysis, information extraction, answer generation, and verification. The problem is decomposed into four main steps: analyzing the question, extracting a relevant passage, generating an answer, and verifying the answer, each handled by a separate function. There are no agent roles indicated in the script. The script uses `analyze_question` to identify the question type and keywords, `extract_relevant_passage` to find the relevant information, `generate_answer` to form an answer, `verify_answer` to confirm its correctness, and `call_llm` to interface with the Gemini LLM. The overall workflow involves analyzing the question, extracting relevant information, generating an initial answer, verifying it for accuracy, and then returning the verified answer."
  },
  {
    "iteration": 3,
    "strategy": "Exploitation",
    "accuracy": 0.7,
    "approach": "The script uses a multi-stage LLM approach to answer questions by decomposing the problem into question analysis, relevant passage extraction, answer generation, and answer verification. Each stage leverages an LLM with a specific role (e.g., question analyzer, passage extractor) to perform its task. The functions used are `main`, `analyze_question`, `extract_relevant_passage`, `generate_answer`, `verify_answer`, and `call_llm`; `main` orchestrates the process, calling the other functions sequentially to analyze the question, extract relevant information, generate an answer, and verify its correctness, using `call_llm` to interact with the Gemini model at each stage. The overall workflow involves analyzing the question, retrieving relevant information, forming an initial answer, and then verifying the answer for accuracy."
  },
  {
    "iteration": 4,
    "strategy": "Exploitation",
    "accuracy": 0.9,
    "approach": "The script employs a multi-stage, LLM-driven approach to answer questions by identifying the question type and keywords, extracting a relevant passage from the given text, generating an answer based on the extracted passage, and then verifying the answer for correctness. It decomposes the problem into four distinct stages, each handled by a specific function acting as an agent. The functions involved are `main` which orchestrates the process, `analyze_question` which determines the question type and keywords, `extract_relevant_passage` which retrieves pertinent text, `generate_answer` which formulates the answer, `verify_answer` which checks the answer, and `call_llm` which interfaces with the Gemini LLM. The workflow begins with `main` calling `analyze_question`, followed by `extract_relevant_passage`, `generate_answer`, and finally `verify_answer`, with each function passing its output as input to the next, using `call_llm` to interact with the LLM in each step."
  },
  {
    "iteration": 5,
    "strategy": "Exploitation",
    "accuracy": 0.8,
    "approach": "This script uses a multi-stage LLM approach with techniques like question analysis, relevant passage extraction, answer generation, and verification. The problem is decomposed into analyzing the question, extracting the relevant passage, generating an initial answer, and then verifying that answer for correctness. The agent roles are implied by the function names, such as a question analyzer, passage extractor, answer generator, and answer verifier. Other functions used are `call_llm` which is used by the agent roles to call the LLM with specific prompts and system instructions.\n\nThe overall workflow begins with `main` calling `analyze_question` to determine the question type and keywords, then `extract_relevant_passage` uses this analysis to extract the most relevant information, then `generate_answer` uses the extracted passage and question analysis to generate an answer, and finally, `verify_answer` verifies the generated answer against the passage."
  },
  {
    "iteration": 6,
    "strategy": "Exploitation",
    "accuracy": 0.8,
    "approach": "The script uses a multi-stage LLM approach to answer questions by analyzing the question, extracting relevant information, generating an initial answer, and then verifying it. The problem is decomposed into four main steps: question analysis, passage extraction, answer generation, and answer verification, each leveraging a specific LLM agent role. The functions used are `main`, `analyze_question`, `extract_relevant_passage`, `generate_answer`, `verify_answer`, and `call_llm`. The workflow begins with `main` calling `analyze_question`, then `extract_relevant_passage` using the output of `analyze_question`, followed by `generate_answer` utilizing the outputs of the previous two functions, and finally `verify_answer` leveraging the outputs of `generate_answer` and `extract_relevant_passage` before returning the verified answer."
  }
]

        COMMON ERROR PATTERNS:
        []

        PRIMARY ISSUES (last 3 iterations):
        [
  {
    "iteration": 0,
    "issue": "The system fails when it needs to identify the \"second longest\" touchdown pass. This is due to it not correctly identifying all touchdown passes first and then ordering them by yardage before selecting the second item. The core problem is the lack of a process for systematically identifying all instances of an event and then applying ordering logic."
  },
  {
    "iteration": 1,
    "issue": "Because no errors were provided, the primary issue cannot be determined."
  },
  {
    "iteration": 2,
    "issue": "Without error cases, it is impossible to determine the single most critical problem."
  },
  {
    "iteration": 3,
    "issue": "The primary issue is the system's lack of a reliable mechanism for recognizing when a calculation (specifically aggregation or percentage calculation) is required and then executing that calculation to produce the final answer. Additionally the system often provides \"Correct\" as answers even when more specific information is expected."
  },
  {
    "iteration": 4,
    "issue": "The most critical problem is the system's inability to track and calculate the final scores of teams based on individual scoring plays described in the passage. This stems from a limitation in complex arithmetic reasoning and score aggregation."
  },
  {
    "iteration": 5,
    "issue": "The primary issue is the system's inability to correctly perform temporal reasoning, specifically calculating the time difference between events mentioned in the passage. This often involves correctly identifying the start and end points of the interval and then performing the subtraction."
  },
  {
    "iteration": 6,
    "issue": "The most critical problem is the **absence of a functional arithmetic reasoning component** that can identify and execute basic calculations based on extracted numerical information. This prevents the system from answering questions that go beyond simple information retrieval."
  }
]

        TARGETED IMPROVEMENTS:
        [
  "Accept a question and a list of extracted numerical values as input.",
  "Return the calculated result.",
  "Test Suite Expansion:** Develop a more comprehensive and diverse test suite, including challenging edge cases and adversarial examples.",
  "Extract the negotiation year.",
  "Extract the appointment year.",
  "Analyze the question for keywords indicating arithmetic operations (e.g., \"total,\" \"more than,\" \"difference\").",
  "Constraint Satisfaction:** Explicitly model constraints within the problem and ensure that the generated solutions adhere to them.",
  "Calculate the difference between the years.",
  "Perform the appropriate calculation based on the question and extracted values.",
  "Error Handling & Logging:** Implement more detailed error logging and tracing to diagnose and debug failures more effectively. Use of print statements during the operation to determine values of variables at particular steps."
]
        

EXAMPLE OF EFFECTIVE LLM USAGE PATTERNS:

```python
def extract_information_with_examples(text):
    """Extract key information from the input text using embedded examples."""
    system_instruction = "You are an information extraction specialist focusing on identifying key entities and relationships."
    
    prompt = f"""
    Extract key information from this text. Focus on identifying all entities, relationships, and important attributes.
    
    Example usage:
    
    Input Text:
    The company XYZ Corp reported quarterly earnings of $3.5 million, which represents a 12% increase from last year. The CEO, Jane Smith, attributed this growth to their new product line launched in March, which has already captured 8% of the market share. They expect to expand their operations to Europe by Q2 2023.
    
    Let's think step by step.
    
    The key entities are:
    - XYZ Corp (company)
    - Jane Smith (person, CEO)
    - New product line (product)
    
    The key information points are:
    - Financial: Quarterly earnings of $3.5 million
    - Performance: 12% increase from previous year
    - Product: New product line launched in March
    - Market: 8% market share for new product
    - Plans: Expansion to Europe by Q2 2023
    
    Extracted Information:
    {{
      "entities": [
        {{"name": "XYZ Corp", "type": "company"}},
        {{"name": "Jane Smith", "type": "person", "role": "CEO"}},
        {{"name": "New product line", "type": "product", "launch_date": "March"}}
      ],
      "financial_data": {{
        "quarterly_earnings": "$3.5 million",
        "growth_rate": "12%"
      }},
      "market_data": {{
        "product_market_share": "8%"
      }},
      "future_plans": [
        {{"type": "expansion", "region": "Europe", "timeline": "Q2 2023"}}
      ]
    }}
    
    Now, extract information from this new text:
    {text}
    """
    
    return call_llm(prompt, system_instruction)
```

```python
def verify_solution_with_examples(problem, proposed_solution):
    """Verify if the proposed solution satisfies all requirements using embedded examples."""
    system_instruction = "You are a critical evaluator who verifies if solutions correctly address problems."
    
    prompt = f"""
    Verify if this proposed solution correctly addresses all aspects of the problem.
    
    Example usage:
    
    Problem:
    Design a data structure that can efficiently perform the following operations:
    1. Insert a value
    2. Delete a value
    3. Get a random value with equal probability for all stored values
    All operations should have average time complexity of O(1).
    
    Proposed Solution:
    I'll use a combination of a hashmap and an array. The hashmap will store the value as the key and its index in the array as the value. The array will store all the inserted values.
    
    For insert: Add the value to the end of the array and update the hashmap with the value and its index. O(1) time.
    
    For delete: Look up the index of the value in the hashmap, swap the value with the last element in the array, update the hashmap for the swapped element, remove the last element from the array, and remove the value from the hashmap. O(1) time.
    
    For get random: Generate a random index within the array's bounds and return the value at that index. O(1) time.
    
    Verification:
    Let me check each requirement:
    1. Insert operation: The solution adds the value to the end of the array and updates the hashmap with O(1) time complexity ✓
    2. Delete operation: The solution uses the hashmap to find the index, then swaps with the last element and updates accordingly with O(1) time complexity ✓
    3. Get random operation: The solution generates a random index within the array bounds with O(1) time complexity ✓
    4. All operations have O(1) average time complexity ✓
    
    Result: VALID - The solution correctly addresses all requirements with the specified time complexity.
    
    Problem:
    {problem}
    
    Proposed Solution:
    {proposed_solution}
    
    Verification:
    """
    
    return call_llm(prompt, system_instruction)
```

```python
def solve_with_validation_loop(problem, max_attempts=3):
    """Solve a problem with iterative refinement through validation feedback loop."""
    system_instruction_solver = "You are an expert problem solver who creates detailed, correct solutions."
    system_instruction_validator = "You are a critical validator who carefully checks solutions against all requirements."
    
    # Initial solution generation
    solution_prompt = f"""
    Provide a detailed solution to this problem. Be thorough and ensure you address all requirements.
    
    Problem:
    {problem}
    """
    
    solution = call_llm(solution_prompt, system_instruction_solver)
    
    # Validation loop
    for attempt in range(max_attempts):
        # Validate the current solution
        validation_prompt = f"""
        Carefully validate if this solution correctly addresses all aspects of the problem.
        If the solution is valid, respond with "VALID: [brief reason]".
        If the solution has any issues, respond with "INVALID: [detailed explanation of issues]".
        
        Problem:
        {problem}
        
        Proposed Solution:
        {solution}
        """
        
        validation_result = call_llm(validation_prompt, system_instruction_validator)
        
        # Check if solution is valid
        if validation_result.startswith("VALID:"):
            return solution
        
        # If invalid, refine the solution
        refined_prompt = f"""
        Your previous solution to this problem has some issues that need to be addressed.
        
        Problem:
        {problem}
        
        Your previous solution:
        {solution}
        
        Validation feedback:
        {validation_result}
        
        Please provide a completely revised solution that addresses all the issues mentioned.
        """
        
        solution = call_llm(refined_prompt, system_instruction_solver)
    
    return solution
```

```python
def multi_perspective_analysis(problem):
    """Analyze a problem from multiple specialized perspectives and synthesize the insights."""
    # Define specialized analysis functions
    def analyze_factual_content(problem):
        system_instruction = "You are a factual analyst who focuses on identifying key facts and data points."
        prompt = f"""
        Analyze this problem for factual content only. Identify explicit facts, constraints, and requirements.
        
        Problem:
        {problem}
        """
        return call_llm(prompt, system_instruction)
    
    def analyze_structure(problem):
        system_instruction = "You are a structural analyst who specializes in problem organization and patterns."
        prompt = f"""
        Analyze the structure of this problem. Identify its components, relationships, and patterns.
        
        Problem:
        {problem}
        """
        return call_llm(prompt, system_instruction)
    
    # Execute parallel analyses
    factual_analysis = analyze_factual_content(problem)
    structural_analysis = analyze_structure(problem)
    
    # Synthesize the results
    synthesis_prompt = f"""
    Synthesize these two different analyses of the same problem into a comprehensive understanding.
    
    Factual Analysis:
    {factual_analysis}
    
    Structural Analysis:
    {structural_analysis}
    
    Provide a unified analysis that leverages both perspectives.
    """
    
    return call_llm(synthesis_prompt, "You are an insight synthesizer who combines multiple analyses.")
```

```python
def best_of_n_approach(problem, n=3):
    """Generate multiple solutions and select the best one based on a quality evaluation."""
    system_instruction_solver = "You are an expert problem solver who provides detailed, correct solutions."
    system_instruction_evaluator = "You are a quality evaluator who assesses solutions based on correctness, completeness, and clarity."
    
    # Generate n different solutions
    solutions = []
    for i in range(n):
        diversity_factor = f"Solution approach {i+1}/{n}: Use a different perspective from previous solutions."
        solution_prompt = f"""
        Provide a detailed solution to this problem.
        {diversity_factor if i > 0 else ""}
        
        Problem:
        {problem}
        """
        
        solutions.append(call_llm(solution_prompt, system_instruction_solver))
    
    # Evaluate each solution
    evaluations = []
    for i, solution in enumerate(solutions):
        evaluation_prompt = f"""
        Evaluate this solution on correctness, completeness, and clarity (1-10 scale).
        
        Problem:
        {problem}
        
        Solution {i+1}:
        {solution}
        
        Provide your evaluation as a JSON with scores and explanation.
        """
        
        evaluations.append(call_llm(evaluation_prompt, system_instruction_evaluator))
    
    # Find the best solution
    comparison_prompt = f"""
    Compare these solutions and their evaluations. Select the best one.
    
    Problem:
    {problem}
    
    {["Solution " + str(i+1) + ": " + solutions[i] + "\n\nEvaluation: " + evaluations[i] for i in range(n)]}
    
    Which solution is best? Respond with the solution number and explanation.
    """
    
    best_solution_index = int(call_llm(comparison_prompt, "You are a solution selector.").split()[1]) - 1
    return solutions[best_solution_index]
```

```python
def solve_with_react_pattern(problem):
    """Solve problems through iterative Reasoning and Acting (ReAct) approach."""
    system_instruction = "You are a problem-solving agent that follows the ReAct pattern: Reason about the current state, take an Action, observe the result, and repeat until reaching a solution."
    
    # Initialize ReAct process
    prompt = f"""
    Solve this problem using the ReAct pattern - alternate between Reasoning and Acting until you reach a final answer.
    
    Example usage:
    
    Problem: What is the capital of the country where the Great Barrier Reef is located, and what is the population of that capital?
    
    Thought 1: I need to determine which country the Great Barrier Reef is in, then find its capital, and finally the population of that capital.
    Action 1: Search[Great Barrier Reef location]
    Observation 1: The Great Barrier Reef is located off the coast of Queensland in northeastern Australia.
    
    Thought 2: Now I know the Great Barrier Reef is in Australia. I need to find Australia's capital city.
    Action 2: Search[capital of Australia]
    Observation 2: The capital of Australia is Canberra.
    
    Thought 3: Now I need to find the population of Canberra.
    Action 3: Search[population of Canberra]
    Observation 3: As of 2021, the population of Canberra is approximately 431,500.
    
    Thought 4: I have found all the required information. The capital of Australia (where the Great Barrier Reef is located) is Canberra, and its population is approximately 431,500.
    Action 4: Finish[The capital of Australia is Canberra, with a population of approximately 431,500.]
    
    Now solve this new problem:
    {problem}
    
    Start with Thought 1:
    """
    
    # Initial reasoning and action planning
    react_response = call_llm(prompt, system_instruction)
    
    # Extract the action from the response
    action = extract_action(react_response)
    
    # Continue the ReAct loop until we reach a "Finish" action
    while not action["type"] == "Finish":
        # Perform the requested action and get an observation
        if action["type"] == "Search":
            observation = perform_search(action["query"])
        elif action["type"] == "Calculate":
            observation = perform_calculation(action["expression"])
        elif action["type"] == "Lookup":
            observation = perform_lookup(action["term"])
        else:
            observation = f"Unknown action type: {action['type']}"
        
        # Continue the ReAct process with the new observation
        continuation_prompt = f"""
        {react_response}
        Observation {action["step_number"]}: {observation}
        
        Continue with the next thought and action:
        """
        
        # Get the next reasoning step and action
        react_response += "\n" + call_llm(continuation_prompt, system_instruction)
        
        # Extract the next action
        action = extract_action(react_response)
    
    # Extract the final answer from the Finish action
    final_answer = action["answer"]
    return final_answer

def extract_action(text):
    """Parse the ReAct response to extract the current action."""
    # Find the last action in the text
    action_matches = re.findall(r"Action (\d+): (\w+)\[(.*?)\]", text)
    if not action_matches:
        return {"type": "Error", "step_number": 0, "query": "No action found"}
    
    # Get the most recent action
    last_action = action_matches[-1]
    step_number = int(last_action[0])
    action_type = last_action[1]
    action_content = last_action[2]
    
    # Handle different action types
    if action_type == "Finish":
        return {"type": "Finish", "step_number": step_number, "answer": action_content}
    elif action_type in ["Search", "Lookup", "Calculate"]:
        return {"type": action_type, "step_number": step_number, "query": action_content}
    else:
        return {"type": "Unknown", "step_number": step_number, "query": action_content}

def perform_search(query):
    """Simulate a search action in the ReAct pattern."""
    # In a real implementation, this would call an actual search API
    return call_llm(f"Provide a factual answer about: {query}", "You are a helpful search engine that provides concise, factual information.")

def perform_calculation(expression):
    """Perform a calculation action in the ReAct pattern."""
    try:
        # Safely evaluate the expression
        result = eval(expression, {"__builtins__": {}}, {"math": math})
        return f"The result is {result}"
    except Exception as e:
        return f"Error in calculation: {str(e)}"

def perform_lookup(term):
    """Simulate a lookup action for specific information."""
    # In a real implementation, this would query a knowledge base or database
    return call_llm(f"Provide specific information about: {term}", "You are a knowledge base that provides specific factual information.")
```MULTI-EXAMPLE PROMPTING GUIDANCE:
        1. CRITICAL: Use MULTIPLE examples (2-5) in EVERY LLM prompt, not just one
        2. Vary the number of examples based on task complexity - more complex tasks need more examples
        3. Select diverse examples that showcase different patterns and edge cases
        4. Structure your few-shot examples to demonstrate clear step-by-step reasoning
        5. Consider using both "easy" and "challenging" examples to help the LLM learn from contrasts
        6. The collection of examples should collectively cover all key aspects of the problem
        7. When available, use examples from previous iterations that revealed specific strengths or weaknesses.
        8. USE REAL EXAMPLES FROM THE DATASET WHERE POSSIBLE!!

        Example of poor single-example prompting:
        ```python
        def extract_entities(text):
            prompt = f'''
            Extract entities from this text.

            Example:
            Text: John will meet Mary at 3pm on Tuesday.
            Entities: {{"people": ["John", "Mary"], "time": "3pm", "day": "Tuesday"}}

            Text: {text}
            Entities:
            '''
            return call_llm(prompt)
        ```

        Example of effective multi-example prompting:
        ```python
        def extract_entities(text):
            prompt = f'''
            Extract entities from this text.

            Example 1:
            Text: John will meet Mary at 3pm on Tuesday.
            Entities: {{"people": ["John", "Mary"], "time": "3pm", "day": "Tuesday"}}

            Example 2:
            Text: The team needs to submit the report by Friday at noon.
            Entities: {{"people": ["the team"], "time": "noon", "day": "Friday", "object": "report"}}

            Example 3:
            Text: Alex cannot attend the conference from Jan 3-5 due to prior commitments.
            Entities: {{"people": ["Alex"], "event": "conference", "date_range": ["Jan 3-5"], "reason": "prior commitments"}}

            Text: {text}
            Entities:
            '''
            return call_llm(prompt)
        ```

        === DIRECT LLM REASONING APPROACH ===

        CRITICAL: Previous scripts have shown that complex code generation with JSON parsing and multi-step pipelines often 
        leads to errors and low performance. Instead, focus on leveraging the LLM's natural reasoning abilities:

        1. SIMPLIFY YOUR APPROACH:
           - Minimize the number of processing steps - simpler is better
           - Directly use LLM for pattern recognition rather than writing complex code
           - Avoid trying to parse or manipulate JSON manually - pass it as text to the LLM

        2. DIRECT TRANSFORMATION:
           - Instead of trying to extract features and then apply them, use the LLM to do the transformation directly
           - Use examples to teach the LLM the pattern, then have it apply that pattern to new inputs
           - Avoid attempting to write complex algorithmic solutions when pattern recognition will work better

        3. ROBUST ERROR HANDLING:
           - Include multiple approaches in case one fails (direct approach + fallback approach)
           - Use simple validation to check if outputs are in the expected format
           - Include a last-resort approach that will always return something valid

        4. AVOID COMMON PITFALLS:
           - Do NOT attempt to use json.loads() or complex JSON parsing - it often fails
           - Do NOT create overly complex Python pipelines that require perfect indentation
           - Do NOT create functions that generate or execute dynamic code
           - Do NOT create unnecessarily complex data transformations

        5. SUCCESSFUL EXAMPLES:
           - The most successful approaches have used direct pattern matching with multiple examples
           - Scripts with simple validation and fallback approaches perform better
           - Scripts with fewer processing steps have higher success rates
        
        IMPLEMENTATION STRATEGIES:
        1. Maintain a "example bank" of successful and failed examples to select from
        2. Implement n-shot prompting with n=3 as default, but adapt based on performance
        3. For complex tasks, use up to 5 examples; for simpler tasks, 2-3 may be sufficient
        4. Include examples with a range of complexity levels, rather than all similar examples



        VALIDATION AND VERIFICATION GUIDANCE:
        1. CRITICAL: Consider implementing validation loops for EACH key processing step, not just final outputs
        2. Design your system to detect, diagnose, and recover from specific errors. This will help future learnings
        3. For every LLM extraction or generation, add a verification step that checks:
           - Whether the output is well-formed and complete
           - Whether the output is logically consistent with the input
           - Whether all constraints are satisfied
        4. Add feedback loops that retry failures with specific feedback
        5. Include diagnostic outputs that reveal exactly where failures occur. Add print statements and intermediate outputs such that you can see them later to determine why things are going wrong.
        6. Include capability to trace through execution steps to identify failure points

        Example of pipeline without verification:
        ```python
        def process_question(question):
            entities = extract_entities(question)
            constraints = identify_constraints(question)
            solution = generate_solution(entities, constraints)
            return solution
        ```

        Example of robust pipeline with verification:
        ```python
        def process_question(question, max_attempts=3):
            # Step 1: Extract entities with verification
            entities_result = extract_entities_with_verification(question)
            if not entities_result.get("is_valid"):
                print(f"Entity extraction failed: {entities_result.get('validation_feedback')}")
                return f"Error in entity extraction: {entities_result.get('validation_feedback')}"

            # Step 2: Identify constraints with verification
            constraints_result = identify_constraints_with_verification(question, entities_result["entities"])
            if not constraints_result.get("is_valid"):
                print(f"Constraint identification failed: {constraints_result.get('validation_feedback')}")
                return f"Error in constraint identification: {constraints_result.get('validation_feedback')}"

            # Step 3: Generate solution with verification
            solution_result = generate_solution_with_verification(
                question, 
                entities_result["entities"], 
                constraints_result["constraints"]
            )
            if not solution_result.get("is_valid"):
                print(f"Solution generation failed: {solution_result.get('validation_feedback')}")
                return f"Error in solution generation: {solution_result.get('validation_feedback')}"

            return solution_result["solution"]

        def extract_entities_with_verification(question, max_attempts=3):
            #Extract entities and verify their validity with feedback loop.
            system_instruction = "You are an expert at extracting and validating entities."

            for attempt in range(max_attempts):
                # First attempt at extraction
                extraction_prompt = f'''
                Extract key entities from this question. 
                Return a JSON object with the extracted entities.

                Example 1: [example with entities]
                Example 2: [example with different entities]
                Example 3: [example with complex entities]

                Question: {question}
                Extraction:
                '''

                extracted_data = call_llm(extraction_prompt, system_instruction)

                try:
                    # Parse the extraction
                    data = json.loads(extracted_data)

                    # Verification step
                    verification_prompt = f'''
                    Verify if these extracted entities are complete and correct:

                    Question: {question}
                    Extracted entities: {json.dumps(data, indent=2)}

                    Check if:
                    1. All relevant entities are extracted
                    2. No irrelevant entities are included
                    3. All entity values are correct

                    Return a JSON with:
                    {{
                      "is_valid": true/false,
                      "validation_feedback": "detailed explanation",
                      "missing_entities": ["entity1", "entity2"],
                      "incorrect_entities": ["entity3"]
                    }}
                    '''

                    verification_result = call_llm(verification_prompt, system_instruction)
                    verification_data = json.loads(verification_result)

                    if verification_data.get("is_valid", False):
                        data["is_valid"] = True
                        data["validation_feedback"] = "All entities are valid."
                        return data

                    # If not valid and we have attempts left, refine with feedback
                    if attempt < max_attempts - 1:
                        feedback = verification_data.get("validation_feedback", "")
                        print(f"Validation failed (attempt {attempt+1}/{max_attempts}): {feedback}")
                        continue

                    # If we're out of attempts, return the best we have with validation info
                    data["is_valid"] = False
                    data["validation_feedback"] = verification_data.get("validation_feedback", "Unknown validation error")
                    return data

                except Exception as e:
                    print(f"Error in extraction/validation (attempt {attempt+1}/{max_attempts}): {str(e)}")
                    if attempt >= max_attempts - 1:
                        return {
                            "is_valid": False,
                            "validation_feedback": f"Error during processing: {str(e)}"
                        }

            return {
                "is_valid": False,
                "validation_feedback": "Failed to extract valid entities after multiple attempts."
            }
        ```

        VALIDATION IMPLEMENTATION STRATEGIES:
        1. Create detailed verification functions for each major processing step
        2. Implement max_attempts limits on all retry loops (typically 3-5 attempts)
        3. Pass specific feedback from verification to subsequent retry attempts
        4. Log all verification failures to help identify systemic issues
        5. Design fallback behaviors when verification repeatedly fails

        

            
        ACCUMULATED LEARNINGS FROM PREVIOUS ITERATIONS:
        ```
# DATASET-SPECIFIC LEARNINGS & EXPERIMENT LOG

This document serves as a running log of our learnings, experiments, and findings specific to the question-answering task on this particular dataset of sports narratives and demographic data.

## 1. DATASET PATTERNS & CHARACTERISTICS

*   **Question Structure:** Questions are consistently formatted as `PASSAGE:\n... \n\nQUESTION: ...`. This structure clearly separates the context from the query.

*   **Passage Content:** Passages consist of narratives describing sports games (primarily American football) or demographic data. They provide the context needed to answer the questions. Passages exhibit variability in content (sports, demographics, geography, nickel production) and length. Passages often take the form of narratives describing events, which can be challenging for precise information extraction required for quantitative comparisons. Passages contain extraneous information, necessitating accurate identification and extraction of only the relevant details.

*   **Answer Types:** Answers are typically concise and factual, directly extracted or derived from the passage. Common answer types include proper nouns (player names), numerical values (counts, yardage, rates), and dates.

*   **Question Types:**
    *   **Fact Extraction:** Directly retrieving information from the passage (e.g., "Who caught the final touchdown of the game?", "How many receiving yards...").
    *   **Counting:** Determining the number of occurrences of an event or entity (e.g., "How many running backs ran for a touchdown?").
    *   **Calculation:** Performing arithmetic operations on values extracted from the passage (e.g., "How many yards did Chris Johnson's first touchdown and Jason Hanson's first field goal combine for?"). Requires unit awareness.
    *   **Comparison/Difference:** Comparing values or entities described in the passage (e.g., "How many more TFR did Malays have in 2004 compared to Ethnic Chinese TFR in 2004?", "How many yards longer..."). Requires numerical reasoning or extraction of specific numbers from the passage (e.g., "How many field goals?", "How many in percent..."). Often requires extracting multiple numerical values and performing comparisons.
    *   **Ordinality:** Questions may include ordinal terms like "second longest", requiring ranking and comparison.
    *   **Multiple Instances:** Question has multiple valid answers in the passage (e.g., "List all the countries...").
    *   **Score Tracking:** Questions that require tracking and aggregating scores based on individual plays or events described in the passage. These questions do not explicitly state "what was the final score" but require addition/subtraction of point values.
    *   **Implicit Numerical Reasoning:** Questions require *implicit* numerical reasoning or inference. For example, extracting individual point values, and combining them to determine a final score.
    *   **Temporal Reasoning:** Questions often involve temporal aspects, requiring understanding the sequence of events (e.g., "final touchdown," "first field goal"). The passages often present information in chronological order. This can also involve calculating the duration between two events, which necessitates identifying start and end dates and performing subtraction (e.g., calculating the number of years between Colorado becoming a state (August 1, 1876) and the creation of its last county (2001)).
    *   **Complex Date/Event Identification:** Correctly pinpointing the exact start and end dates of events can be challenging due to varied phrasing and implied timelines within the passages. The passages contain many dates and events, requiring careful extraction.
    *   **Holistic Understanding for Final Score Calculation:** Some questions require a holistic understanding of the passage in order to determine the final score by analyzing the scoring events described in the passage.

*   **Implicit Information:** The answer might need to be inferred based on multiple pieces of information, requiring the model to synthesize information from different parts of the passage.

*   **Extraneous Information:** Passages often contain rich contextual details that are irrelevant to the question, requiring the model to filter out noise.

*   **Synonyms and Paraphrasing:** The question might use different wording than the passage to refer to the same entity or event.

*   **Multiple Occurrences:** An event (e.g., a touchdown) might occur multiple times; the question could be specific about which occurrence to consider (e.g., "first," "last," "second longest").

*   **Negation:** Questions like "Who did *not* score a touchdown?" require careful handling of negated conditions.

*   **Units:** Need to be aware of units when performing calculations (yards, points, etc.)

*   **Numerical Reasoning Requirement:** A significant portion of questions requires numerical reasoning, including summation, percentage calculations, or other basic arithmetic operations, even when the information is explicitly available in the provided passage. The questions often involve quantities, counts, or proportions extracted from the passage text.

*   **Ambiguity in Expected Answer Granularity:** The "correctness" of an answer can be subjective, particularly when the system provides the correct components of the answer without performing the required calculation. The golden answer might expect a single aggregated number, while the system provides the disaggregated components, leading to a mismatch even though the system extracted the right information. For example, providing "12 Dutch and 10 English" when the answer is expected to be "22".

*   **Census and Demographics Questions:** The presence of census-related questions which frequently require percentage or difference calculations based on population data.

## 2. EFFECTIVE TASK-SPECIFIC STRATEGIES

*   **Multi-Stage Approach:** A multi-stage approach, involving question analysis, passage retrieval/extraction, answer generation, and verification, shows promise. This allows for breaking down the complex task into smaller, manageable components.
    *   Breaking down the problem into question type identification, focused passage extraction, answer generation, and verification helps. This is particularly helpful where numerical or multi-step reasoning is required. Accuracy was 1.00 using this approach in Iteration 1 & 2. The multi-stage LLM approach appears to be effective for initial extraction and analysis. The 90% accuracy in Iteration 4 suggests that analyzing questions, extracting relevant passages, and generating simple answers are generally successful. However, its effectiveness is currently limited by the lack of arithmetic reasoning. The modularity allows for focused improvement of specific stages.
    *   Using separate LLM calls for each subtask (analyze, extract, generate, verify) isolates errors and allows for targeted improvements. This was implemented and effective in Iteration 2.
    *   Decomposing the problem into smaller steps, each handled by a dedicated function (agent), likely contributes to the initial success by isolating concerns and simplifying individual tasks.

*   **Chain-of-Thought Prompting (LLM-focused):** Encouraging the LLM to explicitly show its reasoning steps (e.g., using "Let's think step by step:") can improve accuracy and allow for debugging. Example:

    ```
    PASSAGE: ...

    QUESTION: How many yards did Chris Johnson's first touchdown and Jason Hanson's first field goal combine for?

    Let's think step by step:
    First, I need to identify Chris Johnson's first touchdown yardage. The passage says "Chris Johnson got a 6-yard TD run".
    Second, I need to identify Jason Hanson's first field goal yardage. The passage says "Jason Hanson getting a 53-yard field goal."
    Finally, I need to add those two numbers. 6 + 53 = 59.
    ANSWER: 59
    ```
    *   Hypothesis: Chain-of-thought prompting enhances the LLM's ability to reason and extract information from the passages. (Confirmed for at least a subset of questions in Iteration 1).

*   **Example-Driven Reasoning (LLM-focused):** Providing the LLM with a few examples of questions and answers to guide its reasoning is effective. Suggests that the LLM benefits from having examples of how to handle different question types. This was shown to be effective in Iteration 2.

*   **Few-Shot Learning (LLM-focused):** Providing the LLM with a few examples of questions and answers to guide its reasoning.

*   **Answer Validation Prompt (LLM-focused):** Using a separate prompt to validate the generated answer. This prompt could ask the LLM to justify its answer based on the passage.

*   **Constrained Decoding (LLM-focused):** If the answer is known to be a number, use constrained decoding to ensure that the LLM only generates numerical answers.

*   **Explicit Scoring Rule Definition:** Explicitly define the scoring rules for each type of play in prompt engineering to provide context for the LLM to calculate final scores. (Next Step from Iteration 4).

## 3. COMMON FAILURE MODES ON THIS DATASET

*   **Missing Arithmetic Reasoning:** The system fails when questions require numerical computation. For example, in the question about the Ravens and Steelers score, the system couldn't deduce the final scores from the game events and calculate the difference, leading to the response "There is not enough information."
*   **Incorrect Date Identification:** The system struggles to consistently identify the correct start and end dates for calculating time differences. For example, the system failed to extract the correct start date of "the time Colorada was declared a state" (August 1, 1876) and the end date of when "it's last county was created" (2001).
*   **Inaccurate Handling of Ordinality:** Inability to correctly answer questions involving ordinality (e.g., "second longest"). The system often fails to systematically identify all instances of the relevant event, extract the relevant attribute, order them, and then select the item at the specified ordinal position. Instead, it appears to make direct, often incorrect, guesses based on incomplete context.

*   **Failure to Extract All Relevant Instances:** The system sometimes fails to identify all instances of events related to the question, leading to incomplete information for comparisons and ordinal ranking.

*   **Inability to Filter Extraneous Information:** Difficulty in filtering out irrelevant details from the passage, leading to confusion and incorrect answers.

*   **Arithmetic Errors:** Mistakes in performing calculations. Now a significant and recurring problem. As an example, even when correct dates were identified, the subtraction of 1876 from 2001 was not performed accurately.

*   **Missing Numerical Aggregation:** The system fails when questions require combining multiple numbers from the passage into a single answer (e.g., summing counts of different items). It extracts the individual numbers but doesn't perform the necessary calculation. *Example:* The question "How many Dutch and English warships were blocking Spanish support?" expects the sum of 12 Dutch and 10 English warships (22), but the system returns "12 Dutch and 10 English". Observed in Iteration 3.

*   **Lack of Calculation Awareness and Execution:** The system is not reliably detecting the need for any calculation. *Example:* The question "How many in percent from the census weren't African American?" requires subtracting the percentage of African Americans from 100%, but the system fails to perform this operation and gives 2.8% instead of 97.2%. Observed in Iteration 3.

*   **Ambiguity Resolution:** Difficulty in disambiguating similar information or names within the passage.

*   **Incomplete Information Inference:** Failing to correctly infer the answer when it requires synthesizing information from multiple parts of the passage.

*   **Lack of Specificity:** The system returns a canned phrase that the answer is correct, without stating the answer. *Example:* When asked "Which areas did Louis IX give to Henry III?", the system answers "The answer is correct." instead of the expected answer which is: "Limoges, Cahors, and Périgueux". Observed in Iteration 3. This renders the information useless.

*   **Arithmetic Reasoning and Aggregation:** The primary failure mode, as highlighted in Iteration 4, is the inability to perform complex arithmetic reasoning to aggregate scores based on the narrative descriptions in the passage. The system fails when it needs to keep track of running totals and calculate the final difference between scores.

*   **Implicit Numerical Reasoning:** The system struggles when the question requires *implicit* numerical reasoning or inference. For example, it can extract individual point values, but not combine them to determine a final score.

*   **Misinterpreting Data:** The system misinterpreted the question "How many total points were scored in the game?" and therefore did not successfully parse the result in the passage to extract the correct result.

*   **Potential Failure Modes (Anticipated based on dataset characteristics):**
    *   *Numerical Reasoning Errors:* Questions involving more complex arithmetic (e.g., multiple steps, percentages) could lead to incorrect answers. This has now been confirmed to be a significant issue.
    *   *Ambiguous or Vague Questions:* Questions that are not clearly worded or require significant inference could be misinterpreted by the question analysis module.
    *   *Passage Extraction Errors:* If the relevant passage is not correctly identified, the subsequent answer generation will be flawed.  This could happen if keywords are ambiguous or if the passage requires deeper understanding.
    *   *Verification Errors:* The verification step could fail to detect subtle inaccuracies or inconsistencies in the generated answer.

## 4. EXPERIMENT LOG & FINDINGS

*   **2025-05-19 14:27:04 - INITIAL DATASET ANALYSIS:** Comprehensive analysis of dataset characteristics, challenges, potential approaches, and implementation recommendations. (See full analysis in original entry). Key findings included:
    *   The importance of understanding the question type (extraction, counting, calculation, comparison).
    *   The need for temporal reasoning and arithmetic reasoning.
    *   Potential solution strategies: information retrieval & extraction, direct answer generation.
    *   Decomposition steps: question understanding, relevant passage identification, information extraction/calculation, answer formatting.
    *   Validation techniques: self-consistency checks, units checks, reasonableness checks.

*   **ITERATION 0:** Initial multi-stage approach achieved 67% accuracy. Highlighted the need for improved handling of questions involving comparisons and ordinality. The system needs mechanisms for systematically extracting and processing multiple instances of events from the passage.

*   **ITERATION 1:** Achieved 1.0 accuracy using a multi-stage LLM approach with chain-of-thought prompting.
    *   The approach proved highly effective for the tested subset of the dataset.

*   **ITERATION 2:** Achieved 1.0 accuracy using a multi-stage LLM approach with example-driven reasoning.
    *   The modular approach (analyzing question, extracting passage, generating answer, verifying) seems to be effective.
    *   Using separate LLM calls for each subtask (analyze, extract, generate, verify) likely isolates errors and allows for targeted improvements.

*   **ITERATION 3:** The multi-stage LLM approach, in its current implementation, struggles with questions that necessitate any form of numerical calculation or aggregation, even when the component numbers are correctly extracted from the passage.
    *   The hypothesis that LLMs can inherently perform complex reasoning from raw text is rejected, at least without explicit instruction and verification steps targeted at numerical operations.
    *   The system also exhibited a tendency to answer "The answer is correct" instead of providing the actual answer.

*   **ITERATION 4:** The initial hypothesis that a multi-stage LLM approach can effectively answer questions based on text passages is partially confirmed. The system achieves high accuracy on simpler questions but fails when arithmetic reasoning is involved (90% accuracy on simpler questions).
    *   The hypothesis that the current multi-stage approach is sufficient for all types of questions is rejected, as demonstrated by the failure to handle questions requiring score tracking and comparison.

*   **ITERATION 5:** The "exploitation" strategy, while generally aiming to leverage previously successful patterns, does not adequately address the specific challenges of temporal reasoning and arithmetic calculation present in this dataset. The 80% accuracy indicates a ceiling is being reached with the current approach.

*   **ITERATION 6:** The multi-stage LLM approach shows promise in decomposing the problem but needs to be augmented with a dedicated arithmetic reasoning component to solve quantitative questions. It is effective for simple information retrieval but insufficient for questions requiring calculations based on the extracted information. Errors occur primarily in the "generate" and "verify" stages due to the lack of arithmetic capability.

## 5. NEXT RESEARCH DIRECTIONS

*   **Implement an Arithmetic Reasoning Module:** Introduce a module specifically designed for identifying numerical values, understanding the required calculations, and executing those calculations. This module could be integrated into the "generate\_answer" function.
*   **Improve Score Interpretation:** Improve the ability of the models to extract the relevant scoring information and distinguish what each event implies about the numerical score.
*   **Enhance Verification:** Augment the "verify\_answer" function to check not only the factual correctness but also the numerical validity of the answer given the extracted information. This would involve checking if the calculated answer is consistent with the numbers found in the passage.
*   **Implement a Date Normalization Module:** Develop a module that can reliably extract and normalize dates from the passage text into a standard format (YYYY-MM-DD) to ensure consistent date representation.
*   **Arithmetic Solver Module:** Integrate a simple arithmetic solver module that takes two dates as input and calculates the difference in years, months, or days, as required by the question. This will offload the arithmetic calculation from the LLM, reducing the risk of errors.
*   **Hybrid Approach:** Experiment with a hybrid approach that combines LLM-based reasoning with specialized modules for date extraction and arithmetic calculation. The LLM can focus on identifying the relevant events and dates, while the specialized modules handle the actual calculations.
*   **Implement Score Tracking Agent:** Introduce a "Score Tracker" agent specifically designed to track and update scores based on the narrative descriptions in the passage. This agent should be capable of identifying scoring events (touchdowns, field goals, etc.) and updating the scores accordingly. (Next Step from Iteration 4).

*   **Incorporate Numerical Reasoning Module:** Integrate a numerical reasoning module within the "Generate Answer" agent. This module should be capable of performing simple arithmetic operations (addition, subtraction, comparison) on extracted numerical values to answer questions requiring quantitative analysis. (Next Step from Iteration 4).

*   **Refine Passage Extraction:** Enhance the "Extract Relevant Passage" agent to specifically identify and extract sections of the passage that describe scoring events or relevant numerical data. This can improve the accuracy of subsequent reasoning steps. (Next Step from Iteration 4).

*   **Improve Ordinality Handling:**
    *   Modify the `extract_relevant_passage` function to identify *all* instances of events related to the question.
    *   Introduce a new function, `rank_answers`, that orders extracted information based on a specific criteria (e.g., yardage).
    *   Update the `analyze_question` function to specifically identify questions requiring ranking or comparison. If identified, flag the question for processing by the `rank_answers` function.
    *   In `generate_answer`, incorporate a step to select the correct ranked answer based on the ordinality requested in the question (e.g., "second longest").
    *   Add unit tests specifically targeting questions involving ordinality and comparisons to ensure the system can accurately rank and select answers.

*   **Enhance Information Extraction:** Investigate techniques for improving the accuracy and completeness of information extraction, including named entity recognition, dependency parsing, and semantic role labeling.

*   **Implement a Robust Validation Step:** Develop a more sophisticated validation step to catch errors before the final answer is generated. This could involve verifying units, checking for consistency with the passage, and assessing the reasonableness of the answer. Add adversarial examples designed to trick the verification step.

*   **Explore Different LLM Prompting Strategies:** Experiment with different prompting strategies to improve the LLM's reasoning abilities, including chain-of-thought prompting, few-shot learning, and answer validation prompts.

*   **Develop a More Sophisticated Question Analyzer:** Improve the `analyze_question` function to better identify the type of reasoning required to answer the question, including temporal reasoning, arithmetic reasoning, and logical reasoning.

*   **Implement Calculation Detection Module:** Introduce a module within the `analyze_question` function to explicitly identify questions requiring calculation. This module should flag the question type (summation, percentage, difference, etc.) and the involved entities. This is CRITICAL based on Iteration 3 results.

*   **Calculation Execution Module:** If the calculation detection module flags a question, activate a "calculation execution" module. This module will perform the identified calculation using the extracted numbers from the `extract_relevant_passage` step. The module should have error handling and verification to catch incorrect calculations. This is CRITICAL based on Iteration 3 results.

*   **Enhance Answer Generation:** Modify the `generate_answer` function to prioritize providing explicit numerical answers when a calculation is detected, instead of relying on potentially ambiguous textual descriptions.

*   **Post-Processing Numeric Answers:** Implement a post-processing step to ensure that numeric answers are formatted correctly and include appropriate units (e.g., "%" sign for percentages).

*   **Explicit Answer Reporting:** Make sure the `generate_answer` provides the answer and not just a verification of the correctness.

*   **Expand Dataset for Stress-Testing:** Expand the dataset with new question types, more complex reasoning problems, passages with ambiguous or contradictory information, and passages containing data requiring external knowledge (dates, names, etc.) to further stress-test the system and identify failure points. Specifically:
    *   Introduce more complex or ambiguous questions that require more advanced reasoning or inference.
    *   Stress-test numerical reasoning with questions requiring multi-step calculations, unit conversions, or proportional reasoning.
    *   Test how well the passage retrieval works when the question has multiple valid answers in the passage (e.g., "List all the countries...").

*   **Evaluate the impact of different LLMs:** Experiment with different LLMs (e.g., GPT-4, Claude) to see if performance can be further improved or if certain LLMs are better suited for specific subtasks.

*   **Analyze the verification module:** Examine how the verification step is implemented and how robust it is to different types of errors.
```
        

            
        CAPABILITY ASSESSMENT & IMPROVEMENT GUIDANCE:
        SYSTEM ANALYSIS & GUIDANCE


        

            TOP PERFORMING APPROACHES TO BUILD UPON:
            
TOP PERFORMING APPROACH #1:
Iteration: 1
Accuracy: 1.00
Approach Summary: The script uses a multi-stage LLM approach with chain-of-thought prompting to answer questions by identifying the question type, extracting relevant information, generating an answer, and then verifying the answer. The script uses the following functions: `main` orchestrates the entire process, `analyze_question` identifies the question type and keywords, `extract_relevant_passage` retrieves relevant text, `generate_answer` formulates an initial answer, `verify_answer` validates the answer, and `call_llm` interacts with the Gemini LLM, using system instructions and prompts to guide the LLM's reasoning at each step. The workflow starts with `main` calling `analyze_question`, followed by `extract_relevant_passage`, `generate_answer`, and `verify_answer`, each leveraging `call_llm` to interact with the LLM.

FULL SCRIPT TO REFINE:
```python
import os
import re
import math

def main(question):
    """
    Solve the question using a multi-stage LLM approach.
    This approach focuses on breaking down the problem into question type identification, 
    focused passage extraction, and direct answer generation with verification.
    """
    try:
        # Step 1: Identify question type and keywords
        question_analysis = analyze_question(question)
        if "Error" in question_analysis:
            return "Error analyzing question"

        # Step 2: Extract relevant passage using identified keywords
        relevant_passage = extract_relevant_passage(question, question_analysis)
        if "Error" in relevant_passage:
            return "Error extracting passage"

        # Step 3: Generate answer using extracted passage and question type
        answer = generate_answer(question, relevant_passage, question_analysis)
        if "Error" in answer:
            return "Error generating answer"

        # Step 4: Verify answer
        verified_answer = verify_answer(question, answer, relevant_passage)
        if "Error" in verified_answer:
            return "Error verifying answer"
        
        return verified_answer

    except Exception as e:
        return f"General Error: {str(e)}"

def analyze_question(question):
    """Analyzes the question to identify its type and keywords. Includes multiple examples."""
    system_instruction = "You are an expert at analyzing questions to determine their type and keywords."
    prompt = f"""
    Analyze the following question and identify its type (e.g., fact extraction, calculation, comparison) and keywords.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Analysis: {{"type": "fact extraction", "keywords": ["final touchdown", "caught"]}}

    Example 2:
    Question: How many running backs ran for a touchdown?
    Analysis: {{"type": "counting", "keywords": ["running backs", "touchdown"]}}
    
    Example 3:
    Question: Which player kicked the only field goal of the game?
    Analysis: {{"type": "fact extraction", "keywords": ["player", "field goal"]}}

    Question: {question}
    Analysis:
    """
    return call_llm(prompt, system_instruction)

def extract_relevant_passage(question, question_analysis):
    """Extracts the relevant passage from the question based on keywords. Includes multiple examples."""
    system_instruction = "You are an expert at extracting relevant passages from text."
    prompt = f"""
    Extract the relevant passage from the following text based on the question and keywords.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Keywords: {{"type": "fact extraction", "keywords": ["final touchdown", "caught"]}}
    Text: PASSAGE: After a tough loss at home, the Browns traveled to take on the Packers. ... The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    Passage: The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    
    Example 2:
    Question: How many running backs ran for a touchdown?
    Keywords: {{"type": "counting", "keywords": ["running backs", "touchdown"]}}
    Text: PASSAGE: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. The Lions would respond with kicker Jason Hanson getting a 53-yard field goal. The Titans would answer with Johnson getting a 58-yard TD run, along with DE Dave Ball returning an interception 15 yards for a touchdown. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.
    Passage: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.

    Example 3:
    Question: Which player kicked the only field goal of the game?
    Keywords: {{"type": "fact extraction", "keywords": ["player", "field goal"]}}
    Text: PASSAGE: Game SummaryComing off their Thanksgiving road win over the Falcons, the Colts went home for a Week 13 AFC South rematch with the Jacksonville Jaguars.  ... In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.
    Passage: In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.

    Question: {question}
    Keywords: {question_analysis}
    Text: {question}
    Passage:
    """
    return call_llm(prompt, system_instruction)

def generate_answer(question, relevant_passage, question_analysis):
    """Generates the answer based on the question, relevant passage, and question type. Includes multiple examples."""
    system_instruction = "You are an expert at generating answers to questions based on provided text."
    prompt = f"""
    Generate the answer to the question based on the relevant passage and question type.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Passage: The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    Answer: Jarrett Boykin

    Example 2:
    Question: How many running backs ran for a touchdown?
    Passage: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. The Lions would respond with kicker Jason Hanson getting a 53-yard field goal. The Titans would answer with Johnson getting a 58-yard TD run, along with DE Dave Ball returning an interception 15 yards for a touchdown. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.
    Answer: 2
    
    Example 3:
    Question: Which player kicked the only field goal of the game?
    Passage: In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.
    Answer: Josh Scobee

    Question: {question}
    Passage: {relevant_passage}
    Answer:
    """
    return call_llm(prompt, system_instruction)

def verify_answer(question, answer, relevant_passage):
    """Verifies the generated answer. Includes multiple examples."""
    system_instruction = "You are an expert at verifying answers to questions."
    prompt = f"""
    Verify the following answer to the question based on the relevant passage.  Return the answer if it is correct.  Return the correct answer if it is incorrect.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Answer: Jarrett Boykin
    Passage: The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    Verification: Jarrett Boykin
    
    Example 2:
    Question: How many running backs ran for a touchdown?
    Answer: 2
    Passage: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.
    Verification: 2

    Example 3:
    Question: Which player kicked the only field goal of the game?
    Answer: Josh Scobee
    Passage: In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.
    Verification: Josh Scobee

    Question: {question}
    Answer: {answer}
    Passage: {relevant_passage}
    Verification:
    """
    return call_llm(prompt, system_instruction)

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. DO NOT deviate from this example template or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"
```

TOP PERFORMING APPROACH #2:
Iteration: 2
Accuracy: 1.00
Approach Summary: The script uses a multi-stage LLM approach with example-driven reasoning to answer questions, incorporating question analysis, information extraction, answer generation, and verification. The problem is decomposed into four main steps: analyzing the question, extracting a relevant passage, generating an answer, and verifying the answer, each handled by a separate function. There are no agent roles indicated in the script. The script uses `analyze_question` to identify the question type and keywords, `extract_relevant_passage` to find the relevant information, `generate_answer` to form an answer, `verify_answer` to confirm its correctness, and `call_llm` to interface with the Gemini LLM. The overall workflow involves analyzing the question, extracting relevant information, generating an initial answer, verifying it for accuracy, and then returning the verified answer.

Key approach aspects (full code available for reference)

TOP PERFORMING APPROACH #3:
Iteration: 4
Accuracy: 0.90
Approach Summary: The script employs a multi-stage, LLM-driven approach to answer questions by identifying the question type and keywords, extracting a relevant passage from the given text, generating an answer based on the extracted passage, and then verifying the answer for correctness. It decomposes the problem into four distinct stages, each handled by a specific function acting as an agent. The functions involved are `main` which orchestrates the process, `analyze_question` which determines the question type and keywords, `extract_relevant_passage` which retrieves pertinent text, `generate_answer` which formulates the answer, `verify_answer` which checks the answer, and `call_llm` which interfaces with the Gemini LLM. The workflow begins with `main` calling `analyze_question`, followed by `extract_relevant_passage`, `generate_answer`, and finally `verify_answer`, with each function passing its output as input to the next, using `call_llm` to interact with the LLM in each step.

Key approach aspects (full code available for reference)

            
FULL SCRIPT TO REFINE:
```python
import os
import re
import math

def main(question):
    """
    Solve the question using a multi-stage LLM approach.
    This approach focuses on breaking down the problem into question type identification, 
    focused passage extraction, and direct answer generation with verification.
    """
    try:
        # Step 1: Identify question type and keywords
        question_analysis = analyze_question(question)
        if "Error" in question_analysis:
            return "Error analyzing question"

        # Step 2: Extract relevant passage using identified keywords
        relevant_passage = extract_relevant_passage(question, question_analysis)
        if "Error" in relevant_passage:
            return "Error extracting passage"

        # Step 3: Generate answer using extracted passage and question type
        answer = generate_answer(question, relevant_passage, question_analysis)
        if "Error" in answer:
            return "Error generating answer"

        # Step 4: Verify answer
        verified_answer = verify_answer(question, answer, relevant_passage)
        if "Error" in verified_answer:
            return "Error verifying answer"
        
        return verified_answer

    except Exception as e:
        return f"General Error: {str(e)}"

def analyze_question(question):
    """Analyzes the question to identify its type and keywords. Includes multiple examples."""
    system_instruction = "You are an expert at analyzing questions to determine their type and keywords."
    prompt = f"""
    Analyze the following question and identify its type (e.g., fact extraction, calculation, comparison) and keywords.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Analysis: {{"type": "fact extraction", "keywords": ["final touchdown", "caught"]}}

    Example 2:
    Question: How many running backs ran for a touchdown?
    Analysis: {{"type": "counting", "keywords": ["running backs", "touchdown"]}}
    
    Example 3:
    Question: Which player kicked the only field goal of the game?
    Analysis: {{"type": "fact extraction", "keywords": ["player", "field goal"]}}

    Question: {question}
    Analysis:
    """
    return call_llm(prompt, system_instruction)

def extract_relevant_passage(question, question_analysis):
    """Extracts the relevant passage from the question based on keywords. Includes multiple examples."""
    system_instruction = "You are an expert at extracting relevant passages from text."
    prompt = f"""
    Extract the relevant passage from the following text based on the question and keywords.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Keywords: {{"type": "fact extraction", "keywords": ["final touchdown", "caught"]}}
    Text: PASSAGE: After a tough loss at home, the Browns traveled to take on the Packers. ... The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    Passage: The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    
    Example 2:
    Question: How many running backs ran for a touchdown?
    Keywords: {{"type": "counting", "keywords": ["running backs", "touchdown"]}}
    Text: PASSAGE: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. The Lions would respond with kicker Jason Hanson getting a 53-yard field goal. The Titans would answer with Johnson getting a 58-yard TD run, along with DE Dave Ball returning an interception 15 yards for a touchdown. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.
    Passage: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.

    Example 3:
    Question: Which player kicked the only field goal of the game?
    Keywords: {{"type": "fact extraction", "keywords": ["player", "field goal"]}}
    Text: PASSAGE: Game SummaryComing off their Thanksgiving road win over the Falcons, the Colts went home for a Week 13 AFC South rematch with the Jacksonville Jaguars.  ... In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.
    Passage: In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.

    Question: {question}
    Keywords: {question_analysis}
    Text: {question}
    Passage:
    """
    return call_llm(prompt, system_instruction)

def generate_answer(question, relevant_passage, question_analysis):
    """Generates the answer based on the question, relevant passage, and question type. Includes multiple examples."""
    system_instruction = "You are an expert at generating answers to questions based on provided text."
    prompt = f"""
    Generate the answer to the question based on the relevant passage and question type.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Passage: The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    Answer: Jarrett Boykin

    Example 2:
    Question: How many running backs ran for a touchdown?
    Passage: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. The Lions would respond with kicker Jason Hanson getting a 53-yard field goal. The Titans would answer with Johnson getting a 58-yard TD run, along with DE Dave Ball returning an interception 15 yards for a touchdown. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.
    Answer: 2
    
    Example 3:
    Question: Which player kicked the only field goal of the game?
    Passage: In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.
    Answer: Josh Scobee

    Question: {question}
    Passage: {relevant_passage}
    Answer:
    """
    return call_llm(prompt, system_instruction)

def verify_answer(question, answer, relevant_passage):
    """Verifies the generated answer. Includes multiple examples."""
    system_instruction = "You are an expert at verifying answers to questions."
    prompt = f"""
    Verify the following answer to the question based on the relevant passage.  Return the answer if it is correct.  Return the correct answer if it is incorrect.

    Example 1:
    Question: Who caught the final touchdown of the game?
    Answer: Jarrett Boykin
    Passage: The Packers would later on seal the game when Rodgers found Jarrett Boykin on a 20-yard pass for the eventual final score 31-13.
    Verification: Jarrett Boykin
    
    Example 2:
    Question: How many running backs ran for a touchdown?
    Answer: 2
    Passage: In the first quarter, Tennessee drew first blood as rookie RB Chris Johnson got a 6-yard TD run. In the second quarter, Tennessee increased their lead with RB LenDale White getting a 6-yard and a 2-yard TD run.
    Verification: 2

    Example 3:
    Question: Which player kicked the only field goal of the game?
    Answer: Josh Scobee
    Passage: In the fourth quarter, the Jaguars drew closer as kicker Josh Scobee nailed a 47-yard field goal.
    Verification: Josh Scobee

    Question: {question}
    Answer: {answer}
    Passage: {relevant_passage}
    Verification:
    """
    return call_llm(prompt, system_instruction)

def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. DO NOT deviate from this example template or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"
```

            PREVIOUSLY ATTEMPTED VARIATIONS:
            

            EXPLOITATION GUIDANCE:
            1. Review the error patterns, targeted improvements, and accumulated learnings carefully
            2. CRITICAL: Break down the problem into distinct reasoning steps before modifying code
            3. CRITICAL: Analyze the best scripts to identify which components are working well and which are failing. Focus your improvements on the weak points while preserving successful components.
            4. Maintain the core successful elements of the best approaches
            5. Consider how you can combine strengths from multiple top-performing approaches
            6. CRITICAL: Add EMBEDDED EXAMPLES to EVERY LLM prompt that illustrate:
               - Sample input that resembles the dataset
               - Step-by-step reasoning through the example
               - Properly formatted output
            7. Focus on fixing specific issues identified in previous error analyses. Create an explicit HYPOTHESIS for each targeted improvement, as well as a way to verify if it's successful.
            8. Enhance chain-of-thought reasoning and verification steps. Verification steps should be added to different parts of the pipeline in order to help deduce which parts are successful and where the system is breaking
            9. Apply the key insights from ACCUMULATED LEARNINGS to enhance the approach
            10. Pay SPECIAL ATTENTION to the weaknesses and improvement suggestions from the capability assessment

            IMPROVEMENT STRATEGY:
            Analyze why the top approaches succeeded where others failed. Identify the key differentiators and strengthen them further.

            SYSTEMATIC ENHANCEMENT APPROACH:
            1. First, identify which specific function or component is underperforming based on error analysis
            2. Examine how error cases differ from successful cases
            3. For each identified weakness, implement a targeted enhancement
            4. Add additional verification steps around modified components
            5. Consider how components interact - ensure improvements don't break successful parts

            Consider enhancing the script with one or more of these patterns:
            - Repeated validation with feedback loops
            - Multi-perspective analysis with synthesis
            - Dynamic input-dependent routing
            - Hybrid approaches combining LLM with deterministic functions
            - Best-of-n solution generation and selection
            - ReAct pattern for interactive reasoning and action
            - If it is unknown how successful a processing state or part of the pipeline is, include verification steps to different parts of the pipeline in order to help deduce which parts are successful and where the system is breaking
            - Answer checkers to validate the final answer against the problem statement. If the answer is incorrect, the checker can send the answer back to an earlier part of the system for refinement with feedback

            Here's how to call the Gemini API. Use this example without modification and don't invent configuration options:
            def call_llm(prompt, system_instruction=None):
    """Call the Gemini LLM with a prompt and return the response. DO NOT deviate from this example template or invent configuration options. This is how you call the LLM."""
    try:
        from google import genai
        from google.genai import types

        # Initialize the Gemini client
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

        # Call the API with system instruction if provided
        if system_instruction:
            response = client.models.generate_content(
                model="gemini-2.0-flash", 
                config=types.GenerateContentConfig(
                    system_instruction=system_instruction
                ),
                contents=prompt
            )
        else:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt
            )

        return response.text
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        return f"Error: {str(e)}"

            Since this is an EXPLOITATION phase:
            - Build upon what's working well in the best approaches
            - Consider creative combinations of successful techniques from different scripts
            - Make TARGETED improvements to address specific error patterns
            - For EACH key LLM prompt, include a relevant example with:
              * Sample input similar to the dataset
              * Expected reasoning steps
              * Desired output format
            - Apply the knowledge from our accumulated learnings
            - Significantly enhance the script to address weaknesses identified in the capability assessment

            CRITICAL REQUIREMENTS:
            1. The script MUST properly handle all string literals - be extremely careful with quotes and triple quotes
            2. The script MUST NOT exceed 150 lines of code to prevent truncation
            3. Include detailed comments explaining your improvements
            4. EVERY SINGLE LLM PROMPT must include at least one embedded example showing:
               - Sample input with reasoning
               - Desired output format
            5. Make proper use of error handling
            6. Implement robust capabilities to address the specific weaknesses identified in the capability assessment
            7. Do NOT use json.loads() in the LLM calls to process input data. JSON formatting is good to use to structure information as inputs and outputs, but attempting to have functions process JSON data explicitly with strict built-in functionality is error prone due to formatting issues and additional text that appears as documentation, reasoning, or comments. When passing data into another LLM call, you can read it as plain text rather than trying to load it in strict json format, is the better approach.

            Return a COMPLETE, RUNNABLE Python script that:
            1. Has a main function that takes a question string as input and returns the answer string
            2. Makes multiple LLM calls for different reasoning steps
            3. Has proper error handling for API calls
            4. Includes embedded examples in EVERY LLM prompt
            5. Is COMPLETE - no missing code, no "..." placeholders
            6. Closes all string literals properly

            BE EXTREMELY CAREFUL TO PROPERLY CLOSE ALL STRING QUOTES AND TRIPLE QUOTES!
            